"use client";

import React, { useState } from "react";
import Link from "next/link";
import ToolShell from "@/components/tools/ToolShell";
import { getToolContract } from "@/lib/tools/loadContract";
import { createToolError } from "@/components/tools/ErrorPanel";
import type { ToolContract, ExecutionMode } from "@/components/tools/ToolShell";

const contract = getToolContract("decision-log-generator");

const examples = [
  {
    title: "API Framework Selection",
    inputs: {
      decision: "Use Express.js for REST API framework",
      context: "Building a new microservice that needs to handle 10k requests/second. Team is familiar with Node.js. Need fast development velocity.",
      options: [
        "Express.js - Simple, widely used, large ecosystem",
        "Fastify - Faster performance, less middleware",
        "NestJS - Full framework, TypeScript-first, more structure",
      ],
      rationale: "Express.js chosen for team familiarity and rapid development. Performance is acceptable for current scale. Can migrate to Fastify if needed later.",
    },
  },
  {
    title: "Database Migration Strategy",
    inputs: {
      decision: "Use database migrations instead of schema sync",
      context: "Need to manage database schema changes across multiple environments (dev, staging, production). Team of 5 developers making frequent changes.",
      options: [
        "Database migrations (version controlled)",
        "Auto-sync schema on application startup",
        "Manual SQL scripts",
      ],
      rationale: "Migrations provide version control, rollback capability, and clear history. Auto-sync is too risky for production. Manual scripts lack versioning.",
    },
  },
  {
    title: "Authentication Approach",
    inputs: {
      decision: "Use OAuth 2.0 with JWT tokens",
      context: "Building a SaaS application that needs to support SSO from customer identity providers. Need stateless authentication for scalability.",
      options: [
        "OAuth 2.0 with JWT",
        "Session-based authentication",
        "API keys only",
      ],
      rationale: "OAuth 2.0 supports SSO requirements. JWT enables stateless, scalable auth. Session-based would require shared session store. API keys insufficient for user auth.",
    },
  },
];

export default function DecisionLogGeneratorPage() {
  const [decision, setDecision] = useState("");
  const [context, setContext] = useState("");
  const [options, setOptions] = useState<string[]>(["", ""]);
  const [rationale, setRationale] = useState("");

  if (!contract) {
    return (
      <div className="mx-auto max-w-4xl p-6">
        <p className="text-red-600">Tool contract not found.</p>
      </div>
    );
  }

  const handleRun = async (mode: ExecutionMode, inputs: Record<string, unknown>) => {
    const decisionInput = inputs.decision as string;
    const contextInput = inputs.context as string;
    const optionsInput = inputs.options as string[];
    const rationaleInput = inputs.rationale as string;

    if (!decisionInput || decisionInput.trim().length === 0) {
      return {
        success: false,
        error: createToolError("validation_error", "decision-log-generator", { field: "decision" }),
      };
    }

    if (optionsInput.length < 2 || optionsInput.length > 4) {
      return {
        success: false,
        error: createToolError("validation_error", "decision-log-generator", { message: "Must have 2-4 options" }),
      };
    }

    const validOptions = optionsInput.filter((o) => o.trim().length > 0);
    if (validOptions.length < 2) {
      return {
        success: false,
        error: createToolError("validation_error", "decision-log-generator", { message: "At least 2 non-empty options required" }),
      };
    }

    const markdown = `# Decision Log Entry

## Decision
${decisionInput}

## Context
${contextInput || "No context provided."}

## Options Considered
${validOptions.map((opt, idx) => `${idx + 1}. ${opt}`).join("\n")}

## Rationale
${rationaleInput || "No rationale provided."}

## Date
${new Date().toISOString().split("T")[0]}

---

*Generated by RansfordsNotes Decision Log Generator*`;

    const json = {
      decision: decisionInput,
      context: contextInput,
      options: validOptions,
      rationale: rationaleInput,
      date: new Date().toISOString(),
    };

    return {
      success: true,
      output: `## Markdown\n\n\`\`\`markdown\n${markdown}\n\`\`\`\n\n## JSON\n\n\`\`\`json\n${JSON.stringify(json, null, 2)}\n\`\`\``,
    };
  };

  const updateOption = (index: number, value: string) => {
    const newOptions = [...options];
    newOptions[index] = value;
    setOptions(newOptions);
  };

  const addOption = () => {
    if (options.length < 4) setOptions([...options, ""]);
  };

  const removeOption = (index: number) => {
    if (options.length > 2) setOptions(options.filter((_, i) => i !== index));
  };

  return (
    <div className="mx-auto max-w-6xl p-6">
      <nav className="mb-4">
        <Link href="/tools" className="text-sm font-semibold text-blue-700 hover:underline">
          ← Back to Tools
        </Link>
      </nav>

      <ToolShell contract={contract} onRun={handleRun} examples={examples} initialInputs={{ decision, context, options, rationale }}>
        <div className="space-y-4">
          <div>
            <label htmlFor="decision" className="block text-sm font-semibold text-slate-900">
              Decision <span className="text-red-600">*</span>
            </label>
            <input
              id="decision"
              type="text"
              value={decision}
              onChange={(e) => setDecision(e.target.value)}
              maxLength={200}
              className="mt-2 w-full rounded-lg border border-slate-300 p-3 text-sm focus:border-slate-500 focus:outline-none focus:ring-2 focus:ring-slate-500"
              placeholder="What was decided?"
            />
          </div>
          <div>
            <label htmlFor="context" className="block text-sm font-semibold text-slate-900">
              Context
            </label>
            <textarea
              id="context"
              value={context}
              onChange={(e) => setContext(e.target.value)}
              rows={4}
              maxLength={2000}
              className="mt-2 w-full rounded-lg border border-slate-300 p-3 text-sm focus:border-slate-500 focus:outline-none focus:ring-2 focus:ring-slate-500"
              placeholder="Constraints, goals, stakeholders..."
            />
          </div>
          <div>
            <div className="flex items-center justify-between">
              <label className="block text-sm font-semibold text-slate-900">
                Options (2-4) <span className="text-red-600">*</span>
              </label>
              {options.length < 4 && (
                <button
                  type="button"
                  onClick={addOption}
                  className="text-xs text-slate-600 underline hover:text-slate-900"
                >
                  + Add Option
                </button>
              )}
            </div>
            {options.map((opt, idx) => (
              <div key={idx} className="mt-2 flex gap-2">
                <input
                  type="text"
                  value={opt}
                  onChange={(e) => updateOption(idx, e.target.value)}
                  maxLength={500}
                  className="flex-1 rounded-lg border border-slate-300 p-2 text-sm focus:border-slate-500 focus:outline-none focus:ring-2 focus:ring-slate-500"
                  placeholder={`Option ${idx + 1}`}
                />
                {options.length > 2 && (
                  <button
                    type="button"
                    onClick={() => removeOption(idx)}
                    className="rounded-lg border border-slate-300 px-3 text-sm text-red-600 hover:bg-red-50"
                  >
                    ×
                  </button>
                )}
              </div>
            ))}
          </div>
          <div>
            <label htmlFor="rationale" className="block text-sm font-semibold text-slate-900">
              Rationale
            </label>
            <textarea
              id="rationale"
              value={rationale}
              onChange={(e) => setRationale(e.target.value)}
              rows={4}
              maxLength={2000}
              className="mt-2 w-full rounded-lg border border-slate-300 p-3 text-sm focus:border-slate-500 focus:outline-none focus:ring-2 focus:ring-slate-500"
              placeholder="Why was this option chosen? What trade-offs were considered?"
            />
          </div>
        </div>
      </ToolShell>
    </div>
  );
}

