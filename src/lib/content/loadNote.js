import fs from "fs";
import path from "path";
import matter from "gray-matter";
import { serialize } from "next-mdx-remote/serialize";
import rehypeSlug from "rehype-slug";
import rehypeAutolinkHeadings from "rehype-autolink-headings";
import rehypeKatex from "rehype-katex";
import remarkGfm from "remark-gfm";
import remarkMath from "remark-math";

const NOTES_ROOT = path.join(process.cwd(), "content", "notes");

function slugify(text) {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, "")
    .trim()
    .replace(/\s+/g, "-");
}

export async function loadNote(relativePath, extraScope = {}, options = {}) {
  const contentRoot = options.contentRoot
    ? path.isAbsolute(options.contentRoot)
      ? options.contentRoot
      : path.join(process.cwd(), "content", options.contentRoot)
    : NOTES_ROOT;
  const fullPath = path.join(contentRoot, relativePath);
  const raw = fs.readFileSync(fullPath, "utf8");
  const { content, data } = matter(raw);

  // Extract h2/h3 headings for ContentsSidebar.
  // IMPORTANT: ids must match the actual DOM ids generated by `rehype-slug`,
  // otherwise sidebar links / active tracking will feel broken.
  const headings = [];

  const collectHeadingsPlugin = () => (tree) => {
    const textFrom = (node) => {
      if (!node) return "";
      if (typeof node.value === "string") return node.value;
      if (Array.isArray(node.children)) return node.children.map(textFrom).join("");
      return "";
    };

    const walk = (node) => {
      if (!node) return;
      if (node.type === "element" && (node.tagName === "h2" || node.tagName === "h3")) {
        const depth = Number(node.tagName.slice(1));
        const id = node.properties?.id;
        const title = textFrom(node).trim();
        if (id && title && (depth === 2 || depth === 3)) {
          headings.push({ id: String(id), title, depth });
        }
      }
      if (Array.isArray(node.children)) node.children.forEach(walk);
    };

    walk(tree);
  };

  const mdxSource = await serialize(content, {
    mdxOptions: {
      remarkPlugins: [remarkGfm, remarkMath],
      rehypePlugins: [
        rehypeSlug,
        [rehypeAutolinkHeadings, { behavior: "wrap" }],
        rehypeKatex,
        collectHeadingsPlugin,
      ],
      format: "mdx",
    },
    scope: { ...data, ...extraScope },
  });

  // Fallback: if we failed to collect headings from the compiled tree, do a basic
  // markdown scan (still better than returning none).
  if (!headings.length) {
    const seen = new Map();
    content.split("\n").forEach((line) => {
      const match = /^(#{2,3})\s+(.*)/.exec(line);
      if (!match) return;
      const depth = match[1].length;
      const title = match[2].trim();
      const base = slugify(title);
      const count = (seen.get(base) || 0) + 1;
      seen.set(base, count);
      const id = count === 1 ? base : `${base}-${count}`;
      headings.push({ id, title, depth });
    });
  }

  return {
    source: mdxSource,
    headings,
    meta: {
      title: data.title || "",
      description: data.description || "",
      level: data.level || "",
      // Optional content review metadata for future Stage 8 upgrades.
      certificationDomains: data.certificationDomains || undefined,
      difficultyLevel: data.difficultyLevel || undefined,
      reviewedBy: data.reviewedBy || undefined,
      lastReviewedDate: data.lastReviewedDate || undefined,
    },
  };
}
