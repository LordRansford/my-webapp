/**
 * Project Builder Tool Execution
 * 
 * Example implementation of a tool execution route with credit enforcement.
 * This pattern should be followed for all server-side tools.
 */

import { NextRequest, NextResponse } from "next/server";
import crypto from "crypto";
import { rateLimit } from "@/lib/security/rateLimit";
import { requireAuthForServerTools, getUserIdFromSession } from "@/lib/studios/auth-gating";
import { getToolDefinition, isClientSideOnly } from "@/lib/tools/registry";
import { estimateCredits, computeAuthoritativeCharge, validateSpendLimits, getUserSpendLimits, hasSufficientCredits } from "@/lib/billing/credits";
import { getCreditBalance, consumeCredits, refundCredits } from "@/lib/billing/creditStore";
import { getUserPlan } from "@/lib/billing/access";
import { PLANS } from "@/lib/billing/plans";

export async function POST(req: NextRequest) {
  const toolId = "dev-studio-projects";
  const startTime = Date.now();

  // Rate limiting
  const rateLimitResult = rateLimit(req, {
    keyPrefix: `tool-${toolId}`,
    limit: 10,
    windowMs: 60_000,
  });
  if (rateLimitResult) return rateLimitResult;

  try {
    // Check if tool exists
    const tool = getToolDefinition(toolId);
    if (!tool) {
      return NextResponse.json(
        { error: "Tool not found", code: "TOOL_NOT_FOUND" },
        { status: 404 }
      );
    }

    // Client-side only tools don't need server execution
    if (isClientSideOnly(toolId)) {
      return NextResponse.json(
        {
          error: "This tool runs client-side only",
          code: "CLIENT_SIDE_ONLY",
          message: "No server execution needed for this tool",
        },
        { status: 400 }
      );
    }

    // Check auth requirements
    const authCheck = await requireAuthForServerTools(toolId);
    if (authCheck instanceof NextResponse) {
      return authCheck; // Error response
    }

    const userId = authCheck.userId!;
    const body = await req.json().catch(() => null);
    if (!body || typeof body !== "object") {
      return NextResponse.json(
        { error: "Invalid request body", code: "INVALID_BODY" },
        { status: 400 }
      );
    }

    // Estimate credits before execution
    const estimate = await estimateCredits(toolId, body.requestedLimits);
    if (!estimate) {
      return NextResponse.json(
        { error: "Failed to estimate credits", code: "ESTIMATE_FAILED" },
        { status: 500 }
      );
    }

    // Check if user has sufficient credits
    const creditCheck = await hasSufficientCredits(userId, estimate.max);
    if (!creditCheck.sufficient) {
      return NextResponse.json(
        {
          error: "Insufficient credits",
          code: "INSUFFICIENT_CREDITS",
          balance: creditCheck.balance,
          required: estimate.max,
          shortfall: creditCheck.shortfall,
          action: "Purchase credits or upgrade your plan",
          purchaseUrl: "/account/credits",
        },
        { status: 402 }
      );
    }

    // Validate spend limits
    const plan = await getUserPlan(userId);
    const limits = await getUserSpendLimits(userId);
    const spendCheck = await validateSpendLimits(userId, estimate.max, limits);
    if (!spendCheck.allowed) {
      return NextResponse.json(
        {
          error: "Spend limit exceeded",
          code: "SPEND_LIMIT_EXCEEDED",
          reason: spendCheck.reason,
          action: spendCheck.action,
        },
        { status: 429 }
      );
    }

    // Execute tool (placeholder - implement actual tool logic)
    let platformError = false;
    let actualUsage = { cpuMs: 0, memMb: 0, durationMs: 0 };
    let result: unknown = null;
    let error: Error | null = null;

    try {
      const executionStart = Date.now();
      const projectConfig = body.projectConfig || body.config || {};

      // Validate project configuration
      if (!projectConfig.name || typeof projectConfig.name !== "string" || projectConfig.name.trim() === "") {
        throw new Error("Project name is required");
      }

      // Generate project structure
      const projectStructure: Record<string, string> = {};
      const projectName = projectConfig.name.toLowerCase().replace(/\s+/g, "-");

      // Generate README
      projectStructure[`${projectName}/README.md`] = `# ${projectConfig.name}\n\nGenerated by Ransford's Notes Project Builder.\n\n## Getting Started\n\n\`\`\`bash\nnpm install\nnpm run dev\n\`\`\`\n`;

      // Generate package.json based on stack
      const dependencies: Record<string, string> = {};
      const devDependencies: Record<string, string> = {};
      const scripts: Record<string, string> = {};

      if (projectConfig.stack?.includes("react")) {
        dependencies.react = "^18.2.0";
        dependencies["react-dom"] = "^18.2.0";
        scripts.dev = "vite";
        scripts.build = "vite build";
      }
      if (projectConfig.stack?.includes("nextjs")) {
        dependencies.next = "^14.0.0";
        dependencies.react = "^18.2.0";
        dependencies["react-dom"] = "^18.2.0";
        scripts.dev = "next dev";
        scripts.build = "next build";
        scripts.start = "next start";
      }
      if (projectConfig.stack?.includes("express")) {
        dependencies.express = "^4.18.0";
        scripts.start = "node index.js";
        scripts.dev = "nodemon index.js";
      }
      if (projectConfig.stack?.includes("fastapi")) {
        dependencies.fastapi = "^0.104.0";
        dependencies.uvicorn = "^0.24.0";
        scripts.start = "uvicorn main:app --reload";
      }

      if (projectConfig.features?.includes("TypeScript")) {
        devDependencies.typescript = "^5.0.0";
        devDependencies["@types/node"] = "^20.0.0";
      }

      projectStructure[`${projectName}/package.json`] = JSON.stringify({
        name: projectName,
        version: "1.0.0",
        description: `Generated ${projectConfig.type || "project"}`,
        scripts,
        dependencies,
        devDependencies,
      }, null, 2);

      // Generate main files based on type
      if (projectConfig.type === "website" || projectConfig.type === "api") {
        if (projectConfig.stack?.includes("nextjs")) {
          projectStructure[`${projectName}/src/app/page.tsx`] = `export default function Home() {\n  return <div>Welcome to ${projectConfig.name}</div>;\n}\n`;
        } else if (projectConfig.stack?.includes("react")) {
          projectStructure[`${projectName}/src/App.tsx`] = `function App() {\n  return <div>Welcome to ${projectConfig.name}</div>;\n}\n\nexport default App;\n`;
        } else if (projectConfig.stack?.includes("express")) {
          projectStructure[`${projectName}/index.js`] = `const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.json({ message: 'Welcome to ${projectConfig.name}' });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n`;
        }
      }

      // Generate .gitignore
      projectStructure[`${projectName}/.gitignore`] = `node_modules/\n.env\n.env.local\n.DS_Store\n*.log\n.next/\nbuild/\ndist/\n`;

      actualUsage = {
        cpuMs: Date.now() - executionStart,
        memMb: 120,
        durationMs: Date.now() - executionStart,
      };

      result = {
        success: true,
        projectStructure,
        projectName: projectConfig.name,
        projectType: projectConfig.type,
        stack: projectConfig.stack || [],
        features: projectConfig.features || [],
        fileCount: Object.keys(projectStructure).length,
      };
    } catch (execError) {
      error = execError instanceof Error ? execError : new Error("Execution failed");
      platformError = true; // Platform error = refund
    }

    // Calculate authoritative charge
    const chargeResult = computeAuthoritativeCharge(toolId, actualUsage, platformError);
    const runId = crypto.randomUUID();

    // Charge or refund credits
    if (chargeResult.refunded) {
      // This shouldn't happen for new runs, but handle it
      return NextResponse.json(
        {
          error: "Platform error",
          code: "PLATFORM_ERROR",
          message: chargeResult.reason,
          refunded: true,
        },
        { status: 500 }
      );
    }

    if (chargeResult.charge > 0) {
      try {
        const { consumeCredits } = await import("@/lib/billing/creditStore");
        await consumeCredits(userId, chargeResult.charge, toolId, runId, {
          estimated: estimate.typical,
          actual: chargeResult.charge,
          usage: actualUsage,
        });
      } catch (creditError) {
        // If credit consumption fails, this is a platform error - refund
        return NextResponse.json(
          {
            error: "Credit processing failed",
            code: "CREDIT_PROCESSING_ERROR",
            message: "Your credits were not charged. Please try again.",
          },
          { status: 500 }
        );
      }
    }

    // Get updated balance
    const { getCreditBalance } = await import("@/lib/billing/creditStore");
    const balance = await getCreditBalance(userId);

    // Return result
    return NextResponse.json({
      success: true,
      runId,
      result,
      credits: {
        estimated: estimate.typical,
        charged: chargeResult.charge,
        balance,
      },
      executionTime: Date.now() - startTime,
    });
  } catch (error) {
    console.error("Tool execution error:", error);
    return NextResponse.json(
      {
        error: "Internal server error",
        code: "INTERNAL_ERROR",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
