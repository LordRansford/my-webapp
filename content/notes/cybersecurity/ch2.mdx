---
title: "Cybersecurity Notes - Chapter 2"
description: "How I understand networks: packets, latency, DNS, TLS, and where trust fails." 
level: "intermediate"
---

import ToolCard from "@/components/notes/ToolCard"
import { Callout } from "@/components/notes/Callout"
import { DeeperDive } from "@/components/notes/DeeperDive"
import { MathBlock, MathInline } from "@/components/notes/Math"
import { FlowDiagram, LayerDiagram, TimelineDiagram, BoundaryDiagram, ComparisonDiagram } from "@/components/notes/diagrams"
import Quiz from "@/components/Quiz"
import Recap from "@/components/notes/Recap"
import {
  PacketJourneyTool,
  LbtSimulator,
  InterceptionExplorer,
  DNSJourney,
  HandshakeExplorer,
  CertificateChainExplorer,
  IntegrityLab,
  MiniIncidentSimulator,
} from "@/components/notes/cybersecurity/chapter2-tools"

# Cybersecurity Notes

## Chapter 2 - How Information Moves and How Trust Is Built

In Chapter 1, I learned that data is physical and security is harm reduction. Now I follow the data as it leaves one machine, crosses shared space, and returns. I want to know where trust is assumed, how to measure it, and how to fix it when it fails.

<Callout type="memory" title="My reminder">Networks are shared spaces, not private tunnels.</Callout>

---

## From messages to packets

Messages are chopped into packets so many devices can share links and recover from loss. Packets can be delayed, dropped, duplicated, or reordered. Reliability is rebuilt by protocols, not the wire.

<FlowDiagram title="Packet journey" steps={["Message", "Segments", "Packets", "Frames", "Signals"]} />

<Callout type="note" title="Trade-offs">
Small packets waste overhead; large packets make loss expensive. I choose sizes based on loss patterns and MTU.
</Callout>

<MathBlock formula={"\\text{Packets} = \frac{\\text{Message size}}{\\text{Packet size}}"} />

<ToolCard title="Packet journey" description="See how messages split and reassemble." lazy>
  <PacketJourneyTool />
</ToolCard>

<Quiz
  title="Packets and loss"
  questions={[
    { id: "p1", prompt: "Why split messages?", options: [ { id: "a", text: "Share links and recover loss", correct: true, explanation: "Packets interleave traffic and allow partial resend." }, { id: "b", text: "Make data smaller", correct: false, explanation: "Total data size stays similar." } ] },
    { id: "p2", prompt: "What happens to out-of-order packets?", options: [ { id: "a", text: "Protocols reorder", correct: true, explanation: "TCP reassembles." }, { id: "b", text: "They are discarded", correct: false, explanation: "Not always; TCP reorders." } ] },
    { id: "p3", prompt: "Why do large packets hurt on loss?", options: [ { id: "a", text: "More data must be resent", correct: true, explanation: "Retransmission cost grows." }, { id: "b", text: "Routers dislike them", correct: false, explanation: "Cost, not dislike." } ] },
    { id: "p4", prompt: "Which property is hit by dropped packets?", options: [ { id: "a", text: "Availability", correct: true, explanation: "Service can stutter." }, { id: "b", text: "Font choice", correct: false, explanation: "Aesthetics unaffected." } ] },
    { id: "p5", prompt: "Why do I care about MTU?", options: [ { id: "a", text: "Avoid fragmentation", correct: true, explanation: "Fragmentation risks loss." }, { id: "b", text: "For decoration", correct: false, explanation: "MTU is technical." } ] },
  ]}
/>

---

## The three numbers that rule networks

Latency, bandwidth, and throughput describe constraints. Latency is travel time. Bandwidth is capacity. Throughput is what I actually get after loss and protocol overhead.

<ComparisonDiagram
  title="Latency vs bandwidth"
  left={{ label: "Latency", detail: "Time per trip" }}
  right={{ label: "Bandwidth", detail: "Capacity per second" }}
/>

<MathBlock formula={"1\\ \text{MB} = 8\\ \text{Mb}"} />

<ToolCard title="Latency / bandwidth simulator" description="See how latency, loss, and bandwidth interact." lazy>
  <LbtSimulator />
</ToolCard>

<Quiz
  title="Latency, bandwidth, throughput"
  questions={[
    { id: "l1", prompt: "Why convert MB to Mb?", options: [ { id: "a", text: "Links are measured in bits", correct: true, explanation: "Network speeds use bits." }, { id: "b", text: "To confuse", correct: false, explanation: "It is a convention." } ] },
    { id: "l2", prompt: "What limits TLS handshakes most?", options: [ { id: "a", text: "Latency", correct: true, explanation: "Round trips matter." }, { id: "b", text: "Disk speed", correct: false, explanation: "Disks are not in the handshake path." } ] },
    { id: "l3", prompt: "Throughput falls when?", options: [ { id: "a", text: "Loss increases", correct: true, explanation: "Retransmissions drop throughput." }, { id: "b", text: "Screen is dim", correct: false, explanation: "Display does not matter." } ] },
    { id: "l4", prompt: "Why add buffers carefully?", options: [ { id: "a", text: "Too much causes bloat", correct: true, explanation: "Bufferbloat raises latency." }, { id: "b", text: "Buffers delete data", correct: false, explanation: "They store, not delete." } ] },
    { id: "l5", prompt: "How long for 5 MB on 20 Mbps?", options: [ { id: "a", text: "~2 seconds", correct: true, explanation: "5 MB = 40 Mb; 40/20=2s ideal." }, { id: "b", text: "~0.2 seconds", correct: false, explanation: "Too optimistic." } ] },
  ]}
/>

---

## Where attacks can occur in transit

Data hops across networks, each hop with its own trust boundary. An attacker positioned at a hop can observe, modify, or block traffic.

<BoundaryDiagram
  title="Trust boundary"
  inside={["Client", "ISP", "Resolver"]}
  outside={["Open Wi-Fi", "Rogue gateway", "Compromised router"]}
/>

<ToolCard title="Interception explorer" description="See what each attacker position can do." lazy>
  <InterceptionExplorer />
</ToolCard>

<Quiz
  title="Transit threats"
  questions={[
    { id: "t1", prompt: "Why is public Wi-Fi risky?", options: [ { id: "a", text: "Shared broadcast domain", correct: true, explanation: "Easy to observe traffic." }, { id: "b", text: "Better coffee", correct: false, explanation: "Coffee is unrelated." } ] },
    { id: "t2", prompt: "Which goal does DoS attack?", options: [ { id: "a", text: "Availability", correct: true, explanation: "It takes service down." }, { id: "b", text: "Colour", correct: false, explanation: "Aesthetics again." } ] },
    { id: "t3", prompt: "What mitigates spoofing on local nets?", options: [ { id: "a", text: "Port security / 802.1X", correct: true, explanation: "Tie identity to port." }, { id: "b", text: "Bigger fonts", correct: false, explanation: "Fonts do nothing." } ] },
    { id: "t4", prompt: "Why still use TLS on trusted networks?", options: [ { id: "a", text: "Threats may exist inside", correct: true, explanation: "Inside attacks happen." }, { id: "b", text: "TLS is faster", correct: false, explanation: "Speed not main reason." } ] },
    { id: "t5", prompt: "What is authenticity loss?", options: [ { id: "a", text: "Talking to the wrong party", correct: true, explanation: "Authenticity is about identity." }, { id: "b", text: "Packet delay", correct: false, explanation: "Delay is availability." } ] },
  ]}
/>

---

## DNS as a trust decision

DNS maps names to IP addresses. It is a trust step: if DNS lies, the padlock can still appear while I talk to the wrong server.

<FlowDiagram title="DNS flow" steps={["Query", "Resolver", "Root/TLD", "Authoritative", "Response"]} />

<ToolCard title="DNS journey" description="Walk through resolution and poisoning." lazy>
  <DNSJourney />
</ToolCard>

<Quiz
  title="DNS depth"
  questions={[
    { id: "d1", prompt: "Why cache DNS?", options: [ { id: "a", text: "Reduce latency", correct: true, explanation: "Caching speeds lookups." }, { id: "b", text: "Remove trust", correct: false, explanation: "Trust still required." } ] },
    { id: "d2", prompt: "What if cache is poisoned?", options: [ { id: "a", text: "Users go to attacker", correct: true, explanation: "Wrong IP returned." }, { id: "b", text: "Page loads faster", correct: false, explanation: "Fast to wrong host is still wrong." } ] },
    { id: "d3", prompt: "Why does padlock still show?", options: [ { id: "a", text: "TLS to attacker domain still valid", correct: true, explanation: "TLS secures the wrong endpoint." }, { id: "b", text: "Browser bug", correct: false, explanation: "It is expected if cert matches host." } ] },
    { id: "d4", prompt: "What reduces DNS risk?", options: [ { id: "a", text: "DNSSEC, DoH/DoT, pinned IPs", correct: true, explanation: "They harden resolution." }, { id: "b", text: "Changing fonts", correct: false, explanation: "Not relevant." } ] },
    { id: "d5", prompt: "What is a resolver?", options: [ { id: "a", text: "Server that looks up names", correct: true, explanation: "It resolves names to IPs." }, { id: "b", text: "A firewall", correct: false, explanation: "Different role." } ] },
  ]}
/>

---

## Encryption protects secrecy, not identity

Encryption keeps content secret but does not prove who I am talking to. I still need authentication and key agreement with good entropy.

<FlowDiagram title="Handshake steps" steps={["Hello", "Keys", "Verify", "Secure channel"]} />

<ToolCard title="TLS handshake" description="Step through the handshake." lazy>
  <HandshakeExplorer />
</ToolCard>

<Quiz
  title="Encryption depth"
  questions={[
    { id: "e1", prompt: "What does encryption guarantee?", options: [ { id: "a", text: "Confidentiality", correct: true, explanation: "It hides content." }, { id: "b", text: "Identity", correct: false, explanation: "Identity needs certificates." } ] },
    { id: "e2", prompt: "Why is entropy vital for keys?", options: [ { id: "a", text: "Predictable keys are guessable", correct: true, explanation: "Weak randomness breaks secrecy." }, { id: "b", text: "It makes keys pretty", correct: false, explanation: "Aesthetics again." } ] },
    { id: "e3", prompt: "How can encryption be misused?", options: [ { id: "a", text: "Encrypted phishing", correct: true, explanation: "TLS can hide malicious traffic." }, { id: "b", text: "It stops all attacks", correct: false, explanation: "It is one control only." } ] },
    { id: "e4", prompt: "Why handshakes?", options: [ { id: "a", text: "Agree keys and identity", correct: true, explanation: "They set secrets and trust." }, { id: "b", text: "Add latency", correct: false, explanation: "Latency is side effect." } ] },
    { id: "e5", prompt: "What does perfect secrecy still lack?", options: [ { id: "a", text: "Assurance of who I talk to", correct: true, explanation: "Identity separate." }, { id: "b", text: "Maths", correct: false, explanation: "Maths is present." } ] },
  ]}
/>

---

## Certificates and trust chains

Certificates bind keys to identities using a chain of trust. A warning ignored is a trust failure even if encryption stays strong.

<BoundaryDiagram title="Trust chain" inside={["Leaf cert", "Intermediate", "Root"]} outside={["User", "Rogue CA"]} />

<ToolCard title="Certificate chain" description="Inspect a chain and simulate failure." lazy>
  <CertificateChainExplorer />
</ToolCard>

<Quiz
  title="Certificates"
  questions={[
    { id: "c1", prompt: "What is a trust anchor?", options: [ { id: "a", text: "Root CA", correct: true, explanation: "Roots anchor trust." }, { id: "b", text: "User browser", correct: false, explanation: "Browser stores anchors." } ] },
    { id: "c2", prompt: "Why do certs expire?", options: [ { id: "a", text: "Limit risk window", correct: true, explanation: "Expiry forces renewal." }, { id: "b", text: "To sell more", correct: false, explanation: "Security reason first." } ] },
    { id: "c3", prompt: "What if a CA is compromised?", options: [ { id: "a", text: "Chain trust breaks", correct: true, explanation: "All issued certs suspect." }, { id: "b", text: "Nothing", correct: false, explanation: "It is serious." } ] },
    { id: "c4", prompt: "Why heed browser warnings?", options: [ { id: "a", text: "They signal trust failure", correct: true, explanation: "Warnings matter." }, { id: "b", text: "They are decoration", correct: false, explanation: "Not cosmetic." } ] },
    { id: "c5", prompt: "What binds name to key?", options: [ { id: "a", text: "Certificate subject/ SAN", correct: true, explanation: "Identity fields." }, { id: "b", text: "Cipher suite", correct: false, explanation: "Cipher is unrelated." } ] },
  ]}
/>

---

## Integrity in transit

Hashes detect change. Adding a shared secret (MAC) ties integrity to identity. Integrity does not encrypt; it prevents undetected tampering.

<ToolCard title="Integrity lab" description="See how tampering is caught." lazy>
  <IntegrityLab />
</ToolCard>

<Quiz
  title="Integrity"
  questions={[
    { id: "i1", prompt: "Why plain hash is not enough?", options: [ { id: "a", text: "Anyone can recompute", correct: true, explanation: "Hash alone lacks identity." }, { id: "b", text: "Hashes are secret", correct: false, explanation: "Hashes are public." } ] },
    { id: "i2", prompt: "What does MAC add?", options: [ { id: "a", text: "Shared secret", correct: true, explanation: "Secret binds identity." }, { id: "b", text: "Longer messages", correct: false, explanation: "MAC is about trust." } ] },
    { id: "i3", prompt: "Which goal is this?", options: [ { id: "a", text: "Integrity", correct: true, explanation: "Tamper detection." }, { id: "b", text: "Confidentiality", correct: false, explanation: "MAC does not hide." } ] },
    { id: "i4", prompt: "Why keep keys separate?", options: [ { id: "a", text: "Limit blast radius", correct: true, explanation: "Separation helps." }, { id: "b", text: "Because RAM is free", correct: false, explanation: "Not the reason." } ] },
    { id: "i5", prompt: "What is replay?", options: [ { id: "a", text: "Old valid message resent", correct: true, explanation: "Integrity needs freshness." }, { id: "b", text: "New message", correct: false, explanation: "Replay is reuse." } ] },
  ]}
/>

---

## Practice studio

Put it together: phishing plus DNS manipulation plus cert warnings plus credential theft. Decide quickly, but justify.

<ToolCard title="Mini incident simulator" description="Practice reasoning under uncertainty." lazy>
  <MiniIncidentSimulator />
</ToolCard>

<Recap
  title="Chapter 2 recap"
  points={[
    "Packets and loss shape reliability; MTU and retransmission matter.",
    "Latency, bandwidth, and throughput pull in different directions.",
    "DNS is a trust step; padlocks do not prove name truth.",
    "Encryption hides content but identity needs certificates and chains.",
    "Integrity needs secrets when identity matters; hashes alone are not enough.",
  ]}
  terms={["Latency", "Bandwidth", "Throughput", "DNS", "TLS", "Certificate", "MAC", "MTU"]}
  actions={[
    "Measure real latency and loss before tuning packet size.",
    "Harden DNS with DNSSEC/DoH and monitor cache integrity.",
    "Treat TLS warnings as incidents; review trust anchors.",
    "Use MACs or AEAD when integrity plus identity is needed.",
  ]}
/>
