---
title: "Cybersecurity Notes - Chapter 1"
description: "Foundations I had to learn the hard way: harm, risk, bits, hashes, and why simple practice matters."
level: "beginner"
---

import ToolCard from "@/components/notes/ToolCard"
import { Callout } from "@/components/notes/Callout"
import { DeeperDive } from "@/components/notes/DeeperDive"
import { PrintSummary } from "@/components/notes/PrintSummary"
import { MathBlock, MathInline } from "@/components/notes/Math"
import { FlowDiagram, LayerDiagram, TimelineDiagram, BoundaryDiagram } from "@/components/notes/diagrams"
import SecurityGoalsSorter from "@/components/notes/tools/cybersecurity/ch1/SecurityGoalsSorter"
import RiskDial from "@/components/notes/tools/cybersecurity/ch1/RiskDial"
import BitFlipVisualizer from "@/components/notes/tools/cybersecurity/ch1/BitFlipVisualizer"
import BitPositionExplorer from "@/components/notes/tools/cybersecurity/ch1/BitPositionExplorer"
import BinaryCarryTrainer from "@/components/notes/tools/cybersecurity/ch1/BinaryCarryTrainer"
import EncodingInspector from "@/components/notes/tools/cybersecurity/ch1/EncodingInspector"
import HashAvalancheVisualizer from "@/components/notes/tools/cybersecurity/ch1/HashAvalancheVisualizer"
import EntropySimulator from "@/components/notes/tools/cybersecurity/ch1/EntropySimulator"
import Quiz from "@/components/Quiz"

# Cybersecurity Notes

## Chapter 1 - Foundations

I wrote these notes because I was confused by security jargon. I needed a place to reason things out: why harm happens, how risk is judged, how bits become meaning, and how maths underpins trust. I learn best by making small changes, seeing what breaks, and then generalising. That is the flow here.

---

## Why security exists at all

I treat cybersecurity as harm reduction. Systems fail and people make hurried decisions. If I can predict where harm appears, I can design to reduce it.

<FlowDiagram
  title="Harm chain"
  steps={[
    "Signal or data",
    "Interpretation",
    "Decision",
    "Action",
    "Outcome"
  ]}
/>

<Callout type="memory" title="What I remind myself">
Security is not perfection. It is making sure small failures do not become big harms.
</Callout>

<ToolCard title="Sort harms" description="Classify incidents by the main harm I see first." lazy>
  <SecurityGoalsSorter />
</ToolCard>

<Quiz
  title="Quick check"
  questions={[
    {
      id: "harm",
      prompt: "What do I protect when I think about cybersecurity?",
      options: [
        { id: "a", text: "Only secrets", correct: false, explanation: "Secrets matter but so do integrity and uptime." },
        { id: "b", text: "Information and the outcomes that depend on it", correct: true, explanation: "Harm appears when outcomes fail, not just when secrets leak." }
      ]
    }
  ]}
/>

---

## CIA triad in my own words

The Study Notes stress confidentiality, integrity, and availability. I keep them as a tension diagram: pushing one can stress the others.

<BoundaryDiagram
  title="CIA triad"
  zones={[
    { label: "Confidentiality", detail: "Only the right people can see" },
    { label: "Integrity", detail: "What I read is correct" },
    { label: "Availability", detail: "It works when needed" }
  ]}
/>

- **Confidentiality**: I stop unintended disclosure. Encryption and access controls help, but people, misconfigurations, and logs can leak.
- **Integrity**: I need assurance that data is not tampered. Hashes, signatures, and checksums help, but only if keys and code paths are trusted.
- **Availability**: If a service is down, security fails its purpose. Redundancy, throttling, and graceful degradation matter.

<DeeperDive title="Common mistakes I made">
I once encrypted a backup without checking restore. I achieved confidentiality and lost availability. Balance the three, do not chase one.
</DeeperDive>

<Quiz
  title="Triad micro quiz"
  questions={[
    {
      id: "triad1",
      prompt: "Which event is mostly about integrity?",
      options: [
        { id: "a", text: "API responds slowly", correct: false, explanation: "Slow responses hit availability." },
        { id: "b", text: "Invoice total silently changes", correct: true, explanation: "Silent change is an integrity failure." }
      ]
    }
  ]}
/>

---

## Identity and accountability

The Study Notes emphasise IAAA: identification, authentication, authorisation, accountability. I use it as a flow when thinking about access.

<FlowDiagram
  title="IAAA flow"
  steps={["Claim who I am", "Prove it", "Check what I can do", "Log what I did"]}
/>

- **Identification**: I present a claim (email, badge ID).
- **Authentication**: I prove it (password, token, biometrics). MFA is simply using more than one factor: something I know, have, or am.
- **Authorisation**: The system checks the actions I can take. Least privilege is the default: only the rights I need, only when I need them.
- **Accountability**: Logs make actions traceable. Without logs, disputes become opinions.

<ToolCard title="Risk dial" description="See how likelihood and impact combine." lazy>
  <RiskDial />
</ToolCard>

<Quiz
  title="Identity check"
  questions={[
    {
      id: "iaaa1",
      prompt: "Where does MFA sit?",
      options: [
        { id: "a", text: "Authentication", correct: true, explanation: "MFA strengthens proof of identity." },
        { id: "b", text: "Authorisation", correct: false, explanation: "Authorisation decides actions after login." }
      ]
    }
  ]}
/>

---

## Risk in numbers I can reason with

I avoided formulas until I understood the story. Now I use one simple equation:

<MathBlock formula={"Risk = \\text{Likelihood} \times \\text{Impact}"} />

<Callout type="note" title="How I read it">
If either likelihood or impact is near zero, risk is near zero. I do not over-fit false precision.
</Callout>

I work small examples to internalise it:

- Phishing that lands monthly with small clean-up: <MathInline formula={"0.5 \times 2 = 1"} />
- Ransomware once a year but catastrophic: <MathInline formula={"0.05 \times 50 = 2.5"} />

<TimelineDiagram
  title="Harm story"
  events={[
    { label: "Probe", detail: "Scan or phish" },
    { label: "Access", detail: "Credential or exploit" },
    { label: "Impact", detail: "Encrypt, exfil, disrupt" },
    { label: "Recovery", detail: "Restore and learn" }
  ]}
/>

---

## Bits, bytes, and why position matters

I struggled with binary until I flipped bits by hand. A bit is a physical state. Stacking bits doubles choices each time:

<MathBlock formula={"2^8 = 256"} />

<ToolCard title="Bit flip" description="See how bits affect value." lazy>
  <BitFlipVisualizer />
</ToolCard>

<ToolCard title="Bit position" description="Which bit moves the value most?" lazy>
  <BitPositionExplorer />
</ToolCard>

<ToolCard title="Carry practice" description="Practice base-2 addition." lazy>
  <BinaryCarryTrainer />
</ToolCard>

<Quiz
  title="Binary check"
  questions={[
    {
      id: "bin1",
      prompt: "What happens when I flip the leftmost bit in an 8-bit number?",
      options: [
        { id: "a", text: "It adds 128", correct: true, explanation: "Most significant bit doubles the range." },
        { id: "b", text: "It adds 1", correct: false, explanation: "The rightmost bit adds 1." }
      ]
    }
  ]}
/>

---

## Encoding and meaning

Bytes are just numbers. Meaning appears when I apply an encoding like UTF-8.

<LayerDiagram
  title="Encoding stack"
  layers={[
    { label: "Idea" },
    { label: "Characters" },
    { label: "Bytes" },
    { label: "Signals" }
  ]}
/>

<ToolCard title="Encoding inspector" description="See how text becomes bytes." lazy>
  <EncodingInspector />
</ToolCard>

---

## Hashes and integrity

Hashes reassure me that data stayed the same. One changed bit should shift many output characters (avalanche).

<Callout type="tip" title="Why I trust hashes carefully">
A hash proves integrity if I trust the key path and algorithm choice. MD5 and SHA-1 are broken for collisions; I use SHA-256 or better.
</Callout>

<ToolCard title="Hash avalanche" description="See how tiny changes alter a hash." lazy>
  <HashAvalancheVisualizer />
</ToolCard>

<Quiz
  title="Hash check"
  questions={[
    {
      id: "hash1",
      prompt: "Why is hashing not encryption?",
      options: [
        { id: "a", text: "Hashing is one-way", correct: true, explanation: "I cannot reverse a good hash." },
        { id: "b", text: "Hashing hides keys", correct: false, explanation: "Keys are not involved." }
      ]
    }
  ]}
/>

---

## Entropy and guessing effort

I remember entropy as the difficulty of guessing. Length beats clever substitutions.

<MathBlock formula={"H = L \times \log_2(N)"} />

<ToolCard title="Entropy simulator" description="See how length and charset change effort." lazy>
  <EntropySimulator />
</ToolCard>

---

## Practice studio

- Match incidents to harms using the sorter, then explain each choice aloud.
- Flip bits and predict values before checking.
- Encode emoji and note byte length changes.
- Hash a sentence, change one character, count differences.
- Adjust entropy slider until it feels hard to guess, then explain why.

---

## Checkpoint quiz

<Quiz
  title="Chapter 1 checkpoint"
  questions={[
    {
      id: "chk1",
      prompt: "What makes risk drop fastest in the simple formula?",
      options: [
        { id: "a", text: "Reducing likelihood or impact towards zero", correct: true, explanation: "Either factor near zero collapses the product." },
        { id: "b", text: "Changing units", correct: false, explanation: "Units do not change the product." }
      ]
    },
    {
      id: "chk2",
      prompt: "Why do I treat availability as security?",
      options: [
        { id: "a", text: "Because downtime is harm", correct: true, explanation: "If users cannot use a service, security failed its purpose." },
        { id: "b", text: "Because availability is only performance", correct: false, explanation: "Security must preserve service, not just speed." }
      ]
    },
    {
      id: "chk3",
      prompt: "What does UTF-8 change?",
      options: [
        { id: "a", text: "It maps characters to bytes", correct: true, explanation: "Encoding turns symbols into byte sequences." },
        { id: "b", text: "It encrypts text", correct: false, explanation: "Encoding is not encryption." }
      ]
    }
  ]}
/>

<PrintSummary
  title="Chapter 1 â€“ what I carry forward"
  bullets={[
    "Harm reduction is the goal; I balance confidentiality, integrity, availability.",
    "Risk is a product, not a vibe; small changes in either factor can dominate.",
    "Bits are physical states; position controls weight.",
    "Encoding gives meaning; hashing gives integrity if the path is trusted.",
    "Entropy favours length and variety; guessing effort is maths, not myth."
  ]}
/>
