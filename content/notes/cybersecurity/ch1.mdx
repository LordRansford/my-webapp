---
title: "Cybersecurity Notes: Beginner"
description: "My beginner notes. Calm, detailed, and practical. I start at what data is and build up to networks, trust, and the foundations of secure systems."
level: "beginner"
---

import ProgressBar from '@/components/notes/ProgressBar'
import PageNav from '@/components/notes/PageNav'
import ToolCard from '@/components/notes/ToolCard'
import Callout from '@/components/notes/Callout'
import GlossaryTip from '@/components/notes/GlossaryTip'
import QuizBlock from '@/components/notes/QuizBlock'

import BitChangeTool from '@/components/notes/tools/cybersecurity/ch1/BitChangeTool'
import EncodingExplorerTool from '@/components/notes/tools/cybersecurity/ch1/EncodingExplorerTool'
import UnicodeBytesTool from '@/components/notes/tools/cybersecurity/ch1/UnicodeBytesTool'
import CIAClassifierTool from '@/components/notes/tools/cybersecurity/ch1/CIAClassifierTool'
import TrustBoundaryTool from '@/components/notes/tools/cybersecurity/ch1/TrustBoundaryTool'
import IntegrityChainTool from '@/components/notes/tools/cybersecurity/ch1/IntegrityChainTool'
import PacketJourneyTool from '@/components/notes/tools/cybersecurity/ch1/PacketJourneyTool'
import MetadataLeakTool from '@/components/notes/tools/cybersecurity/ch1/MetadataLeakTool'
import EncryptionPlacementTool from '@/components/notes/tools/cybersecurity/ch1/EncryptionPlacementTool'
import PasswordEntropyTool from '@/components/notes/tools/cybersecurity/ch1/PasswordEntropyTool'
import HashFingerprintTool from '@/components/notes/tools/cybersecurity/ch1/HashFingerprintTool'

<ProgressBar mode="scroll" />

# Cybersecurity Notes  
## Beginner  
### Page 1 of 4  Foundations that make everything else make sense

<Callout variant="concept">
Before I talk about hackers, tools, or encryption, I start with what data is. If I do not understand data and meaning, I cannot understand security.
</Callout>

<PageNav
  prevHref="/notes/cybersecurity/roadmap"
  prevLabel="Roadmap"
  nextHref="/cybersecurity/intermediate"
  nextLabel="Next page  Intermediate"
  showTop
  showBottom
/>

---

## Section 1  What data really is and why security starts here

<Callout variant="concept">
Data is not information. Data is a physical state that I choose to interpret as information.
</Callout>

### What I mean by physical state
I do not see words, pictures, money, or passwords. A computer detects physical conditions.

Examples of physical conditions:
- electrical voltage being low or high
- a tiny magnetic region pointing one way or another
- a light pulse being present or absent
- microscopic electrical charge being trapped or not trapped

Computers are designed to treat these conditions as stable states so they can work reliably.

<GlossaryTip term="Physical state">
A physical state is the condition something is in. In computing it usually means a measurable signal such as voltage, charge, light, or magnetism.
</GlossaryTip>

### Bits  the smallest unit of data
A bit is the smallest unit of data. It represents one of two possible states, which we write as 0 and 1.

Mathematically:

\[
b \in \{0,1\}
\]

This means b can only be 0 or 1. This is not scary maths. It is simply describing a designed constraint.

### Why computers use two states
A common question is why computers use base 2 rather than base 10. The reason is reliability. Real physical signals get disturbed.

That disturbance is called noise.

<GlossaryTip term="Noise">
Noise means any unwanted disturbance that changes a signal. Like trying to hear a whisper in a loud room, interference makes the message harder to interpret.
</GlossaryTip>

Noise matters because noise can flip bits. If a system does not detect that, integrity fails quietly.

### Bytes and powers of two
Bits become useful when grouped. 8 bits is a byte.

A byte has:

\[
2^8 = 256
\]

possible patterns. Each extra bit doubles possibilities, which later becomes the heart of password strength and cryptographic key sizes.

### Worked example  why doubling matters
With 3 bits there are:

\[
2^3 = 8
\]

patterns:
000 001 010 011 100 101 110 111

Every time I add one bit, I double the patterns. That is exponential growth. Attackers fear exponential growth because it makes brute force guessing infeasible.

### Practice tool  single bit change
<ToolCard
  title="See how one tiny bit change alters meaning"
  description="Flip one bit and watch how interpretation changes. This is the simplest way to feel what integrity means."
>
  <BitChangeTool />
</ToolCard>

### Quiz and checks
<QuizBlock
  title="Check your understanding"
  questions={[
    { q: "What is a physical state in computing", a: "A measurable condition such as voltage, charge, magnetism, or light, used to represent data." },
    { q: "What is a bit", a: "The smallest unit of data, representing one of two states, usually written 0 or 1." },
    { q: "What is noise", a: "Unwanted disturbance that changes a signal and can cause misinterpretation." },
    { q: "Why do computers prefer two states", a: "Two states are easier to separate reliably under noise, heat, and imperfect hardware." },
    { q: "What does 2^8 represent", a: "The number of unique patterns possible with 8 bits, which is 256." }
  ]}
/>

<PageNav showTop showBottom />

---

## Section 2  From raw data to meaning  encoding and interpretation

<Callout variant="concept">
Encoding is representation. Encryption is secrecy. Confusing them causes real security failures.
</Callout>

### What encoding does
Encoding is a shared agreement that maps bit patterns to symbols.

If I show you 01000001, it means nothing unless we agree on a scheme. Under ASCII, it maps to A.

<GlossaryTip term="Encoding">
Encoding is a rule for representing symbols using bits. It is designed for compatibility and representation, not secrecy.
</GlossaryTip>

### ASCII and positional notation
ASCII assigns numbers to characters. For A, ASCII uses decimal 65.

Binary is base 2 positional notation. Each position represents a power of two. 65 is 64 plus 1, so in binary it becomes 01000001.

<Callout variant="explain">
Positional notation means the position of a digit determines its value. In base 10, 345 means 3 hundreds, 4 tens, 5 ones. In base 2, each position is a power of two.
</Callout>

#### Common ASCII examples

| Character | Decimal | Binary | Hex | Notes |
|-----------|---------|--------|-----|-------|
| A | 65 | 01000001 | 41 | Uppercase letter |
| a | 97 | 01100001 | 61 | Lowercase letter |
| 0 | 48 | 00110000 | 30 | Digit zero |
| Space | 32 | 00100000 | 20 | Whitespace |
| Newline | 10 | 00001010 | 0A | Line break |

This table shows how the same bit pattern means different things depending on the encoding scheme. Security problems appear when systems assume one encoding but receive another.

### Hex  how engineers read binary
Binary is hard to read. Hex is base 16 and compresses binary safely. One hex digit represents 4 bits because 2^4 is 16. That is why bytes display as two hex digits, and why hashes are usually shown in hex.

<GlossaryTip term="Hexadecimal">
Hexadecimal is base 16 representation using digits 0 to 9 and letters A to F. It is a compact way to show bytes and cryptographic values.
</GlossaryTip>

#### Hex digit to binary mapping

| Hex | Binary | Decimal | Notes |
|-----|--------|---------|-------|
| 0 | 0000 | 0 | Lowest value |
| 1 | 0001 | 1 | |
| 5 | 0101 | 5 | |
| A | 1010 | 10 | First letter |
| F | 1111 | 15 | Highest single hex digit |
| FF | 11111111 | 255 | Full byte in hex |

Notice how one hex digit covers exactly 4 bits. This makes hex perfect for displaying bytes, hashes, and keys compactly.

### Unicode and UTF 8
ASCII is too small for the world. Unicode assigns numbers to characters globally. UTF 8 is a way to encode Unicode values into bytes.

Key idea:
- some characters use 1 byte
- others use 2, 3, or 4 bytes

So character count is not always byte count. Attackers exploit this when validation counts characters but enforcement counts bytes. That is a canonicalisation problem.

#### UTF 8 byte length examples

| Character | Unicode code point | UTF 8 bytes | Hex representation | Notes |
|-----------|-------------------|-------------|-------------------|-------|
| A | U+0041 | 1 byte | 41 | ASCII compatible |
| Ã© | U+00E9 | 2 bytes | C3 A9 | Latin with accent |
| ä¸­ | U+4E2D | 3 bytes | E4 B8 AD | Chinese character |
| ðŸš€ | U+1F680 | 4 bytes | F0 9F 9A 80 | Emoji |

This variable length is why character limits and byte limits can differ. Security bugs appear when validation uses one but enforcement uses the other.

<GlossaryTip term="Canonicalisation">
Canonicalisation means converting data to a standard form. Security bugs appear when two parts of a system standardise differently and interpret the same input in different ways.
</GlossaryTip>

### Practice tools  encoding and Unicode
<ToolCard
  title="Explore how text becomes bytes, binary, and hex"
  description="Type text and see its representation. This makes interpretation visible."
>
  <EncodingExplorerTool />
</ToolCard>

<ToolCard
  title="See how Unicode can change byte length"
  description="Compare characters that look similar but encode differently. This is where real parsing bugs begin."
>
  <UnicodeBytesTool />
</ToolCard>

### Quiz
<QuizBlock
  title="Check your understanding"
  questions={[
    { q: "Why is encoding not security", a: "Because encoding is reversible with public rules. It does not hide information." },
    { q: "What is the difference between Unicode and UTF 8", a: "Unicode defines characters and code points. UTF 8 defines how those code points become bytes." },
    { q: "Why does hex matter in security", a: "It is a compact, precise way to display bytes, hashes, and keys." },
    { q: "What is a canonicalisation problem", a: "When systems interpret the same input differently because they normalise or parse it differently." }
  ]}
/>

<PageNav showTop showBottom />

---

## Section 3  Security properties and trust  what being secure actually means

<Callout variant="concept">
Security is about preserving properties, even when people make mistakes and attackers try to break things.
</Callout>

### Security properties
A security property is something I want to remain true under stress.

The beginner framework is CIA:
- confidentiality  prevent unauthorised disclosure
- integrity  prevent unauthorised or undetected modification
- availability  keep systems usable when needed

#### Security properties at a glance

| Property | What it protects | Example failure | Common defence |
|----------|----------------|-----------------|----------------|
| Confidentiality | Secrecy of information | Password leaked in logs | Encryption, access controls |
| Integrity | Correctness and authenticity | Data modified without detection | Hashes, signatures, checksums |
| Availability | Usability when needed | System down due to attack | Redundancy, rate limiting |
| Authenticity | Genuine origin | Fake email claiming to be from bank | Digital signatures, certificates |
| Authorisation | Permission to act | User accessing admin functions | Access control lists, roles |

This table helps you classify security failures. When something goes wrong, ask which property failed and why.

<GlossaryTip term="Confidentiality">
Confidentiality means keeping information secret from unauthorised people.
</GlossaryTip>

<GlossaryTip term="Integrity">
Integrity means keeping information correct and detecting tampering. Silent integrity failures are especially dangerous.
</GlossaryTip>

<GlossaryTip term="Availability">
Availability means systems are usable when needed. Outages and denial of service are security failures when they cause harm.
</GlossaryTip>

### CIA is not enough  add authenticity and authorisation
Authenticity asks whether something is genuinely what it claims to be.

Authentication is proving who you are. Authorisation is what you are allowed to do. Many failures happen when authentication is fine but authorisation is broken.

<GlossaryTip term="Authentication">
Authentication is proving identity. Examples include passwords, biometrics, and cryptographic proofs.
</GlossaryTip>

<GlossaryTip term="Authorisation">
Authorisation is permission. It answers what actions are allowed after identity is known.
</GlossaryTip>

### Trust and trust boundaries
Trust is an assumption. A trust boundary is where assumptions change. Any input crossing into a system is a trust boundary. Any network hop is a trust boundary. Attackers live at boundaries.

<GlossaryTip term="Trust boundary">
A place where data or control moves between components with different levels of trust. Validation and checks must occur here.
</GlossaryTip>

### Integrity chains
Integrity is rarely protected once. Systems use layers like hashes, signatures, and logs. An integrity chain helps me understand how trust can be preserved or destroyed across time.

### Practice tools  classify and explore trust
<ToolCard
  title="Classify security failures using CIA"
  description="Pick the property that failed and explain why. This builds correct instincts."
>
  <CIAClassifierTool />
</ToolCard>

<ToolCard
  title="Find trust boundaries in a system"
  description="See where assumptions change and where checks must exist."
>
  <TrustBoundaryTool />
</ToolCard>

<ToolCard
  title="See how integrity checks catch or miss tampering"
  description="Modify data and observe what breaks. This prepares you for hashing and signatures later."
>
  <IntegrityChainTool />
</ToolCard>

### Quiz
<QuizBlock
  title="Check your understanding"
  questions={[
    { q: "Why is availability a security issue", a: "Because unusable systems cause harm and can be exploited through denial of service or ransomware." },
    { q: "What is the difference between authentication and authorisation", a: "Authentication proves identity. Authorisation controls permissions after identity is known." },
    { q: "What is a trust boundary", a: "Where assumptions change, such as user input entering a server or one service calling another." },
    { q: "Why are integrity failures dangerous", a: "Because systems and people keep trusting incorrect data, so damage accumulates silently." }
  ]}
/>

<PageNav showTop showBottom />

---

## Section 4  Networks and data movement  where attacks live

<Callout variant="concept">
Most security failures happen while data is moving, not while it sits still.
</Callout>

### What a network is
A network is a system that lets computers exchange data. At the lowest level it uses electricity, light, or radio waves to carry bits.

### Packets  why data is split
Large data is split into packets because:
- errors can be detected and retransmitted
- routing is possible
- congestion can be managed

A packet usually contains:
- payload  the actual content
- headers  addressing and control data

<GlossaryTip term="Packet">
A packet is a small chunk of data sent across a network with headers that help route and reassemble it.
</GlossaryTip>

### Layering and OSI
Layering separates concerns. The OSI model is a teaching model with 7 layers. I do not memorise it to sound clever. I use it to locate problems and controls.

### Metadata leakage
Even if payload is encrypted, metadata can reveal behaviour:
- who talks to whom
- when and how often
- message size patterns

That supports traffic analysis and targeting.

<GlossaryTip term="Metadata">
Metadata is information about data, such as sender, timing, size, and routing headers. It often remains visible even when content is encrypted.
</GlossaryTip>

### Where encryption fits
Encryption protects payload confidentiality, not everything. Encryption placement affects what observers can learn. This leads naturally into intermediate topics like TLS, VPNs, and zero trust.

### Practice tools  packet journey and leakage
<ToolCard
  title="Follow a packet from sender to receiver"
  description="Watch splitting, headers, routing, and reassembly. This makes networking real."
>
  <PacketJourneyTool />
</ToolCard>

<ToolCard
  title="See what leaks even when content is encrypted"
  description="Explore how metadata alone can reveal sensitive patterns."
>
  <MetadataLeakTool />
</ToolCard>

<ToolCard
  title="Explore encryption placement through the layers"
  description="Move encryption through layers and observe what it protects and what it does not."
>
  <EncryptionPlacementTool />
</ToolCard>

### Bonus practice  passwords and hashes  bridge to intermediate
<ToolCard
  title="Password strength and guessing time"
  description="See how search space grows and why length wins. This leads into cryptographic key sizes later."
>
  <PasswordEntropyTool />
</ToolCard>

<ToolCard
  title="Hash fingerprints and the avalanche effect"
  description="Change one character and see the fingerprint change completely. This prepares you for integrity and signatures."
>
  <HashFingerprintTool />
</ToolCard>

### Final beginner quiz
<QuizBlock
  title="Beginner mastery check"
  questions={[
    { q: "Why are packets used", a: "To manage errors, routing, congestion, and efficiency rather than sending one huge block." },
    { q: "What is the difference between payload and headers", a: "Payload is the content. Headers carry addressing and control data needed for delivery." },
    { q: "What can metadata reveal", a: "Communication patterns such as who, when, how often, and approximate activity, even without content." },
    { q: "Does encryption hide metadata", a: "Usually no. It mainly protects payload confidentiality. Headers and timing often remain visible." },
    { q: "Why does understanding networks lead to zero trust", a: "Because internal networks cannot be assumed safe. Every hop is a boundary and must be verified." }
  ]}
/>

<Callout variant="concept">
Beginner complete. If I can explain these four sections clearly, I am ready to study how attackers exploit them and how defenders design controls.
</Callout>

<PageNav
  prevHref="/notes/cybersecurity/roadmap"
  prevLabel="Roadmap"
  nextHref="/cybersecurity/intermediate"
  nextLabel="Next page  Intermediate"
  showTop
  showBottom
/>
