// Phase 5 baseline schema
// - PostgreSQL for production (Neon) - DATABASE_URL from environment
// - Structure is Postgres-native (no translation needed)
//
// Identity model (passwordless):
// - User = email + provider id (providerAccountId)
// - Email is the primary identifier for humans; internal `id` is a stable UUID

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model UserIdentity {
  // Use the same stable id as NextAuth's `user.id` (session.user.id).
  // This keeps cross-device progress keyed to the auth identity without leaking tokens client-side.
  id                String   @id
  email             String   @unique
  provider          String
  providerAccountId String
  createdAt         DateTime @default(now())
  lastLoginAt       DateTime @default(now())
  adminRole         String?  // OWNER | ADMIN | SUPPORT | READ_ONLY (null means not an admin)
  accountStatus     String   @default("active") // active | suspended | pending
  lastActiveAt      DateTime @default(now())

  cpdState  CpdState?
  progress  Progress[]
  credits   Credits?
  creditUsage CreditUsageEvent[]
  creditLots CreditLot[]
  projects  Project[]
  
  // AI Studio relations
  datasets  Dataset[]
  models    Model[]
  trainingJobs TrainingJob[]
  agents    Agent[]
  agentExecutions AgentExecution[]
  deployments Deployment[]
  
  // Assessment and Certificate relations
  assessmentAttempts AssessmentAttempt[]
  assessmentSessions AssessmentSession[]
  certificates Certificate[]
  learnerProfile LearnerProfile?

  @@index([provider, providerAccountId])
}

model LearnerProfile {
  userId          String   @id
  certificateName String
  lockedAt        DateTime @default(now())

  user UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SupportTicket {
  id          String   @id @default(cuid())
  userId      String?
  name        String?
  email       String?
  category    String
  message     String
  status      String   @default("open") // open | in_progress | resolved
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  attachments SupportTicketAttachment[]
  notes       SupportTicketNote[]

  @@index([status, createdAt])
  @@index([category, createdAt])
  @@index([userId, createdAt])
}

model SupportTicketAttachment {
  id           String   @id @default(cuid())
  ticketId     String
  fileName     String
  mimeType     String
  sizeBytes    Int
  storageKey   String?  // stored outside repo (blob, s3, etc)
  createdAt    DateTime @default(now())

  ticket SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId, createdAt])
}

model SupportTicketNote {
  id          String   @id @default(cuid())
  ticketId    String
  adminUserId String
  note        String
  createdAt   DateTime @default(now())

  ticket SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId, createdAt])
}

model Credits {
  userId    String   @id
  balance   Int      @default(0)
  expiresAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CreditUsageEvent {
  id         String   @id @default(cuid())
  userId     String
  toolId     String
  consumed   Int
  units      Int
  freeUnits  Int
  paidUnits  Int
  runId            String?
  baseFree         Boolean  @default(false)
  estimatedCredits Int      @default(0)
  actualCredits    Int      @default(0)
  meteringUnit     String   @default("ms") // "ms" initially
  durationMs       Int      @default(0)
  inputBytes       Int      @default(0)
  outputBytes      Int      @default(0)
  freeTierAppliedMs Int     @default(0)
  paidMs           Int      @default(0)
  occurredAt DateTime @default(now())

  user UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, occurredAt])
  @@index([toolId, occurredAt])
  @@index([runId])
}

model CreditLedgerEvent {
  id          String   @id @default(cuid())
  userId      String
  type        String // credit_grant | credit_purchase_pending | credit_purchase_completed | credit_spent | credit_refund | credit_expired | admin_adjustment
  amountPence Int // positive or negative
  reason      String
  toolId      String?
  runId       String?
  createdAt   DateTime @default(now())
  createdBy   String? // admin id

  @@index([userId, createdAt])
  @@index([type, createdAt])
  @@index([runId])
}

model ToolRun {
  id                 String   @id @default(cuid())
  userId             String?  // null for anonymous
  toolId             String
  courseId           String?
  pageId             String?
  inputSizeBytes     Int?
  computeUnits       Int      @default(0)
  computeMs          Int      @default(0)
  costPence          Int      @default(0)
  freeTierCoveredPence Int    @default(0)
  paidTierChargedPence Int    @default(0)
  status             String   @default("success") // success | failed | blocked_insufficient_credit
  createdAt          DateTime @default(now())
  metadata           Json?

  @@index([userId, createdAt])
  @@index([toolId, createdAt])
  @@index([status, createdAt])
}

model StripeWebhookEvent {
  id           String   @id @default(cuid())
  stripeEventId String  @unique
  eventType    String
  receivedAt   DateTime @default(now())

  @@index([receivedAt])
  @@index([eventType, receivedAt])
}

model Job {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  userId          String?
  anonKey         String?
  toolId          String
  status          String   @default("queued") // queued | running | succeeded | failed | denied | cancelled

  inputBytes      Int?
  startedAt       DateTime?
  finishedAt      DateTime?
  durationMs      Int?

  estimatedCostCredits Int?
  chargedCredits  Int?
  freeTierAppliedMs Int?

  requestId       String?
  idempotencyKey  String?  @unique

  errorCode       String?
  errorMessage    String?
  errorStack      String?

  outputRef       String?
  payloadJson     Json?
  resultJson      Json?

  events          JobEvent[]

  @@index([status, createdAt])
  @@index([toolId, createdAt])
  @@index([userId, createdAt])
  @@index([anonKey, createdAt])
}

model JobEvent {
  id        String   @id @default(cuid())
  jobId     String
  createdAt DateTime @default(now())
  level     String   @default("info") // info | warn | error
  message   String
  data      Json?

  job Job @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId, createdAt])
}

model DailyUsage {
  id            String   @id @default(cuid())
  dayUtc        String   // YYYY-MM-DD
  userId        String?
  anonKey       String?
  toolId        String?
  usedMs        Int      @default(0)
  usedCredits   Int      @default(0)
  requestCount  Int      @default(0)
  lastRequestAt DateTime?

  @@unique([dayUtc, userId, anonKey, toolId])
  @@index([dayUtc, userId])
  @@index([dayUtc, anonKey])
}

model WorkspaceSession {
  id        String   @id @default(cuid())
  tokenHash String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  projects Project[]
}

model Project {
  id               String   @id @default(cuid())
  ownerId          String?  // null means anonymous
  workspaceSessionId String?
  title            String
  topic            String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  owner    UserIdentity?    @relation(fields: [ownerId], references: [id], onDelete: SetNull)
  session  WorkspaceSession? @relation(fields: [workspaceSessionId], references: [id], onDelete: Cascade)

  runs        Run[]
  attachments Attachment[]
  notes       Note[]

  @@index([ownerId, updatedAt])
  @@index([workspaceSessionId, updatedAt])
  @@index([topic, updatedAt])
}

model Run {
  id         String   @id @default(cuid())
  projectId  String
  toolId     String
  status     String   @default("queued") // queued | running | succeeded | failed | denied | cancelled | aborted
  startedAt  DateTime?
  finishedAt DateTime?

  inputJson   Json?
  outputJson  Json?
  metricsJson Json?
  errorJson   Json?

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  attachments Attachment[]
  notes       Note[]

  @@index([projectId, startedAt])
  @@index([toolId, startedAt])
}

model Attachment {
  id         String   @id @default(cuid())
  projectId  String
  runId      String?
  filename   String
  mimeType   String
  sizeBytes  Int
  storageKey String
  createdAt  DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  run     Run?    @relation(fields: [runId], references: [id], onDelete: SetNull)

  @@index([projectId, createdAt])
  @@index([runId, createdAt])
}

model Note {
  id        String   @id @default(cuid())
  projectId String
  runId     String?
  content   String
  createdAt DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  run     Run?    @relation(fields: [runId], references: [id], onDelete: SetNull)

  @@index([projectId, createdAt])
  @@index([runId, createdAt])
}

model CreditLot {
  id            String   @id @default(cuid())
  userId        String
  credits       Int // legacy total credits granted (kept for compatibility)
  amountCredits Int      @default(0)
  remainingCredits Int   @default(0)
  source        String
  stripeEventId String?
  stripePriceId String?
  stripeCheckoutSessionId String?
  stripePaymentIntentId   String?
  purchasedAt    DateTime @default(now())
  expiresAt     DateTime?
  createdAt     DateTime @default(now())

  user UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([stripeEventId])
  @@index([stripeCheckoutSessionId])
}

model Purchase {
  id              String   @id @default(cuid())
  userId          String
  productId       String
  stripeSessionId String   @unique
  stripeEventId   String   @unique
  status          String
  createdAt       DateTime @default(now())
}

model CertificateEntitlement {
  id              String   @id @default(cuid())
  userId          String
  courseId        String
  status          String // "not_requested" | "pending_payment" | "eligible" | "issued"
  stripeSessionId String?  @unique
  issuedAt        DateTime?
  issuedCertificateId String? @unique
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId, courseId])
}

model CourseCompletionEvidence {
  id           String   @id @default(cuid())
  userId       String
  courseId     String
  evidenceType String // "progress" | "quiz" | "tool" | "manual"
  payload      Json
  createdAt    DateTime @default(now())

  @@index([userId, courseId])
}

model CertificateIssuance {
  id            String   @id @default(cuid())
  userId        String
  courseId      String
  certificateId String   @unique // RN-AI-FOUND-2026-000123
  entitlementId String
  issuedAt      DateTime @default(now())
  revokedAt     DateTime?
  revokedReason String?
  pdfStorageKey String
  pdfSha256     String
  version       Int      @default(1)
  metadata      Json?
}

model CourseCompletion {
  id            String   @id @default(cuid())
  userId        String
  courseId      String
  courseVersion String
  completedAt   DateTime @default(now())
  score         Int?
  passed        Boolean  @default(true)

  @@index([userId])
  @@unique([userId, courseId, courseVersion])
}

model Certificate {
  id              String   @id @default(cuid())
  userId          String
  courseId        String
  courseVersion   String
  levelId         String?  // Added for tier-based certificates
  issuedAt        DateTime @default(now())
  certificateHash String   @unique
  pdfKey          String
  creditsUsed     Int
  issuer          String   @default("RansfordsNotes")
  status          String   @default("issued") // "issued" | "revoked"
  createdAt       DateTime @default(now())
  
  // Enhanced fields for CPD certificates
  cpdHours        Float?
  score           Int?
  blockchainHash  String?  @unique
  verificationUrl String?
  
  user            UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@unique([userId, courseId, courseVersion])
  @@index([levelId])
}

model AuditEvent {
  id          String   @id @default(cuid())
  actorUserId String?
  action      String // "CERT_REQUESTED" | "CERT_PAYMENT_CONFIRMED" | "CERT_ISSUED" | "CERT_DOWNLOADED" | "EVIDENCE_RECORDED"
  entityType  String // "certificate" | "evidence"
  entityId    String?
  details     Json?
  ip          String?
  userAgent   String?
  createdAt   DateTime @default(now())
}

model AdminAuditLog {
  id           String   @id @default(cuid())
  adminUserId  String
  adminRole    String
  actionType   String
  targetType   String
  targetId     String?
  reason       String
  timestamp    DateTime @default(now())
  ipAddress    String?
  userAgent    String?  // truncated in app layer

  @@index([adminUserId, timestamp])
  @@index([actionType, timestamp])
  @@index([targetType, timestamp])
}

model FeedbackSubmission {
  id          String   @id @default(cuid())
  sessionId   String?
  name        String?
  source      String
  pageUrl     String
  pageTitle   String?
  category    String?
  followUp    String?
  clientSummary String?
  message     String
  screenshotName String?
  screenshotType String?
  screenshotDataUrl String?
  submittedAt DateTime @default(now())

  @@index([submittedAt])
  @@index([source])
  @@index([sessionId])
}

model CpdState {
  userId    String   @id
  stateJson String
  updatedAt DateTime @updatedAt

  user UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Progress {
  id        String   @id @default(cuid())
  userId    String
  courseId  String
  levelId   String
  sectionId String
  completed Boolean  @default(false)
  minutes   Int      @default(0)
  updatedAt DateTime @updatedAt

  user UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId, levelId, sectionId])
  @@index([userId, courseId, levelId])
}

// ============================================================================
// AI Studio Models
// ============================================================================

model Dataset {
  id              String   @id @default(cuid())
  userId          String
  name            String
  description     String?
  type            String   // csv, json, jsonl, parquet, hdf5
  size            Int      // Using Int instead of BigInt for SQLite compatibility
  rows            Int?
  columns         Int?
  filePath        String
  license         String
  licenseVerified Boolean  @default(false)
  status          String   @default("uploading") // uploading, processing, verified, rejected, deleted
  schema          Json?
  statistics      Json?
  qualityScore    Float?
  validationResult Json?
  metadata        Json     @default("{}")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  deletedAt       DateTime?

  user            UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)
  trainingJobs    TrainingJob[]
  modelEvaluations ModelEvaluation[]
  trainedModels   Model[]

  @@index([userId])
  @@index([status])
  @@index([license])
  @@index([createdAt])
}

model Model {
  id                String   @id @default(cuid())
  userId            String
  name              String
  description       String?
  type              String   // classification, regression, clustering, generation, other
  architecture      Json
  status            String   @default("created") // created, training, trained, failed, deployed, archived
  version           String   @default("1.0.0")
  trainingDatasetId String?
  trainingConfig    Json?
  metrics           Json?
  modelPath         String?
  modelSize         Int?      // Using Int instead of BigInt for SQLite compatibility
  metadata          Json     @default("{}")
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  trainedAt         DateTime?
  deletedAt         DateTime?

  user              UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)
  trainingDataset   Dataset? @relation(fields: [trainingDatasetId], references: [id])
  evaluations       ModelEvaluation[]
  trainingJobs      TrainingJob[]
  deployments       Deployment[]

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([trainingDatasetId])
  @@index([createdAt])
}

model TrainingJob {
  id              String   @id @default(cuid())
  userId          String
  modelId         String
  datasetId       String
  status          String   @default("queued") // queued, running, completed, failed, cancelled
  computeType     String   @default("browser") // browser, backend
  config          Json
  progress        Float    @default(0)
  currentEpoch    Int?
  totalEpochs     Int?
  metrics         Json?
  metricsHistory  Json?
  errorMessage    String?
  workerId        String?
  startedAt       DateTime?
  completedAt     DateTime?
  durationSeconds Int?
  cost            Float?   // Using Float instead of Decimal for SQLite compatibility
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)
  model           Model @relation(fields: [modelId], references: [id], onDelete: Cascade)
  dataset         Dataset @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([modelId])
  @@index([status])
  @@index([createdAt])
}

model ModelEvaluation {
  id            String   @id @default(cuid())
  modelId       String
  datasetId     String
  metrics       Json
  confusionMatrix Json?
  perClassMetrics Json?
  createdAt     DateTime @default(now())

  model         Model    @relation(fields: [modelId], references: [id], onDelete: Cascade)
  dataset       Dataset  @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@index([modelId])
  @@index([datasetId])
  @@index([createdAt])
}

model Agent {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?
  type        String   // single, multi, hierarchical, collaborative
  modelConfig Json
  tools       Json
  memoryConfig Json?
  systemPrompt String?
  workflow    Json?
  status      String   @default("active") // active, paused, archived
  metadata    Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?

  user        UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)
  executions  AgentExecution[]

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
}

model AgentExecution {
  id            String   @id @default(cuid())
  agentId       String
  userId        String
  input         String
  output        String?
  status        String   @default("running") // running, completed, failed, cancelled
  steps         Json?
  cost          Float?   // Using Float instead of Decimal for SQLite compatibility
  tokensUsed    Int?
  durationSeconds Int?
  errorMessage  String?
  startedAt     DateTime @default(now())
  completedAt   DateTime?

  agent         Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
  user          UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([agentId])
  @@index([userId])
  @@index([status])
  @@index([startedAt])
}

model Deployment {
  id          String   @id @default(cuid())
  userId      String
  modelId     String
  name        String
  target      String   // api, browser, container, edge
  status      String   @default("deploying") // deploying, active, scaling, failed, stopped
  url         String?
  config      Json
  replicas    Int      @default(1)
  metrics     Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?

  user        UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)
  model       Model    @relation(fields: [modelId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([modelId])
  @@index([status])
  @@index([target])
}



// Assessment system for course evaluations
model Assessment {
  id            String   @id @default(cuid())
  courseId      String
  levelId       String   // foundations, intermediate, advanced
  passThreshold Int      @default(80)
  timeLimit     Int?     // minutes
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  questions     Question[]
  attempts      AssessmentAttempt[]
  sessions      AssessmentSession[]

  @@unique([courseId, levelId])
  @@index([courseId])
  @@index([levelId])
}

model Question {
  id               String       @id @default(cuid())
  assessmentId     String
  type             String       // MCQ, MultiResponse, Scenario, Practical
  bloomLevel       Int          // 1-6
  difficultyTarget Float        // 0.3-0.85 (percentage who get it right)
  discriminationIndex Float?    // How well it distinguishes high vs low performers
  question         String       // The question text
  options          String?      // JSON array for MCQ/MultiResponse
  correctAnswer    String       // JSON (single value or array)
  explanation      String       // Detailed explanation of the correct answer
  tags             String       // Comma-separated tags
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  assessment       Assessment   @relation(fields: [assessmentId], references: [id], onDelete: Cascade)

  @@index([assessmentId])
  @@index([bloomLevel])
  @@index([type])
}

model AssessmentAttempt {
  id            String   @id @default(cuid())
  userId        String
  assessmentId  String
  courseVersion String // course version at time of attempt
  questionIds   String // JSON array of served question ids in order
  score         Int      // Percentage
  passed        Boolean
  answers       String   // JSON of user answers
  timeSpent     Int      // seconds
  completedAt   DateTime @default(now())

  user          UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)
  assessment    Assessment   @relation(fields: [assessmentId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([assessmentId])
  @@index([passed])
  @@index([completedAt])
  @@index([courseVersion])
}

model AssessmentSession {
  id           String   @id @default(cuid())
  userId       String
  assessmentId String
  questionIds  String   // JSON array of question ids in order
  startedAt    DateTime @default(now())
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user       UserIdentity @relation(fields: [userId], references: [id], onDelete: Cascade)
  assessment Assessment   @relation(fields: [assessmentId], references: [id], onDelete: Cascade)

  @@unique([userId, assessmentId])
  @@index([userId])
  @@index([assessmentId])
  @@index([expiresAt])
}
