{
  "version": 3,
  "sources": [],
  "debugId": "94f99a25-67f9-fb58-2f46-95a6265ef863",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../src/lib/games/framework/SeededRNG.ts","../../../../src/lib/games/games/governance-simulator/GovernanceSimulator.tsx/__nextjs-internal-proxy.mjs","../../../../src/lib/games/games/governance-simulator/index.ts","../../../../src/lib/games/games/governance-simulator/scenarioGenerator.ts","../../../../src/lib/games/games/governance-simulator/stakeholderEngine.ts","../../../../src/lib/games/games/governance-simulator/riskEngine.ts","../../../../src/lib/games/games/governance-simulator/gameState.ts","../../../../src/lib/games/games/governance-simulator/persistence.ts","../../../../src/lib/games/games/governance-simulator/explainabilityAnalyzer.ts","../../../../src/app/games/governance-simulator/page.tsx"],"sourcesContent":["/**\n * Seeded Random Number Generator\n * \n * Uses Linear Congruential Generator (LCG) for deterministic randomness.\n * Same seed always produces same sequence - essential for daily puzzles and replays.\n * \n * Based on technical architecture specification for gold-standard implementation.\n */\n\nexport class SeededRNG {\n  private state: number;\n  \n  constructor(seed: number) {\n    // Ensure seed is positive integer\n    this.state = Math.abs(Math.floor(seed)) || 1;\n  }\n  \n  /**\n   * Generate next random number [0, 1)\n   */\n  next(): number {\n    // LCG: (a * state + c) mod m\n    // Using constants from Numerical Recipes\n    this.state = (this.state * 1664525 + 1013904223) % 2**32;\n    return this.state / 2**32;\n  }\n  \n  /**\n   * Generate random integer in range [min, max] (inclusive)\n   */\n  nextInt(min: number, max: number): number {\n    return Math.floor(this.next() * (max - min + 1)) + min;\n  }\n  \n  /**\n   * Generate random float in range [min, max)\n   */\n  nextFloat(min: number, max: number): number {\n    return min + this.next() * (max - min);\n  }\n  \n  /**\n   * Shuffle array deterministically (Fisher-Yates)\n   */\n  shuffle<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(this.next() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n  \n  /**\n   * Weighted random selection\n   * @param items Array of items to choose from\n   * @param weights Array of weights (must match items length)\n   * @returns Selected item\n   */\n  weightedChoice<T>(items: T[], weights: number[]): T {\n    if (items.length !== weights.length) {\n      throw new Error('Items and weights arrays must have same length');\n    }\n    \n    const totalWeight = weights.reduce((sum, w) => sum + w, 0);\n    if (totalWeight === 0) {\n      throw new Error('Total weight must be greater than 0');\n    }\n    \n    let random = this.next() * totalWeight;\n    \n    for (let i = 0; i < items.length; i++) {\n      random -= weights[i];\n      if (random <= 0) return items[i];\n    }\n    \n    // Fallback (should never reach here, but TypeScript requires it)\n    return items[items.length - 1];\n  }\n  \n  /**\n   * Choose random item from array\n   */\n  choice<T>(array: T[]): T {\n    if (array.length === 0) {\n      throw new Error('Cannot choose from empty array');\n    }\n    return array[this.nextInt(0, array.length - 1)];\n  }\n  \n  /**\n   * Sample n items from array without replacement\n   */\n  sample<T>(array: T[], n: number): T[] {\n    if (n > array.length) {\n      throw new Error('Sample size cannot be larger than array length');\n    }\n    \n    const indices = new Set<number>();\n    const result: T[] = [];\n    \n    while (indices.size < n) {\n      const index = this.nextInt(0, array.length - 1);\n      if (!indices.has(index)) {\n        indices.add(index);\n        result.push(array[index]);\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get current state (for save/restore)\n   */\n  getState(): number {\n    return this.state;\n  }\n  \n  /**\n   * Restore state (for replay)\n   */\n  setState(state: number): void {\n    this.state = Math.abs(Math.floor(state)) || 1;\n  }\n  \n  /**\n   * Create a new RNG instance with same seed (for testing/debugging)\n   */\n  clone(): SeededRNG {\n    const cloned = new SeededRNG(this.state);\n    return cloned;\n  }\n}\n\n/**\n * Generate daily seed from date string (YYYY-MM-DD UTC)\n */\nexport function getDailySeed(): number {\n  const today = new Date();\n  const year = today.getUTCFullYear();\n  const month = String(today.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(today.getUTCDate()).padStart(2, '0');\n  const dateStr = `${year}-${month}-${day}`;\n  \n  // Simple hash function (FNV-1a inspired)\n  let hash = 2166136261; // FNV offset basis\n  for (let i = 0; i < dateStr.length; i++) {\n    hash ^= dateStr.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  \n  return Math.abs(hash >>> 0); // Convert to unsigned 32-bit integer\n}\n\n/**\n * Generate variant seed for different difficulty tiers\n * Same base seed with different variants produces different but deterministic sequences\n */\nexport function getDailySeedVariant(baseSeed: number, variant: string): number {\n  let hash = 2166136261;\n  for (let i = 0; i < variant.length; i++) {\n    hash ^= variant.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  return (baseSeed ^ hash) >>> 0; // XOR for variant\n}\n\n/**\n * Hash string to number (simple implementation)\n */\nexport function hashString(str: string): number {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash);\n}\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/lib/games/games/governance-simulator/GovernanceSimulator.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/games/games/governance-simulator/GovernanceSimulator.tsx\",\n    \"default\",\n);\n","/**\n * Governance Simulator - Exports\n */\n\nexport { default } from './GovernanceSimulator';\nexport * from './types';\nexport * from './scenarioGenerator';\nexport * from './stakeholderEngine';\nexport * from './riskEngine';\nexport * from './gameState';\nexport * from './persistence';\nexport * from './explainabilityAnalyzer';\n","/**\n * Governance Simulator - Scenario Generator\n */\n\nimport { SeededRNG } from '@/lib/games/framework/SeededRNG';\nimport type { Scenario, Stakeholder, Objective, Risk, Event, ScenarioType, Difficulty } from './types';\n\nexport function generateScenario(\n  seed: number,\n  scenarioType: ScenarioType,\n  difficulty: Difficulty\n): Scenario {\n  const rng = new SeededRNG(seed);\n  const config = getDifficultyConfig(difficulty);\n  \n  const stakeholders = generateStakeholders(config.stakeholderCount, rng);\n  const objectives = generateObjectives(config.objectiveCount, stakeholders, rng);\n  const initialRisks = generateRisks(config.riskCount, rng);\n  const events = generateEvents(config.totalTurns, config, rng);\n  \n  return {\n    id: `scenario-${seed}`,\n    name: getScenarioName(scenarioType),\n    description: getScenarioDescription(scenarioType, difficulty),\n    type: scenarioType,\n    difficulty,\n    totalTurns: config.totalTurns,\n    stakeholders,\n    objectives,\n    initialRisks,\n    events,\n  };\n}\n\ninterface DifficultyConfig {\n  stakeholderCount: number;\n  objectiveCount: number;\n  riskCount: number;\n  totalTurns: number;\n  eventFrequency: number;\n}\n\nfunction getDifficultyConfig(difficulty: Difficulty): DifficultyConfig {\n  switch (difficulty) {\n    case 'foundations':\n      return {\n        stakeholderCount: 2,\n        objectiveCount: 2,\n        riskCount: 2,\n        totalTurns: 8,\n        eventFrequency: 0.2,\n      };\n    case 'intermediate':\n      return {\n        stakeholderCount: 3,\n        objectiveCount: 3,\n        riskCount: 3,\n        totalTurns: 10,\n        eventFrequency: 0.3,\n      };\n    case 'advanced':\n      return {\n        stakeholderCount: 4,\n        objectiveCount: 4,\n        riskCount: 4,\n        totalTurns: 12,\n        eventFrequency: 0.4,\n      };\n    case 'expert':\n      return {\n        stakeholderCount: 5,\n        objectiveCount: 5,\n        riskCount: 5,\n        totalTurns: 12,\n        eventFrequency: 0.5,\n      };\n  }\n}\n\nfunction generateStakeholders(count: number, rng: SeededRNG): Stakeholder[] {\n  const types: Stakeholder['type'][] = [\n    'data-team',\n    'security-team',\n    'compliance-team',\n    'business-team',\n    'executive',\n  ];\n  \n  const stakeholders: Stakeholder[] = [];\n  for (let i = 0; i < count; i++) {\n    const type = types[i % types.length];\n    stakeholders.push({\n      id: `stakeholder-${i}`,\n      name: `${type} ${i + 1}`,\n      type,\n      trust: 70 + rng.next() * 20, // 70-90\n      satisfaction: 70 + rng.next() * 20,\n      compliance: 80 + rng.next() * 15,\n      preferences: {\n        controls: type === 'security-team' ? 80 : type === 'data-team' ? 40 : 60,\n        transparency: type === 'executive' ? 90 : 60,\n        autonomy: type === 'data-team' ? 80 : 50,\n      },\n    });\n  }\n  \n  return stakeholders;\n}\n\nfunction generateObjectives(\n  count: number,\n  stakeholders: Stakeholder[],\n  rng: SeededRNG\n): Objective[] {\n  const types: Objective['type'][] = ['trust', 'compliance', 'innovation', 'cost'];\n  const objectives: Objective[] = [];\n  \n  for (let i = 0; i < count; i++) {\n    const type = types[i % types.length];\n    objectives.push({\n      id: `objective-${i}`,\n      name: `${type} Objective`,\n      description: `Maintain ${type} above threshold`,\n      type,\n      target: 75,\n      current: 70 + rng.next() * 10,\n      met: false,\n    });\n  }\n  \n  return objectives;\n}\n\nfunction generateRisks(count: number, rng: SeededRNG): Risk[] {\n  const types: Risk['type'][] = ['privacy', 'security', 'compliance', 'innovation', 'cost'];\n  const risks: Risk[] = [];\n  \n  for (let i = 0; i < count; i++) {\n    const type = types[i % types.length];\n    risks.push({\n      id: `risk-${i}`,\n      name: `${type} Risk`,\n      type,\n      level: 30 + rng.next() * 30, // 30-60\n      trend: rng.next() < 0.33 ? 'increasing' : rng.next() < 0.66 ? 'stable' : 'decreasing',\n    });\n  }\n  \n  return risks;\n}\n\nfunction generateEvents(\n  totalTurns: number,\n  config: DifficultyConfig,\n  rng: SeededRNG\n): Event[] {\n  const events: Event[] = [];\n  \n  for (let turn = 2; turn <= totalTurns; turn++) {\n    if (rng.next() < config.eventFrequency) {\n      const eventTypes: Event['type'][] = ['incident', 'scrutiny', 'budget-shock', 'stakeholder-feedback'];\n      const type = rng.sample(eventTypes, 1)[0];\n      \n      events.push({\n        id: `event-${turn}`,\n        type,\n        name: `${type} Event`,\n        description: `${type} occurred in round ${turn}`,\n        round: turn,\n        severity: 0.3 + rng.next() * 0.4, // 0.3-0.7\n        affectedStakeholders: [],\n        effect: {\n          trustChange: (rng.next() - 0.5) * 20, // -10 to +10\n          riskChange: rng.next() * 15, // 0 to +15\n        },\n      });\n    }\n  }\n  \n  return events;\n}\n\nfunction getScenarioName(type: ScenarioType): string {\n  const names = {\n    'data-sharing': 'Data Sharing Governance',\n    'ai-governance': 'AI Governance Challenge',\n    'cyber-controls': 'Cybersecurity Controls',\n    'interoperability': 'Interoperability Governance',\n  };\n  return names[type];\n}\n\nfunction getScenarioDescription(type: ScenarioType, difficulty: Difficulty): string {\n  return `Manage governance for ${type} scenario at ${difficulty} difficulty.`;\n}\n","/**\n * Governance Simulator - Stakeholder Engine\n * \n * Calculates stakeholder responses to governance changes.\n */\n\nimport type { GameState, Stakeholder, GovernanceStrategy, Event } from './types';\n\n/**\n * Calculate stakeholder responses to governance strategy\n */\nexport function calculateStakeholderResponses(\n  state: GameState,\n  strategy: GovernanceStrategy\n): Stakeholder[] {\n  return state.stakeholders.map(stakeholder => {\n    // Calculate alignment with preferences\n    const controlsAlignment = 1 - Math.abs(strategy.controls - stakeholder.preferences.controls) / 100;\n    const transparencyAlignment = 1 - Math.abs(strategy.transparency - stakeholder.preferences.transparency) / 100;\n    const autonomyAlignment = 1 - Math.abs(strategy.autonomy - stakeholder.preferences.autonomy) / 100;\n    \n    const overallAlignment = (controlsAlignment + transparencyAlignment + autonomyAlignment) / 3;\n    \n    // Update trust based on alignment\n    const trustChange = (overallAlignment - 0.5) * 10; // -5 to +5 per turn\n    const newTrust = Math.max(0, Math.min(100, stakeholder.trust + trustChange));\n    \n    // Update satisfaction based on trust\n    const satisfactionChange = (newTrust - stakeholder.trust) * 0.5;\n    const newSatisfaction = Math.max(0, Math.min(100, stakeholder.satisfaction + satisfactionChange));\n    \n    // Update compliance based on controls\n    const complianceChange = (strategy.controls - 50) * 0.2; // Higher controls = higher compliance\n    const newCompliance = Math.max(0, Math.min(100, stakeholder.compliance + complianceChange));\n    \n    return {\n      ...stakeholder,\n      trust: newTrust,\n      satisfaction: newSatisfaction,\n      compliance: newCompliance,\n    };\n  });\n}\n\n/**\n * Apply events to stakeholders\n */\nexport function applyEventsToStakeholders(\n  stakeholders: Stakeholder[],\n  events: Event[]\n): Stakeholder[] {\n  let updated = [...stakeholders];\n  \n  for (const event of events) {\n    for (const stakeholderId of event.affectedStakeholders) {\n      const stakeholder = updated.find(s => s.id === stakeholderId);\n      if (stakeholder && event.effect.trustChange) {\n        stakeholder.trust = Math.max(0, Math.min(100, stakeholder.trust + event.effect.trustChange));\n      }\n    }\n  }\n  \n  return updated;\n}\n","/**\n * Governance Simulator - Risk Engine\n * \n * Calculates risk levels based on governance strategy.\n */\n\nimport type { GameState, Risk, GovernanceStrategy } from './types';\n\n/**\n * Calculate risk levels based on governance strategy\n */\nexport function calculateRiskLevels(\n  state: GameState,\n  strategy: GovernanceStrategy\n): Risk[] {\n  return state.risks.map(risk => {\n    let newLevel = risk.level;\n    \n    // Risk changes based on governance strategy\n    switch (risk.type) {\n      case 'privacy':\n      case 'security':\n      case 'compliance':\n        // Higher controls = lower risk\n        newLevel -= (strategy.controls - 50) * 0.3;\n        break;\n      case 'innovation':\n        // Higher controls = higher innovation risk (slower innovation)\n        newLevel += (strategy.controls - 50) * 0.2;\n        break;\n      case 'cost':\n        // Higher controls = higher cost risk\n        newLevel += (strategy.controls - 50) * 0.1;\n        break;\n    }\n    \n    // Update trend\n    const trend = newLevel > risk.level ? 'increasing' : \n                  newLevel < risk.level ? 'decreasing' : 'stable';\n    \n    return {\n      ...risk,\n      level: Math.max(0, Math.min(100, newLevel)),\n      trend,\n    };\n  });\n}\n\n/**\n * Apply events to risks\n */\nexport function applyEventsToRisks(\n  risks: Risk[],\n  events: import('./types').Event[]\n): Risk[] {\n  let updated = [...risks];\n  \n  for (const event of events) {\n    if (event.effect.riskChange) {\n      // Apply risk change to all risks (simplified)\n      updated = updated.map(risk => ({\n        ...risk,\n        level: Math.max(0, Math.min(100, risk.level + event.effect.riskChange! * 0.5)),\n      }));\n    }\n  }\n  \n  return updated;\n}\n","/**\n * Governance Simulator - Game State Management\n */\n\nimport type { GameState, Scenario, GovernanceStrategy } from './types';\nimport { calculateStakeholderResponses, applyEventsToStakeholders } from './stakeholderEngine';\nimport { calculateRiskLevels, applyEventsToRisks } from './riskEngine';\n\n/**\n * Initialize game state\n */\nexport function initializeGameState(scenario: Scenario, seed: number): GameState {\n  const initialStrategy: GovernanceStrategy = {\n    controls: 60,\n    transparency: 70,\n    autonomy: 50,\n    enforcement: 60,\n  };\n  \n  return {\n    scenario,\n    currentTurn: 0,\n    totalTurns: scenario.totalTurns,\n    governanceStrategy: initialStrategy,\n    stakeholders: scenario.stakeholders.map(s => ({ ...s })),\n    risks: scenario.initialRisks.map(r => ({ ...r })),\n    objectives: scenario.objectives.map(o => ({ ...o })),\n    events: [...scenario.events],\n    decisionHistory: [],\n    metrics: {\n      averageTrust: calculateAverageTrust(scenario.stakeholders),\n      averageSatisfaction: calculateAverageSatisfaction(scenario.stakeholders),\n      averageCompliance: calculateAverageCompliance(scenario.stakeholders),\n      averageRisk: calculateAverageRisk(scenario.initialRisks),\n      stability: 100,\n      outcomes: 0,\n    },\n    seed,\n    status: 'idle',\n  };\n}\n\n/**\n * Start the game\n */\nexport function startGame(state: GameState): GameState {\n  return {\n    ...state,\n    status: 'playing',\n    currentTurn: 1,\n  };\n}\n\n/**\n * Execute turn\n */\nexport function executeTurn(\n  state: GameState,\n  strategyChange?: Partial<GovernanceStrategy>\n): GameState {\n  if (state.status !== 'playing') return state;\n  \n  let newState = { ...state };\n  \n  // Update governance strategy if changed\n  if (strategyChange) {\n    newState.governanceStrategy = {\n      ...newState.governanceStrategy,\n      ...strategyChange,\n    };\n    newState.decisionHistory.push({\n      turn: newState.currentTurn,\n      strategyChange,\n      reasoning: 'Strategy adjustment',\n    });\n  }\n  \n  // Calculate stakeholder responses\n  newState.stakeholders = calculateStakeholderResponses(newState, newState.governanceStrategy);\n  \n  // Calculate risk levels\n  newState.risks = calculateRiskLevels(newState, newState.governanceStrategy);\n  \n  // Apply events for this turn\n  const turnEvents = newState.events.filter(e => e.round === newState.currentTurn);\n  if (turnEvents.length > 0) {\n    newState.stakeholders = applyEventsToStakeholders(newState.stakeholders, turnEvents);\n    newState.risks = applyEventsToRisks(newState.risks, turnEvents);\n  }\n  \n  // Update objectives\n  newState.objectives = updateObjectives(newState);\n  \n  // Calculate metrics\n  newState.metrics = calculateMetrics(newState);\n  \n  // Advance turn\n  newState.currentTurn += 1;\n  \n  // Check win/loss\n  if (newState.currentTurn > newState.totalTurns) {\n    newState.status = 'finished';\n    newState.outcome = checkWinCondition(newState) ? 'win' : 'loss';\n  } else if (checkLossCondition(newState)) {\n    newState.status = 'finished';\n    newState.outcome = 'loss';\n  }\n  \n  return newState;\n}\n\nfunction updateObjectives(state: GameState): GameState['objectives'] {\n  return state.objectives.map(obj => {\n    let current = obj.current;\n    \n    switch (obj.type) {\n      case 'trust':\n        current = state.metrics.averageTrust;\n        break;\n      case 'compliance':\n        current = state.metrics.averageCompliance;\n        break;\n      case 'innovation':\n        // Innovation inversely related to controls\n        current = 100 - state.governanceStrategy.controls;\n        break;\n      case 'cost':\n        // Cost related to controls and enforcement\n        current = (state.governanceStrategy.controls + state.governanceStrategy.enforcement) / 2;\n        break;\n    }\n    \n    return {\n      ...obj,\n      current,\n      met: current >= obj.target,\n    };\n  });\n}\n\nfunction calculateMetrics(state: GameState): GameState['metrics'] {\n  return {\n    averageTrust: calculateAverageTrust(state.stakeholders),\n    averageSatisfaction: calculateAverageSatisfaction(state.stakeholders),\n    averageCompliance: calculateAverageCompliance(state.stakeholders),\n    averageRisk: calculateAverageRisk(state.risks),\n    stability: calculateStability(state),\n    outcomes: calculateOutcomes(state),\n  };\n}\n\nfunction calculateAverageTrust(stakeholders: GameState['stakeholders']): number {\n  return stakeholders.reduce((sum, s) => sum + s.trust, 0) / stakeholders.length;\n}\n\nfunction calculateAverageSatisfaction(stakeholders: GameState['stakeholders']): number {\n  return stakeholders.reduce((sum, s) => sum + s.satisfaction, 0) / stakeholders.length;\n}\n\nfunction calculateAverageCompliance(stakeholders: GameState['stakeholders']): number {\n  return stakeholders.reduce((sum, s) => sum + s.compliance, 0) / stakeholders.length;\n}\n\nfunction calculateAverageRisk(risks: GameState['risks']): number {\n  return risks.reduce((sum, r) => sum + r.level, 0) / risks.length;\n}\n\nfunction calculateStability(state: GameState): number {\n  // Simplified stability calculation\n  // In full implementation, would track metric volatility over time\n  return 80; // Placeholder\n}\n\nfunction calculateOutcomes(state: GameState): number {\n  const metObjectives = state.objectives.filter(o => o.met).length;\n  return (metObjectives / state.objectives.length) * 100;\n}\n\n/**\n * Check win condition\n */\nexport function checkWinCondition(state: GameState): boolean {\n  const trustMet = state.metrics.averageTrust >= 70;\n  const objectivesMet = state.objectives.every(o => o.met);\n  const noCriticalIncidents = state.metrics.averageRisk < 80;\n  \n  return trustMet && objectivesMet && noCriticalIncidents;\n}\n\n/**\n * Check loss condition\n */\nexport function checkLossCondition(state: GameState): boolean {\n  const trustCritical = state.metrics.averageTrust < 30;\n  const riskCritical = state.metrics.averageRisk >= 90;\n  const outcomesFailed = state.metrics.outcomes < 50;\n  \n  return trustCritical || riskCritical || outcomesFailed;\n}\n","/**\n * Governance Simulator - Persistence\n */\n\nimport type { GameState } from './types';\n\nexport interface GovernanceSimulatorProgress {\n  version: 1;\n  xp: number;\n  currentTier: 'assistant' | 'manager' | 'director' | 'executive' | 'master';\n  tierProgress: number;\n  unlockedScenarios: string[];\n  unlockedStrategies: string[];\n  unlockedTools: string[];\n  personalBests: Record<string, {\n    bestScore: number;\n    bestTrust: number;\n    bestStability: number;\n    bestOutcomes: number;\n  }>;\n  currentStreak: number;\n  longestStreak: number;\n  lastPlayedDate: string;\n  completedChallenges: Array<{\n    challengeCode: string;\n    completedDate: string;\n    score: number;\n    trust: number;\n    stability: number;\n    outcomes: number;\n    strategyHash: string;\n  }>;\n  stats: {\n    scenariosCompleted: number;\n    averageTrust: number;\n    averageStability: number;\n    averageOutcomes: number;\n    incidentsPrevented: number;\n    stakeholderSatisfaction: number;\n    scenarioTypeStats: Record<string, {\n      completed: number;\n      averageScore: number;\n      averageTrust: number;\n    }>;\n  };\n}\n\nconst STORAGE_KEY = 'governance-simulator-progress';\n\nexport function getProgress(): GovernanceSimulatorProgress {\n  if (typeof window === 'undefined') {\n    return getDefaultProgress();\n  }\n  \n  try {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (stored) {\n      return JSON.parse(stored);\n    }\n  } catch (error) {\n    console.error('Error loading progress:', error);\n  }\n  \n  return getDefaultProgress();\n}\n\nexport function saveProgress(progress: GovernanceSimulatorProgress): void {\n  if (typeof window === 'undefined') return;\n  \n  try {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));\n  } catch (error) {\n    console.error('Error saving progress:', error);\n  }\n}\n\nfunction getDefaultProgress(): GovernanceSimulatorProgress {\n  return {\n    version: 1,\n    xp: 0,\n    currentTier: 'assistant',\n    tierProgress: 0,\n    unlockedScenarios: ['data-sharing'],\n    unlockedStrategies: ['balanced'],\n    unlockedTools: [],\n    personalBests: {},\n    currentStreak: 0,\n    longestStreak: 0,\n    lastPlayedDate: '',\n    completedChallenges: [],\n    stats: {\n      scenariosCompleted: 0,\n      averageTrust: 0,\n      averageStability: 0,\n      averageOutcomes: 0,\n      incidentsPrevented: 0,\n      stakeholderSatisfaction: 0,\n      scenarioTypeStats: {},\n    },\n  };\n}\n\nexport function updateProgressAfterGame(\n  progress: GovernanceSimulatorProgress,\n  state: GameState,\n  score: number\n): GovernanceSimulatorProgress {\n  const updated = { ...progress };\n  \n  updated.stats.scenariosCompleted += 1;\n  updated.stats.averageTrust = \n    (updated.stats.averageTrust * (updated.stats.scenariosCompleted - 1) + state.metrics.averageTrust) / \n    updated.stats.scenariosCompleted;\n  updated.stats.averageStability = \n    (updated.stats.averageStability * (updated.stats.scenariosCompleted - 1) + state.metrics.stability) / \n    updated.stats.scenariosCompleted;\n  updated.stats.averageOutcomes = \n    (updated.stats.averageOutcomes * (updated.stats.scenariosCompleted - 1) + state.metrics.outcomes) / \n    updated.stats.scenariosCompleted;\n  \n  // Update personal bests\n  const scenarioId = `scenario-${state.seed}`;\n  const currentBest = updated.personalBests[scenarioId];\n  if (!currentBest || score > currentBest.bestScore) {\n    updated.personalBests[scenarioId] = {\n      bestScore: score,\n      bestTrust: state.metrics.averageTrust,\n      bestStability: state.metrics.stability,\n      bestOutcomes: state.metrics.outcomes,\n    };\n  }\n  \n  return updated;\n}\n","/**\n * Governance Simulator - Explainability Analyzer\n */\n\nimport type { GameState } from './types';\n\nexport interface Analysis {\n  keyDecisions: Array<{\n    turn: number;\n    description: string;\n    impact: 'positive' | 'negative' | 'neutral';\n    reasoning: string;\n  }>;\n  mistakes: Array<{\n    turn: number;\n    description: string;\n    cost: string;\n    recommendation: string;\n  }>;\n  recommendations: Array<{\n    type: 'strategy' | 'stakeholder' | 'risk-management';\n    description: string;\n    rationale: string;\n  }>;\n  summary: string;\n}\n\nexport function analyzeRun(state: GameState): Analysis {\n  const keyDecisions: Analysis['keyDecisions'] = [];\n  const mistakes: Analysis['mistakes'] = [];\n  const recommendations: Analysis['recommendations'] = [];\n  \n  // Analyze decision history\n  for (const decision of state.decisionHistory) {\n    const impact = determineDecisionImpact(decision, state);\n    keyDecisions.push({\n      turn: decision.turn,\n      description: `Changed strategy: ${Object.keys(decision.strategyChange).join(', ')}`,\n      impact,\n      reasoning: impact === 'positive' \n        ? 'Strategy change improved metrics'\n        : impact === 'negative'\n        ? 'Strategy change worsened metrics'\n        : 'Strategy change had neutral impact',\n    });\n  }\n  \n  // Analyze stakeholder trust\n  const lowTrustStakeholders = state.stakeholders.filter(s => s.trust < 50);\n  if (lowTrustStakeholders.length > 0) {\n    mistakes.push({\n      turn: state.currentTurn,\n      description: `${lowTrustStakeholders.length} stakeholders have low trust (<50)`,\n      cost: 'Reduced stakeholder satisfaction and compliance',\n      recommendation: 'Adjust governance strategy to better align with stakeholder preferences',\n    });\n  }\n  \n  // Analyze risks\n  const highRisks = state.risks.filter(r => r.level > 70);\n  if (highRisks.length > 0) {\n    mistakes.push({\n      turn: state.currentTurn,\n      description: `${highRisks.length} risks are high (>70)`,\n      cost: 'Increased vulnerability to incidents',\n      recommendation: 'Increase controls or adjust strategy to mitigate risks',\n    });\n  }\n  \n  // Generate recommendations\n  if (state.metrics.averageTrust < 60) {\n    recommendations.push({\n      type: 'stakeholder',\n      description: 'Improve stakeholder trust by aligning governance with preferences',\n      rationale: `Average trust is ${state.metrics.averageTrust.toFixed(1)}, below target of 70`,\n    });\n  }\n  \n  if (state.metrics.averageRisk > 60) {\n    recommendations.push({\n      type: 'risk-management',\n      description: 'Increase controls to reduce risk levels',\n      rationale: `Average risk is ${state.metrics.averageRisk.toFixed(1)}, above acceptable threshold`,\n    });\n  }\n  \n  const win = state.outcome === 'win';\n  const summary = win\n    ? `Successfully maintained governance with ${state.metrics.averageTrust.toFixed(1)}% average trust and ${state.metrics.outcomes.toFixed(1)}% outcome achievement.`\n    : `Failed to maintain governance. Trust dropped to ${state.metrics.averageTrust.toFixed(1)}% or outcomes fell to ${state.metrics.outcomes.toFixed(1)}%.`;\n  \n  return {\n    keyDecisions: keyDecisions.slice(0, 3),\n    mistakes: mistakes.slice(0, 3),\n    recommendations,\n    summary,\n  };\n}\n\nfunction determineDecisionImpact(\n  decision: GameState['decisionHistory'][0],\n  state: GameState\n): 'positive' | 'negative' | 'neutral' {\n  // Simplified impact determination\n  // In full implementation, would compare metrics before/after decision\n  return 'neutral';\n}\n","import GovernanceSimulator from \"@/lib/games/games/governance-simulator\";\n\nexport default function GovernanceSimulatorPage() {\n  return <GovernanceSimulator />;\n}\n"],"names":[],"mappings":"yYASO,OAAM,EACH,KAER,AAFsB,aAEV,CAAY,CAAE,CAExB,IAAI,CAAC,KAAK,CAAG,KAAK,GAAG,CAAC,KAAK,KAAK,CAAC,KAAU,CAC7C,CAKA,MAAe,CAIb,OADA,IAAI,CAAC,KAAK,CAAG,CAAc,QAAb,IAAI,CAAC,KAAK,CAAa,UAAA,CAAU,CAAI,KAAG,OAC/C,IAAI,CAAC,KAAK,CAAG,KAAG,MACzB,CAKA,QAAQ,CAAW,CAAE,CAAW,CAAU,CACxC,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,IAAM,CAAD,CAAO,GAAM,CAAC,EAAK,CACrD,CAKA,UAAU,CAAW,CAAE,CAAW,CAAU,CAC1C,OAAO,EAAM,IAAI,CAAC,IAAI,IAAM,CAAD,CAAO,CAAA,CAAG,AACvC,CAKA,QAAW,CAAU,CAAO,CAC1B,IAAM,EAAW,IAAI,EAAM,CAC3B,IAAK,IAAI,EAAI,EAAS,MAAM,CAAG,EAAG,EAAI,EAAG,IAAK,CAC5C,IAAM,EAAI,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,IAAM,CAAD,EAAK,CAAC,CACzC,EAAC,CAAQ,CAAC,EAAE,CAAE,CAAQ,CAAC,EAAE,CAAC,CAAG,CAAC,CAAQ,CAAC,EAAE,CAAE,CAAQ,CAAC,EAAE,CAAC,AACzD,CACA,OAAO,CACT,CAQA,eAAkB,CAAU,CAAE,CAAiB,CAAK,CAClD,GAAI,EAAM,MAAM,GAAK,EAAQ,MAAM,CACjC,CADmC,KAC7B,AAAI,MAAM,kDAGlB,IAAM,EAAc,EAAQ,MAAM,CAAC,CAAC,EAAK,IAAM,EAAM,EAAG,GACxD,GAAoB,GAAG,CAAnB,EACF,MAAM,AAAI,MAAM,uCAGlB,IAAI,EAAS,IAAI,CAAC,IAAI,GAAK,EAE3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAAK,AAErC,GAAI,CADJ,GAAU,CAAO,CAAC,EAAE,AAAF,GACJ,EAAG,OAAO,CAAK,CAAC,EAAE,CAIlC,OAAO,CAAK,CAAC,EAAM,MAAM,CAAG,EAAE,AAChC,CAKA,OAAU,CAAU,CAAK,CACvB,GAAqB,GAAG,CAApB,EAAM,MAAM,CACd,MAAM,AAAI,MAAM,kCAElB,OAAO,CAAK,CAAC,IAAI,CAAC,OAAO,CAAC,EAAG,EAAM,MAAM,CAAG,GAAG,AACjD,CAKA,OAAU,CAAU,CAAE,CAAS,CAAO,CACpC,GAAI,EAAI,EAAM,MAAM,CAClB,CADoB,KACd,AAAI,MAAM,kDAGlB,IAAM,EAAU,IAAI,IACd,EAAc,EAAE,CAEtB,KAAO,EAAQ,IAAI,CAAG,GAAG,CACvB,IAAM,EAAQ,IAAI,CAAC,OAAO,CAAC,EAAG,EAAM,MAAM,CAAG,GACxC,EAAQ,GAAG,CAAC,KACf,EAAQ,CADe,EACZ,CAAC,GACZ,EAAO,IAAI,CAAC,CAAK,CAAC,EAAM,EAE5B,CAEA,OAAO,CACT,CAKA,UAAmB,CACjB,OAAO,IAAI,CAAC,KAAK,AACnB,CAKA,SAAS,CAAa,CAAQ,CAC5B,IAAI,CAAC,KAAK,CAAG,KAAK,GAAG,CAAC,KAAK,KAAK,CAAC,KAAW,CAC9C,CAKA,OAAmB,CAEjB,OADe,AACR,IADY,EAAU,IAAI,CAAC,KAAK,CAEzC,CACF,yDCnIe,CAAA,EADf,AACe,EADf,CAAA,CAAA,QACe,uBAAA,AAAuB,EAClC,WAAa,MAAM,AAAI,MAAM,kUAAoU,EACjW,iGACA,+DAHW,CAAA,EADf,AACe,EADf,CAAA,CAAA,QACe,uBAAA,AAAuB,EAClC,WAAa,MAAM,AAAI,MAAM,8SAAgT,EAC7U,6EACA,wICDJ,EAAA,EAAA,CAAA,CAAA,QOFe,SAAS,IACtB,MAAO,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,OAAmB,CAAA,CAAA,EAC7B,CNAA,EAAA,CAAA,CAAA","ignoreList":[1]}}]
}