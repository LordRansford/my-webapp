{
  "version": 3,
  "sources": [],
  "debugId": "bad9a27d-7b73-c530-8e7f-d65fa805d3c0",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../src/lib/games/framework/SeededRNG.ts","../../../../src/lib/games/games/proof-sprint/ProofSprint.tsx/__nextjs-internal-proxy.mjs","../../../../src/lib/games/games/proof-sprint/index.ts","../../../../src/lib/games/games/proof-sprint/puzzleGenerator.ts","../../../../src/lib/games/games/proof-sprint/moveDefinitions.ts","../../../../src/lib/games/games/proof-sprint/gameState.ts","../../../../src/lib/games/games/proof-sprint/persistence.ts","../../../../src/lib/games/games/proof-sprint/explainabilityAnalyzer.ts","../../../../src/app/games/proof-sprint/page.tsx"],"sourcesContent":["/**\n * Seeded Random Number Generator\n * \n * Uses Linear Congruential Generator (LCG) for deterministic randomness.\n * Same seed always produces same sequence - essential for daily puzzles and replays.\n * \n * Based on technical architecture specification for gold-standard implementation.\n */\n\nexport class SeededRNG {\n  private state: number;\n  \n  constructor(seed: number) {\n    // Ensure seed is positive integer\n    this.state = Math.abs(Math.floor(seed)) || 1;\n  }\n  \n  /**\n   * Generate next random number [0, 1)\n   */\n  next(): number {\n    // LCG: (a * state + c) mod m\n    // Using constants from Numerical Recipes\n    this.state = (this.state * 1664525 + 1013904223) % 2**32;\n    return this.state / 2**32;\n  }\n  \n  /**\n   * Generate random integer in range [min, max] (inclusive)\n   */\n  nextInt(min: number, max: number): number {\n    return Math.floor(this.next() * (max - min + 1)) + min;\n  }\n  \n  /**\n   * Generate random float in range [min, max)\n   */\n  nextFloat(min: number, max: number): number {\n    return min + this.next() * (max - min);\n  }\n  \n  /**\n   * Shuffle array deterministically (Fisher-Yates)\n   */\n  shuffle<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(this.next() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n  \n  /**\n   * Weighted random selection\n   * @param items Array of items to choose from\n   * @param weights Array of weights (must match items length)\n   * @returns Selected item\n   */\n  weightedChoice<T>(items: T[], weights: number[]): T {\n    if (items.length !== weights.length) {\n      throw new Error('Items and weights arrays must have same length');\n    }\n    \n    const totalWeight = weights.reduce((sum, w) => sum + w, 0);\n    if (totalWeight === 0) {\n      throw new Error('Total weight must be greater than 0');\n    }\n    \n    let random = this.next() * totalWeight;\n    \n    for (let i = 0; i < items.length; i++) {\n      random -= weights[i];\n      if (random <= 0) return items[i];\n    }\n    \n    // Fallback (should never reach here, but TypeScript requires it)\n    return items[items.length - 1];\n  }\n  \n  /**\n   * Choose random item from array\n   */\n  choice<T>(array: T[]): T {\n    if (array.length === 0) {\n      throw new Error('Cannot choose from empty array');\n    }\n    return array[this.nextInt(0, array.length - 1)];\n  }\n  \n  /**\n   * Sample n items from array without replacement\n   */\n  sample<T>(array: T[], n: number): T[] {\n    if (n > array.length) {\n      throw new Error('Sample size cannot be larger than array length');\n    }\n    \n    const indices = new Set<number>();\n    const result: T[] = [];\n    \n    while (indices.size < n) {\n      const index = this.nextInt(0, array.length - 1);\n      if (!indices.has(index)) {\n        indices.add(index);\n        result.push(array[index]);\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get current state (for save/restore)\n   */\n  getState(): number {\n    return this.state;\n  }\n  \n  /**\n   * Restore state (for replay)\n   */\n  setState(state: number): void {\n    this.state = Math.abs(Math.floor(state)) || 1;\n  }\n  \n  /**\n   * Create a new RNG instance with same seed (for testing/debugging)\n   */\n  clone(): SeededRNG {\n    const cloned = new SeededRNG(this.state);\n    return cloned;\n  }\n}\n\n/**\n * Generate daily seed from date string (YYYY-MM-DD UTC)\n */\nexport function getDailySeed(): number {\n  const today = new Date();\n  const year = today.getUTCFullYear();\n  const month = String(today.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(today.getUTCDate()).padStart(2, '0');\n  const dateStr = `${year}-${month}-${day}`;\n  \n  // Simple hash function (FNV-1a inspired)\n  let hash = 2166136261; // FNV offset basis\n  for (let i = 0; i < dateStr.length; i++) {\n    hash ^= dateStr.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  \n  return Math.abs(hash >>> 0); // Convert to unsigned 32-bit integer\n}\n\n/**\n * Generate variant seed for different difficulty tiers\n * Same base seed with different variants produces different but deterministic sequences\n */\nexport function getDailySeedVariant(baseSeed: number, variant: string): number {\n  let hash = 2166136261;\n  for (let i = 0; i < variant.length; i++) {\n    hash ^= variant.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  return (baseSeed ^ hash) >>> 0; // XOR for variant\n}\n\n/**\n * Hash string to number (simple implementation)\n */\nexport function hashString(str: string): number {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash);\n}\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/lib/games/games/proof-sprint/ProofSprint.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/games/games/proof-sprint/ProofSprint.tsx\",\n    \"default\",\n);\n","/**\n * Proof Sprint - Exports\n */\n\nexport { default } from './ProofSprint';\nexport * from './types';\nexport * from './puzzleGenerator';\nexport * from './moveDefinitions';\nexport * from './gameState';\nexport * from './persistence';\nexport * from './explainabilityAnalyzer';\n","/**\n * Proof Sprint - Puzzle Generator\n * \n * Generates deterministic mathematical proof puzzles.\n */\n\nimport { SeededRNG } from '@/lib/games/framework/SeededRNG';\nimport type { Puzzle, Statement, Move, TopicTrack, Difficulty } from './types';\nimport { getMoveDefinitions } from './moveDefinitions';\n\nexport function generatePuzzle(params: {\n  seed: number;\n  topicTrack: TopicTrack;\n  difficulty: Difficulty;\n}): Puzzle {\n  const rng = new SeededRNG(params.seed);\n  const config = getDifficultyConfig(params.difficulty);\n  \n  // Generate puzzle based on topic track\n  const { givenStatements, targetStatement } = generatePuzzleContent(\n    params.topicTrack,\n    params.difficulty,\n    rng\n  );\n  \n  // Get available moves for this difficulty\n  const allMoves = getMoveDefinitions();\n  const availableMoves = allMoves.filter(move => \n    config.availableMoveTypes.includes(move.type)\n  );\n  \n  return {\n    id: `proof-${params.seed}`,\n    seed: params.seed,\n    name: `${params.topicTrack} Proof Puzzle ${params.seed}`,\n    description: `Prove the target statement in ${config.maxSteps} steps or less.`,\n    topicTrack: params.topicTrack,\n    difficulty: params.difficulty,\n    givenStatements,\n    targetStatement,\n    availableMoves,\n    maxSteps: config.maxSteps,\n    hintTokens: config.hintTokens,\n    tier: getTierForDifficulty(params.difficulty),\n  };\n}\n\ninterface DifficultyConfig {\n  maxSteps: number;\n  hintTokens: number;\n  availableMoveTypes: Move['type'][];\n}\n\nfunction getDifficultyConfig(difficulty: Difficulty): DifficultyConfig {\n  switch (difficulty) {\n    case 'beginner':\n      return {\n        maxSteps: 15,\n        hintTokens: 3,\n        availableMoveTypes: ['distribute', 'simplify', 'combine'],\n      };\n    case 'student':\n      return {\n        maxSteps: 12,\n        hintTokens: 2,\n        availableMoveTypes: ['distribute', 'simplify', 'combine', 'factor'],\n      };\n    case 'scholar':\n      return {\n        maxSteps: 10,\n        hintTokens: 2,\n        availableMoveTypes: ['distribute', 'simplify', 'combine', 'factor', 'substitute'],\n      };\n    case 'theorist':\n      return {\n        maxSteps: 8,\n        hintTokens: 1,\n        availableMoveTypes: ['distribute', 'simplify', 'combine', 'factor', 'substitute', 'expand'],\n      };\n    case 'master':\n      return {\n        maxSteps: 6,\n        hintTokens: 0,\n        availableMoveTypes: ['distribute', 'simplify', 'combine', 'factor', 'substitute', 'expand', 'theorem'],\n      };\n  }\n}\n\nfunction generatePuzzleContent(\n  track: TopicTrack,\n  difficulty: Difficulty,\n  rng: SeededRNG\n): { givenStatements: Statement[]; targetStatement: Statement } {\n  // Simplified puzzle generation - in full implementation, this would generate\n  // topic-specific puzzles (algebra, number theory, etc.)\n  \n  const givenStatements: Statement[] = [\n    {\n      id: 'given-1',\n      expression: 'a + b = c',\n      type: 'given',\n    },\n    {\n      id: 'given-2',\n      expression: 'd = 2',\n      type: 'given',\n    },\n  ];\n  \n  const targetStatement: Statement = {\n    id: 'target',\n    expression: '(a + b)^2 = a^2 + 2ab + b^2',\n    type: 'target',\n  };\n  \n  return { givenStatements, targetStatement };\n}\n\nfunction getTierForDifficulty(difficulty: Difficulty): number {\n  switch (difficulty) {\n    case 'beginner': return 0;\n    case 'student': return 100;\n    case 'scholar': return 300;\n    case 'theorist': return 600;\n    case 'master': return 1000;\n  }\n}\n","/**\n * Proof Sprint - Move Definitions\n * \n * Defines available proof moves/techniques.\n */\n\nimport type { Move, Statement } from './types';\n\nexport function getMoveDefinitions(): Move[] {\n  return [\n    {\n      id: 'distribute',\n      type: 'distribute',\n      name: 'Distribute',\n      description: 'Distribute multiplication over addition',\n      penalty: 0,\n      applicable: (statements) => statements.some(s => s.expression.includes('(')),\n    },\n    {\n      id: 'factor',\n      type: 'factor',\n      name: 'Factor',\n      description: 'Factor out common terms',\n      penalty: 0.1,\n      applicable: (statements) => true, // Can always try to factor\n    },\n    {\n      id: 'simplify',\n      type: 'simplify',\n      name: 'Simplify',\n      description: 'Simplify expression',\n      penalty: 0,\n      applicable: (statements) => true,\n    },\n    {\n      id: 'combine',\n      type: 'combine',\n      name: 'Combine Like Terms',\n      description: 'Combine similar terms',\n      penalty: 0,\n      applicable: (statements) => true,\n    },\n    {\n      id: 'substitute',\n      type: 'substitute',\n      name: 'Substitute',\n      description: 'Substitute one expression for another',\n      penalty: 0.05,\n      applicable: (statements) => statements.length >= 2,\n    },\n    {\n      id: 'expand',\n      type: 'expand',\n      name: 'Expand',\n      description: 'Expand expression (powerful but penalized)',\n      penalty: 0.1,\n      applicable: (statements) => statements.some(s => s.expression.includes('^')),\n    },\n    {\n      id: 'theorem',\n      type: 'theorem',\n      name: 'Apply Theorem',\n      description: 'Apply mathematical theorem (very powerful but high penalty)',\n      penalty: 0.2,\n      applicable: (statements) => statements.length >= 2,\n    },\n  ];\n}\n","/**\n * Proof Sprint - Game State Management\n */\n\nimport type { GameState, Puzzle, Move, Statement, ProofStep } from './types';\n\n/**\n * Initialize game state from puzzle\n */\nexport function initializeGameState(puzzle: Puzzle, seed: number): GameState {\n  return {\n    puzzle,\n    currentStatements: [...puzzle.givenStatements],\n    proofSteps: [],\n    stepCount: 0,\n    penalty: 0,\n    hintTokens: puzzle.hintTokens,\n    seed,\n    status: 'idle',\n  };\n}\n\n/**\n * Start the game\n */\nexport function startGame(state: GameState): GameState {\n  return {\n    ...state,\n    status: 'playing',\n  };\n}\n\n/**\n * Execute move\n */\nexport function executeMove(\n  state: GameState,\n  move: Move,\n  inputStatementIds: string[]\n): GameState {\n  if (state.status !== 'playing') return state;\n  \n  // Validate move\n  if (!move.applicable(state.currentStatements)) {\n    return state; // Invalid move\n  }\n  \n  // Check step limit\n  if (state.stepCount >= state.puzzle.maxSteps) {\n    return {\n      ...state,\n      status: 'finished',\n      outcome: 'loss',\n    };\n  }\n  \n  // Apply move (simplified - in full implementation, this would actually transform expressions)\n  const outputStatement: Statement = {\n    id: `derived-${state.stepCount + 1}`,\n    expression: `[Result of ${move.name}]`, // Simplified\n    type: 'derived',\n    stepNumber: state.stepCount + 1,\n  };\n  \n  const proofStep: ProofStep = {\n    stepNumber: state.stepCount + 1,\n    move,\n    inputStatements: inputStatementIds,\n    outputStatement,\n    penalty: move.penalty,\n  };\n  \n  const newState: GameState = {\n    ...state,\n    currentStatements: [...state.currentStatements, outputStatement],\n    proofSteps: [...state.proofSteps, proofStep],\n    stepCount: state.stepCount + 1,\n    penalty: state.penalty + move.penalty,\n  };\n  \n  // Check if target reached (simplified check)\n  if (outputStatement.expression === state.puzzle.targetStatement.expression) {\n    newState.status = 'finished';\n    newState.outcome = 'win';\n    newState.elegance = calculateElegance(newState);\n  }\n  \n  return newState;\n}\n\nfunction calculateElegance(state: GameState): number {\n  // Simplified elegance calculation\n  // In full implementation, would analyze proof structure, move variety, etc.\n  const stepEfficiency = 1 - (state.stepCount / state.puzzle.maxSteps);\n  const penaltyPenalty = state.penalty;\n  const moveVariety = new Set(state.proofSteps.map(s => s.move.type)).size / state.proofSteps.length;\n  \n  return Math.max(0, Math.min(10, (stepEfficiency * 5 + moveVariety * 5 - penaltyPenalty * 2)));\n}\n\n/**\n * Check win condition\n */\nexport function checkWinCondition(state: GameState): boolean {\n  return state.currentStatements.some(s => \n    s.expression === state.puzzle.targetStatement.expression\n  );\n}\n\n/**\n * Check loss condition\n */\nexport function checkLossCondition(state: GameState): boolean {\n  return state.stepCount >= state.puzzle.maxSteps && !checkWinCondition(state);\n}\n","/**\n * Proof Sprint - Persistence\n */\n\nimport type { GameState } from './types';\n\nexport interface ProofSprintProgress {\n  version: 1;\n  xp: number;\n  currentTier: 'beginner' | 'student' | 'scholar' | 'theorist' | 'master';\n  tierProgress: number;\n  unlockedMoves: string[];\n  unlockedTracks: string[];\n  unlockedPuzzlePacks: string[];\n  personalBests: Record<string, {\n    bestSteps: number;\n    bestScore: number;\n    bestElegance: number;\n    completionCount: number;\n  }>;\n  currentStreak: number;\n  longestStreak: number;\n  lastPlayedDate: string;\n  completedChallenges: Array<{\n    challengeCode: string;\n    completedDate: string;\n    steps: number;\n    score: number;\n    elegance: number;\n  }>;\n  stats: {\n    puzzlesSolved: number;\n    totalSteps: number;\n    averageElegance: number;\n    hintsUsed: number;\n    restarts: number;\n    topicTrackStats: Record<string, {\n      puzzlesSolved: number;\n      averageSteps: number;\n      averageElegance: number;\n    }>;\n  };\n}\n\nconst STORAGE_KEY = 'proof-sprint-progress';\n\nexport function getProgress(): ProofSprintProgress {\n  if (typeof window === 'undefined') {\n    return getDefaultProgress();\n  }\n  \n  try {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (stored) {\n      return JSON.parse(stored);\n    }\n  } catch (error) {\n    console.error('Error loading progress:', error);\n  }\n  \n  return getDefaultProgress();\n}\n\nexport function saveProgress(progress: ProofSprintProgress): void {\n  if (typeof window === 'undefined') return;\n  \n  try {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));\n  } catch (error) {\n    console.error('Error saving progress:', error);\n  }\n}\n\nfunction getDefaultProgress(): ProofSprintProgress {\n  return {\n    version: 1,\n    xp: 0,\n    currentTier: 'beginner',\n    tierProgress: 0,\n    unlockedMoves: ['distribute', 'simplify', 'combine'],\n    unlockedTracks: ['algebra', 'logic'],\n    unlockedPuzzlePacks: [],\n    personalBests: {},\n    currentStreak: 0,\n    longestStreak: 0,\n    lastPlayedDate: '',\n    completedChallenges: [],\n    stats: {\n      puzzlesSolved: 0,\n      totalSteps: 0,\n      averageElegance: 0,\n      hintsUsed: 0,\n      restarts: 0,\n      topicTrackStats: {},\n    },\n  };\n}\n\nexport function updateProgressAfterGame(\n  progress: ProofSprintProgress,\n  state: GameState,\n  score: number,\n  elegance: number\n): ProofSprintProgress {\n  const updated = { ...progress };\n  \n  updated.stats.puzzlesSolved += 1;\n  updated.stats.totalSteps += state.stepCount;\n  updated.stats.averageElegance = \n    (updated.stats.averageElegance * (updated.stats.puzzlesSolved - 1) + elegance) / updated.stats.puzzlesSolved;\n  \n  // Update personal bests\n  const puzzleId = `puzzle-${state.seed}`;\n  const currentBest = updated.personalBests[puzzleId];\n  if (!currentBest || score > currentBest.bestScore) {\n    updated.personalBests[puzzleId] = {\n      bestSteps: state.stepCount,\n      bestScore: score,\n      bestElegance: elegance,\n      completionCount: (currentBest?.completionCount || 0) + 1,\n    };\n  }\n  \n  return updated;\n}\n","/**\n * Proof Sprint - Explainability Analyzer\n */\n\nimport type { GameState } from './types';\n\nexport interface Analysis {\n  keyDecisions: Array<{\n    step: number;\n    description: string;\n    impact: 'positive' | 'negative' | 'neutral';\n    reasoning: string;\n  }>;\n  mistakes: Array<{\n    step: number;\n    description: string;\n    cost: string;\n    recommendation: string;\n  }>;\n  recommendations: Array<{\n    type: 'strategy' | 'move-selection' | 'efficiency';\n    description: string;\n    rationale: string;\n  }>;\n  summary: string;\n}\n\nexport function analyzeRun(state: GameState): Analysis {\n  const keyDecisions: Analysis['keyDecisions'] = [];\n  const mistakes: Analysis['mistakes'] = [];\n  const recommendations: Analysis['recommendations'] = [];\n  \n  // Analyze proof steps\n  for (const step of state.proofSteps) {\n    if (step.penalty > 0.1) {\n      keyDecisions.push({\n        step: step.stepNumber,\n        description: `Used ${step.move.name} (penalty: ${step.penalty})`,\n        impact: step.penalty > 0.15 ? 'negative' : 'neutral',\n        reasoning: 'Powerful move used, but incurred penalty',\n      });\n    }\n  }\n  \n  // Check for inefficiencies\n  if (state.stepCount > state.puzzle.maxSteps * 0.8) {\n    mistakes.push({\n      step: state.stepCount,\n      description: 'Used too many steps',\n      cost: 'Reduced efficiency score',\n      recommendation: 'Consider using more powerful moves to reduce step count',\n    });\n  }\n  \n  if (state.penalty > 0.3) {\n    mistakes.push({\n      step: state.stepCount,\n      description: 'Accumulated high penalty',\n      cost: 'Reduced final score',\n      recommendation: 'Balance powerful moves with simple steps',\n    });\n  }\n  \n  // Generate recommendations\n  if (state.stepCount > state.puzzle.maxSteps * 0.7) {\n    recommendations.push({\n      type: 'efficiency',\n      description: 'Focus on reducing step count',\n      rationale: `Used ${state.stepCount} of ${state.puzzle.maxSteps} steps`,\n    });\n  }\n  \n  if (state.penalty > 0.2) {\n    recommendations.push({\n      type: 'move-selection',\n      description: 'Use powerful moves more strategically',\n      rationale: 'High penalty accumulated from powerful moves',\n    });\n  }\n  \n  const win = state.outcome === 'win';\n  const summary = win\n    ? `Successfully completed proof in ${state.stepCount} steps with elegance score ${state.elegance?.toFixed(1) || 0}.`\n    : `Failed to complete proof within ${state.puzzle.maxSteps} steps.`;\n  \n  return {\n    keyDecisions: keyDecisions.slice(0, 3),\n    mistakes: mistakes.slice(0, 3),\n    recommendations,\n    summary,\n  };\n}\n","import ProofSprint from \"@/lib/games/games/proof-sprint\";\n\nexport default function ProofSprintPage() {\n  return <ProofSprint />;\n}\n"],"names":[],"mappings":"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","ignoreList":[1]}}]
}