{
  "version": 3,
  "sources": [],
  "debugId": "dc463e6b-00c0-8143-c8c9-58f19c355535",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../src/lib/studios/security/auditLogger.ts","../../../../src/components/dev-studios/SecurityBanner.tsx","../../../../src/lib/studios/security/inputSanitizer.ts","../../../../src/utils/validateUpload.ts","../../../../node_modules/lucide-react/src/icons/chevron-right.ts","../../../../src/components/studios/StudioBreadcrumbs.tsx","../../../../src/stores/useStudiosStore.js"],"sourcesContent":["/**\n * Audit Logger for Studios\n * \n * Logs important actions for governance, compliance, and security monitoring.\n * All logs are stored client-side only (localStorage) for privacy.\n */\n\n\"use client\";\n\ninterface AuditLogEntry {\n  timestamp: number;\n  action: string;\n  studio: string;\n  tool?: string;\n  userId?: string;\n  metadata?: Record<string, unknown>;\n}\n\nclass AuditLogger {\n  private storageKey = \"studio-audit-logs\";\n  private maxLogs = 1000; // Keep last 1000 entries\n\n  /**\n   * Log an action\n   */\n  log(action: string, studio: string, metadata?: Record<string, unknown>): void {\n    if (typeof window === \"undefined\") {\n      return; // Server-side rendering\n    }\n\n    try {\n      const entry: AuditLogEntry = {\n        timestamp: Date.now(),\n        action,\n        studio,\n        metadata: metadata || {}\n      };\n\n      const logs = this.getLogs();\n      logs.push(entry);\n\n      // Keep only the most recent logs\n      if (logs.length > this.maxLogs) {\n        logs.splice(0, logs.length - this.maxLogs);\n      }\n\n      localStorage.setItem(this.storageKey, JSON.stringify(logs));\n    } catch (error) {\n      // Silently fail if localStorage is not available\n      console.warn(\"Failed to log audit entry:\", error);\n    }\n  }\n\n  /**\n   * Get all logs\n   */\n  getLogs(): AuditLogEntry[] {\n    if (typeof window === \"undefined\") {\n      return [];\n    }\n\n    try {\n      const stored = localStorage.getItem(this.storageKey);\n      if (!stored) {\n        return [];\n      }\n      return JSON.parse(stored) as AuditLogEntry[];\n    } catch (error) {\n      console.warn(\"Failed to read audit logs:\", error);\n      return [];\n    }\n  }\n\n  /**\n   * Get logs for a specific studio\n   */\n  getLogsForStudio(studio: string): AuditLogEntry[] {\n    return this.getLogs().filter(log => log.studio === studio);\n  }\n\n  /**\n   * Clear all logs\n   */\n  clearLogs(): void {\n    if (typeof window !== \"undefined\") {\n      localStorage.removeItem(this.storageKey);\n    }\n  }\n\n  /**\n   * Export logs as JSON\n   */\n  exportLogs(): string {\n    return JSON.stringify(this.getLogs(), null, 2);\n  }\n}\n\nexport const auditLogger = new AuditLogger();\n\n// Common audit actions\nexport const AuditActions = {\n  TOOL_OPENED: \"tool_opened\",\n  FILE_UPLOADED: \"file_uploaded\",\n  PROJECT_CREATED: \"project_created\",\n  PROJECT_DELETED: \"project_deleted\",\n  DEPLOYMENT_INITIATED: \"deployment_initiated\",\n  CREDITS_CONSUMED: \"credits_consumed\",\n  SETTINGS_CHANGED: \"settings_changed\",\n  ERROR_OCCURRED: \"error_occurred\",\n  ERROR_BOUNDARY_TRIGGERED: \"error_boundary_triggered\",\n  ERROR_BOUNDARY_RESET: \"error_boundary_reset\",\n  PERFORMANCE_ISSUE: \"performance_issue\",\n  RETRY_ATTEMPTED: \"retry_attempted\"\n} as const;\n\n","\"use client\";\n\nimport React from \"react\";\n\nexport function SecurityBanner() {\n  return (\n    <div className=\"rounded-2xl border border-amber-200 bg-amber-50/70 px-4 py-3 text-sm text-amber-900 flex flex-col gap-1\">\n      <span className=\"font-semibold\">Security reminder</span>\n      <span className=\"text-xs text-amber-800\">\n        This studio is for education and experimentation. Do not upload production data or secrets. Outputs are demos; review before using anywhere safety-critical or financial.\n      </span>\n    </div>\n  );\n}\n","/**\n * Input Sanitization for Studios\n * \n * Provides utilities to sanitize and validate user inputs across all studios\n * to prevent XSS, injection attacks, and data corruption.\n */\n\n/**\n * Sanitize text input to prevent XSS attacks\n * Removes HTML tags and limits length\n */\nexport function sanitizeText(input: unknown, maxLength: number = 1000): string {\n  if (typeof input !== \"string\") {\n    return \"\";\n  }\n\n  // Remove HTML tags\n  let sanitized = input.replace(/<[^>]*>/g, \"\");\n\n  // Remove potentially dangerous characters\n  sanitized = sanitized.replace(/[<>\\\"']/g, \"\");\n\n  // Trim whitespace\n  sanitized = sanitized.trim();\n\n  // Limit length\n  if (sanitized.length > maxLength) {\n    sanitized = sanitized.slice(0, maxLength);\n  }\n\n  return sanitized;\n}\n\n/**\n * Sanitize file name to prevent path traversal and other attacks\n */\nexport function sanitizeFileName(fileName: string): string {\n  if (!fileName || typeof fileName !== \"string\") {\n    return \"file\";\n  }\n\n  // Remove path separators and dangerous characters\n  let sanitized = fileName\n    .replace(/[\\/\\\\]/g, \"_\") // Replace path separators\n    .replace(/[<>:\"|?*]/g, \"_\") // Replace Windows reserved characters\n    .replace(/\\.\\./g, \"_\") // Prevent path traversal\n    .trim();\n\n  // Remove leading dots (hidden files)\n  sanitized = sanitized.replace(/^\\.+/, \"\");\n\n  // Limit length\n  if (sanitized.length > 255) {\n    const ext = sanitized.split(\".\").pop();\n    const name = sanitized.slice(0, 255 - (ext ? ext.length + 1 : 0));\n    sanitized = ext ? `${name}.${ext}` : name;\n  }\n\n  // Ensure it's not empty\n  if (!sanitized) {\n    sanitized = \"file\";\n  }\n\n  return sanitized;\n}\n\n/**\n * Validate and sanitize JSON input\n */\nexport function sanitizeJson(input: unknown): { valid: boolean; data: any; error?: string } {\n  if (typeof input !== \"string\") {\n    return { valid: false, data: null, error: \"Input must be a string\" };\n  }\n\n  try {\n    const parsed = JSON.parse(input);\n    \n    // Check for circular references and limit depth\n    const sanitized = sanitizeObject(parsed, 0, 10);\n    \n    return { valid: true, data: sanitized };\n  } catch (error) {\n    return { valid: false, data: null, error: \"Invalid JSON format\" };\n  }\n}\n\n/**\n * Recursively sanitize object to prevent prototype pollution\n */\nfunction sanitizeObject(obj: any, depth: number, maxDepth: number): any {\n  if (depth > maxDepth) {\n    return null;\n  }\n\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n\n  if (typeof obj !== \"object\") {\n    return typeof obj === \"string\" ? sanitizeText(obj, 10000) : obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => sanitizeObject(item, depth + 1, maxDepth));\n  }\n\n  const sanitized: any = {};\n  for (const key in obj) {\n    // Prevent prototype pollution\n    if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n      continue;\n    }\n\n    // Sanitize key\n    const safeKey = sanitizeText(key, 100);\n    if (!safeKey || safeKey.startsWith(\"__proto__\") || safeKey.startsWith(\"constructor\")) {\n      continue;\n    }\n\n    sanitized[safeKey] = sanitizeObject(obj[key], depth + 1, maxDepth);\n  }\n\n  return sanitized;\n}\n\n/**\n * Validate email format\n */\nexport function validateEmail(email: string): boolean {\n  if (typeof email !== \"string\") {\n    return false;\n  }\n\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email) && email.length <= 254;\n}\n\n/**\n * Validate URL format and prevent SSRF\n */\nexport function validateUrl(url: string, allowedProtocols: string[] = [\"https:\", \"http:\"]): { valid: boolean; url?: URL; error?: string } {\n  if (typeof url !== \"string\") {\n    return { valid: false, error: \"URL must be a string\" };\n  }\n\n  try {\n    const parsed = new URL(url);\n\n    // Check protocol\n    if (!allowedProtocols.includes(parsed.protocol)) {\n      return { valid: false, error: `Protocol ${parsed.protocol} is not allowed` };\n    }\n\n    // Prevent localhost and private IPs (basic SSRF protection)\n    const hostname = parsed.hostname.toLowerCase();\n    if (\n      hostname === \"localhost\" ||\n      hostname === \"127.0.0.1\" ||\n      hostname.startsWith(\"192.168.\") ||\n      hostname.startsWith(\"10.\") ||\n      hostname.startsWith(\"172.16.\") ||\n      hostname.startsWith(\"172.17.\") ||\n      hostname.startsWith(\"172.18.\") ||\n      hostname.startsWith(\"172.19.\") ||\n      hostname.startsWith(\"172.20.\") ||\n      hostname.startsWith(\"172.21.\") ||\n      hostname.startsWith(\"172.22.\") ||\n      hostname.startsWith(\"172.23.\") ||\n      hostname.startsWith(\"172.24.\") ||\n      hostname.startsWith(\"172.25.\") ||\n      hostname.startsWith(\"172.26.\") ||\n      hostname.startsWith(\"172.27.\") ||\n      hostname.startsWith(\"172.28.\") ||\n      hostname.startsWith(\"172.29.\") ||\n      hostname.startsWith(\"172.30.\") ||\n      hostname.startsWith(\"172.31.\")\n    ) {\n      return { valid: false, error: \"Local and private IP addresses are not allowed\" };\n    }\n\n    return { valid: true, url: parsed };\n  } catch (error) {\n    return { valid: false, error: \"Invalid URL format\" };\n  }\n}\n\n/**\n * Validate file type by MIME type and extension\n */\nexport function validateFileType(file: File, allowedTypes: string[], allowedExtensions: string[]): { valid: boolean; error?: string } {\n  // Check MIME type\n  if (allowedTypes.length > 0 && !allowedTypes.includes(file.type)) {\n    return { valid: false, error: `File type ${file.type} is not allowed` };\n  }\n\n  // Check extension\n  const extension = \".\" + file.name.split(\".\").pop()?.toLowerCase();\n  if (allowedExtensions.length > 0 && !allowedExtensions.includes(extension)) {\n    return { valid: false, error: `File extension ${extension} is not allowed` };\n  }\n\n  return { valid: true };\n}\n\n\n\n","\"use client\";\n\nimport { sanitizeFileName, validateFileType } from \"@/lib/studios/security/inputSanitizer\";\nimport { auditLogger, AuditActions } from \"@/lib/studios/security/auditLogger\";\n\nexport type UploadRule = {\n  maxBytes: number;\n  allowedExtensions: string[];\n};\n\nexport type UploadResult = {\n  safeFiles: File[];\n  errors: string[];\n};\n\n/**\n * Validate files on the client: size + extension. Blocks unknown types by default.\n * Enhanced with security features: file name sanitization, dangerous file type blocking, and audit logging.\n * Note: this is client-side only; revalidate server-side if/when a backend is added.\n */\nexport function validateUpload(files: FileList | File[] | null | undefined, rule: UploadRule): UploadResult {\n  if (!files) return { safeFiles: [], errors: [] };\n  const arr = Array.from(files);\n  const allowed = rule.allowedExtensions.map((e) => e.toLowerCase().replace(/^\\./, \"\"));\n  const safeFiles: File[] = [];\n  const errors: string[] = [];\n\n  // Dangerous file types that should always be blocked\n  const dangerousExtensions = [\"exe\", \"bat\", \"cmd\", \"com\", \"pif\", \"scr\", \"vbs\", \"js\", \"jar\", \"sh\", \"ps1\"];\n\n  arr.forEach((file) => {\n    // Sanitize file name to prevent path traversal\n    const sanitizedName = sanitizeFileName(file.name);\n    const sanitizedFile = sanitizedName !== file.name \n      ? new File([file], sanitizedName, { type: file.type })\n      : file;\n\n    const ext = (sanitizedFile.name.split(\".\").pop() || \"\").toLowerCase();\n    const sizeOk = sanitizedFile.size <= rule.maxBytes;\n    const extOk = allowed.includes(ext);\n    const isDangerous = dangerousExtensions.includes(ext);\n\n    // Block dangerous file types\n    if (isDangerous) {\n      const errorMsg = `${sanitizedName}: This file type is not allowed for security reasons.`;\n      errors.push(errorMsg);\n      auditLogger.log(AuditActions.ERROR_OCCURRED, \"file-upload\", {\n        error: \"dangerous_file_type\",\n        fileName: sanitizedName,\n        extension: ext\n      });\n      return;\n    }\n\n    // Validate file type\n    if (!extOk) {\n      const errorMsg = `${sanitizedName}: File type not allowed. Allowed types: ${allowed.join(\", \")}.`;\n      errors.push(errorMsg);\n      auditLogger.log(AuditActions.ERROR_OCCURRED, \"file-upload\", {\n        error: \"invalid_file_type\",\n        fileName: sanitizedName,\n        extension: ext\n      });\n      return;\n    }\n\n    // Validate file size\n    if (!sizeOk) {\n      const errorMsg = `${sanitizedName}: File is too large. Maximum size is ${rule.maxBytes / (1024 * 1024)}MB.`;\n      errors.push(errorMsg);\n      auditLogger.log(AuditActions.ERROR_OCCURRED, \"file-upload\", {\n        error: \"file_too_large\",\n        fileName: sanitizedName,\n        fileSize: sanitizedFile.size,\n        maxSize: rule.maxBytes\n      });\n      return;\n    }\n\n    // Additional validation using validateFileType\n    const allowedExts = rule.allowedExtensions.map(e => e.startsWith(\".\") ? e : `.${e}`);\n    const validation = validateFileType(sanitizedFile, [], allowedExts);\n    if (!validation.valid) {\n      const errorMsg = validation.error || `${sanitizedName}: File validation failed.`;\n      errors.push(errorMsg);\n      auditLogger.log(AuditActions.ERROR_OCCURRED, \"file-upload\", {\n        error: \"validation_failed\",\n        fileName: sanitizedName,\n        errorDetails: validation.error\n      });\n      return;\n    }\n\n    // File is safe\n    safeFiles.push(sanitizedFile);\n    auditLogger.log(AuditActions.FILE_UPLOADED, \"file-upload\", {\n      fileName: sanitizedName,\n      fileSize: sanitizedFile.size,\n      fileType: sanitizedFile.type\n    });\n  });\n\n  return { safeFiles, errors };\n}\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ChevronRight\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtOSAxOCA2LTYtNi02IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/chevron-right\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChevronRight = createLucideIcon('ChevronRight', [\n  ['path', { d: 'm9 18 6-6-6-6', key: 'mthhwq' }],\n]);\n\nexport default ChevronRight;\n","\"use client\";\n\nimport React from \"react\";\nimport Link from \"next/link\";\nimport { ChevronRight, Home } from \"lucide-react\";\n\ninterface BreadcrumbItem {\n  label: string;\n  href?: string;\n}\n\ninterface StudioBreadcrumbsProps {\n  items: BreadcrumbItem[];\n  className?: string;\n}\n\nexport function StudioBreadcrumbs({ items, className = \"\" }: StudioBreadcrumbsProps) {\n  return (\n    <nav \n      className={`flex items-center gap-2 text-sm text-slate-600 ${className}`}\n      aria-label=\"Breadcrumb navigation\"\n    >\n      <Link\n        href=\"/\"\n        className=\"flex items-center gap-1 hover:text-slate-900 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500 focus-visible:ring-offset-2 rounded\"\n        aria-label=\"Home\"\n      >\n        <Home className=\"w-4 h-4\" aria-hidden=\"true\" />\n        <span className=\"sr-only\">Home</span>\n      </Link>\n      \n      {items.map((item, index) => {\n        const isLast = index === items.length - 1;\n        \n        return (\n          <React.Fragment key={index}>\n            <ChevronRight className=\"w-4 h-4 text-slate-400\" aria-hidden=\"true\" />\n            {isLast || !item.href ? (\n              <span className=\"text-slate-900 font-medium\" aria-current=\"page\">\n                {item.label}\n              </span>\n            ) : (\n              <Link\n                href={item.href}\n                className=\"hover:text-slate-900 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500 focus-visible:ring-offset-2 rounded\"\n              >\n                {item.label}\n              </Link>\n            )}\n          </React.Fragment>\n        );\n      })}\n    </nav>\n  );\n}\n","\"use client\";\n\nimport { create } from \"zustand\";\n\nconst makeId = () => {\n  if (typeof crypto !== \"undefined\" && crypto.randomUUID) return crypto.randomUUID();\n  return Math.random().toString(36).slice(2);\n};\n\n// Seed a lightweight sample dataset so Model Forge and Control Room have something to show.\nconst sampleDatasetId = \"sample-ds-1\";\nconst sampleRows = Array.from({ length: 30 }).map((_, idx) => ({\n  feature_a: Number((Math.random() * 10 + idx * 0.2).toFixed(2)),\n  feature_b: Number((Math.random() * 5 + 1).toFixed(2)),\n  category: [\"alpha\", \"beta\", \"gamma\"][idx % 3],\n  target: idx % 2 === 0 ? \"yes\" : \"no\",\n}));\n\nconst initialDatasets = [\n  {\n    id: sampleDatasetId,\n    name: \"Sample customer churn\",\n    sizeBytes: 12_000,\n    rowCount: sampleRows.length,\n    columnCount: 4,\n    columns: [\"feature_a\", \"feature_b\", \"category\", \"target\"],\n    createdAt: new Date().toISOString(),\n  },\n];\n\nconst initialParsedData = {\n  [sampleDatasetId]: {\n    columns: [\"feature_a\", \"feature_b\", \"category\", \"target\"],\n    rows: sampleRows,\n  },\n};\n\nexport const useStudiosStore = create((set, get) => ({\n  datasets: initialDatasets,\n  parsedDataById: initialParsedData,\n  jobs: [],\n\n  addDataset: (meta, parsed) =>\n    set((state) => {\n      const exists = state.datasets.find((d) => d.id === meta.id);\n      const nextDatasets = exists\n        ? state.datasets.map((d) => (d.id === meta.id ? meta : d))\n        : [...state.datasets, meta];\n      const nextParsed = parsed\n        ? { ...state.parsedDataById, [meta.id]: parsed }\n        : state.parsedDataById;\n      return { datasets: nextDatasets, parsedDataById: nextParsed };\n    }),\n\n  setParsedData: (datasetId, parsed) =>\n    set((state) => ({\n      parsedDataById: { ...state.parsedDataById, [datasetId]: parsed },\n    })),\n\n  getParsedData: (datasetId) => get().parsedDataById[datasetId],\n\n  addJob: (job) =>\n    set((state) => ({\n      jobs: [\n        ...state.jobs,\n        {\n          ...job,\n          id: job.id || makeId(),\n          startedAt: job.startedAt || new Date().toISOString(),\n        },\n      ],\n    })),\n\n  updateJob: (id, patch) =>\n    set((state) => ({\n      jobs: state.jobs.map((j) => (j.id === id ? { ...j, ...patch } : j)),\n    })),\n}));\n"],"names":[],"mappings":"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"}}]
}