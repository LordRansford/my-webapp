{
  "version": 3,
  "sources": [],
  "debugId": "f5007d45-dbab-4af3-9265-685e998e1c42",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../src/lib/studios/security/auditLogger.ts"],"sourcesContent":["/**\n * Audit Logger for Studios\n * \n * Logs important actions for governance, compliance, and security monitoring.\n * All logs are stored client-side only (localStorage) for privacy.\n */\n\n\"use client\";\n\ninterface AuditLogEntry {\n  timestamp: number;\n  action: string;\n  studio: string;\n  tool?: string;\n  userId?: string;\n  metadata?: Record<string, unknown>;\n}\n\nclass AuditLogger {\n  private storageKey = \"studio-audit-logs\";\n  private maxLogs = 1000; // Keep last 1000 entries\n\n  /**\n   * Log an action\n   */\n  log(action: string, studio: string, metadata?: Record<string, unknown>): void {\n    if (typeof window === \"undefined\") {\n      return; // Server-side rendering\n    }\n\n    try {\n      const entry: AuditLogEntry = {\n        timestamp: Date.now(),\n        action,\n        studio,\n        metadata: metadata || {}\n      };\n\n      const logs = this.getLogs();\n      logs.push(entry);\n\n      // Keep only the most recent logs\n      if (logs.length > this.maxLogs) {\n        logs.splice(0, logs.length - this.maxLogs);\n      }\n\n      localStorage.setItem(this.storageKey, JSON.stringify(logs));\n    } catch (error) {\n      // Silently fail if localStorage is not available\n      console.warn(\"Failed to log audit entry:\", error);\n    }\n  }\n\n  /**\n   * Get all logs\n   */\n  getLogs(): AuditLogEntry[] {\n    if (typeof window === \"undefined\") {\n      return [];\n    }\n\n    try {\n      const stored = localStorage.getItem(this.storageKey);\n      if (!stored) {\n        return [];\n      }\n      return JSON.parse(stored) as AuditLogEntry[];\n    } catch (error) {\n      console.warn(\"Failed to read audit logs:\", error);\n      return [];\n    }\n  }\n\n  /**\n   * Get logs for a specific studio\n   */\n  getLogsForStudio(studio: string): AuditLogEntry[] {\n    return this.getLogs().filter(log => log.studio === studio);\n  }\n\n  /**\n   * Clear all logs\n   */\n  clearLogs(): void {\n    if (typeof window !== \"undefined\") {\n      localStorage.removeItem(this.storageKey);\n    }\n  }\n\n  /**\n   * Export logs as JSON\n   */\n  exportLogs(): string {\n    return JSON.stringify(this.getLogs(), null, 2);\n  }\n}\n\nexport const auditLogger = new AuditLogger();\n\n// Common audit actions\nexport const AuditActions = {\n  TOOL_OPENED: \"tool_opened\",\n  FILE_UPLOADED: \"file_uploaded\",\n  PROJECT_CREATED: \"project_created\",\n  PROJECT_DELETED: \"project_deleted\",\n  DEPLOYMENT_INITIATED: \"deployment_initiated\",\n  CREDITS_CONSUMED: \"credits_consumed\",\n  SETTINGS_CHANGED: \"settings_changed\",\n  ERROR_OCCURRED: \"error_occurred\",\n  ERROR_BOUNDARY_TRIGGERED: \"error_boundary_triggered\",\n  ERROR_BOUNDARY_RESET: \"error_boundary_reset\",\n  PERFORMANCE_ISSUE: \"performance_issue\",\n  RETRY_ATTEMPTED: \"retry_attempted\"\n} as const;\n\n"],"names":[],"mappings":"wCAiGO,IAAM,EAAc,IA/E3B,AA+E+B,MA9ErB,AADJ,WACiB,mBAAoB,CACjC,QAAU,GAAK,CAKvB,IAAI,CAAc,CAAE,CAAc,CAAE,CAAkC,CAAQ,CA0B9E,CAKA,SAA2B,CAEvB,MAAO,EAAE,AAab,CAKA,iBAAiB,CAAc,CAAmB,CAChD,OAAO,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,GAAO,EAAI,MAAM,GAAK,EACrD,CAKA,WAAkB,CAIlB,CAKA,YAAqB,CACnB,OAAO,KAAK,SAAS,CAAC,IAAI,CAAC,OAAO,GAAI,KAAM,EAC9C,CACF,wBAK4B,CAC1B,YAAa,cACb,cAAe,gBACf,gBAAiB,kBACjB,gBAAiB,kBACjB,qBAAsB,uBACtB,iBAAkB,mBAClB,iBAAkB,mBAClB,eAAgB,iBAChB,yBAA0B,2BAC1B,qBAAsB,uBACtB,kBAAmB,oBACnB,gBAAiB,iBACnB"}}]
}