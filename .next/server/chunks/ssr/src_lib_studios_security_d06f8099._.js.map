{
  "version": 3,
  "sources": [],
  "debugId": "dfcad99c-b2ae-4bf3-8563-081ed1f9fcbc",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../src/lib/studios/security/auditLogger.ts","../../../../src/lib/studios/security/inputSanitizer.ts"],"sourcesContent":["/**\n * Audit Logger for Studios\n * \n * Logs important actions for governance, compliance, and security monitoring.\n * All logs are stored client-side only (localStorage) for privacy.\n */\n\n\"use client\";\n\ninterface AuditLogEntry {\n  timestamp: number;\n  action: string;\n  studio: string;\n  tool?: string;\n  userId?: string;\n  metadata?: Record<string, unknown>;\n}\n\nclass AuditLogger {\n  private storageKey = \"studio-audit-logs\";\n  private maxLogs = 1000; // Keep last 1000 entries\n\n  /**\n   * Log an action\n   */\n  log(action: string, studio: string, metadata?: Record<string, unknown>): void {\n    if (typeof window === \"undefined\") {\n      return; // Server-side rendering\n    }\n\n    try {\n      const entry: AuditLogEntry = {\n        timestamp: Date.now(),\n        action,\n        studio,\n        metadata: metadata || {}\n      };\n\n      const logs = this.getLogs();\n      logs.push(entry);\n\n      // Keep only the most recent logs\n      if (logs.length > this.maxLogs) {\n        logs.splice(0, logs.length - this.maxLogs);\n      }\n\n      localStorage.setItem(this.storageKey, JSON.stringify(logs));\n    } catch (error) {\n      // Silently fail if localStorage is not available\n      console.warn(\"Failed to log audit entry:\", error);\n    }\n  }\n\n  /**\n   * Get all logs\n   */\n  getLogs(): AuditLogEntry[] {\n    if (typeof window === \"undefined\") {\n      return [];\n    }\n\n    try {\n      const stored = localStorage.getItem(this.storageKey);\n      if (!stored) {\n        return [];\n      }\n      return JSON.parse(stored) as AuditLogEntry[];\n    } catch (error) {\n      console.warn(\"Failed to read audit logs:\", error);\n      return [];\n    }\n  }\n\n  /**\n   * Get logs for a specific studio\n   */\n  getLogsForStudio(studio: string): AuditLogEntry[] {\n    return this.getLogs().filter(log => log.studio === studio);\n  }\n\n  /**\n   * Clear all logs\n   */\n  clearLogs(): void {\n    if (typeof window !== \"undefined\") {\n      localStorage.removeItem(this.storageKey);\n    }\n  }\n\n  /**\n   * Export logs as JSON\n   */\n  exportLogs(): string {\n    return JSON.stringify(this.getLogs(), null, 2);\n  }\n}\n\nexport const auditLogger = new AuditLogger();\n\n// Common audit actions\nexport const AuditActions = {\n  TOOL_OPENED: \"tool_opened\",\n  FILE_UPLOADED: \"file_uploaded\",\n  PROJECT_CREATED: \"project_created\",\n  PROJECT_DELETED: \"project_deleted\",\n  DEPLOYMENT_INITIATED: \"deployment_initiated\",\n  CREDITS_CONSUMED: \"credits_consumed\",\n  SETTINGS_CHANGED: \"settings_changed\",\n  ERROR_OCCURRED: \"error_occurred\",\n  ERROR_BOUNDARY_TRIGGERED: \"error_boundary_triggered\",\n  ERROR_BOUNDARY_RESET: \"error_boundary_reset\",\n  PERFORMANCE_ISSUE: \"performance_issue\",\n  RETRY_ATTEMPTED: \"retry_attempted\"\n} as const;\n\n","/**\n * Input Sanitization for Studios\n * \n * Provides utilities to sanitize and validate user inputs across all studios\n * to prevent XSS, injection attacks, and data corruption.\n */\n\n/**\n * Sanitize text input to prevent XSS attacks\n * Removes HTML tags and limits length\n */\nexport function sanitizeText(input: unknown, maxLength: number = 1000): string {\n  if (typeof input !== \"string\") {\n    return \"\";\n  }\n\n  // Remove HTML tags\n  let sanitized = input.replace(/<[^>]*>/g, \"\");\n\n  // Remove potentially dangerous characters\n  sanitized = sanitized.replace(/[<>\\\"']/g, \"\");\n\n  // Trim whitespace\n  sanitized = sanitized.trim();\n\n  // Limit length\n  if (sanitized.length > maxLength) {\n    sanitized = sanitized.slice(0, maxLength);\n  }\n\n  return sanitized;\n}\n\n/**\n * Sanitize file name to prevent path traversal and other attacks\n */\nexport function sanitizeFileName(fileName: string): string {\n  if (!fileName || typeof fileName !== \"string\") {\n    return \"file\";\n  }\n\n  // Remove path separators and dangerous characters\n  let sanitized = fileName\n    .replace(/[\\/\\\\]/g, \"_\") // Replace path separators\n    .replace(/[<>:\"|?*]/g, \"_\") // Replace Windows reserved characters\n    .replace(/\\.\\./g, \"_\") // Prevent path traversal\n    .trim();\n\n  // Remove leading dots (hidden files)\n  sanitized = sanitized.replace(/^\\.+/, \"\");\n\n  // Limit length\n  if (sanitized.length > 255) {\n    const ext = sanitized.split(\".\").pop();\n    const name = sanitized.slice(0, 255 - (ext ? ext.length + 1 : 0));\n    sanitized = ext ? `${name}.${ext}` : name;\n  }\n\n  // Ensure it's not empty\n  if (!sanitized) {\n    sanitized = \"file\";\n  }\n\n  return sanitized;\n}\n\n/**\n * Validate and sanitize JSON input\n */\nexport function sanitizeJson(input: unknown): { valid: boolean; data: any; error?: string } {\n  if (typeof input !== \"string\") {\n    return { valid: false, data: null, error: \"Input must be a string\" };\n  }\n\n  try {\n    const parsed = JSON.parse(input);\n    \n    // Check for circular references and limit depth\n    const sanitized = sanitizeObject(parsed, 0, 10);\n    \n    return { valid: true, data: sanitized };\n  } catch (error) {\n    return { valid: false, data: null, error: \"Invalid JSON format\" };\n  }\n}\n\n/**\n * Recursively sanitize object to prevent prototype pollution\n */\nfunction sanitizeObject(obj: any, depth: number, maxDepth: number): any {\n  if (depth > maxDepth) {\n    return null;\n  }\n\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n\n  if (typeof obj !== \"object\") {\n    return typeof obj === \"string\" ? sanitizeText(obj, 10000) : obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => sanitizeObject(item, depth + 1, maxDepth));\n  }\n\n  const sanitized: any = {};\n  for (const key in obj) {\n    // Prevent prototype pollution\n    if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n      continue;\n    }\n\n    // Sanitize key\n    const safeKey = sanitizeText(key, 100);\n    if (!safeKey || safeKey.startsWith(\"__proto__\") || safeKey.startsWith(\"constructor\")) {\n      continue;\n    }\n\n    sanitized[safeKey] = sanitizeObject(obj[key], depth + 1, maxDepth);\n  }\n\n  return sanitized;\n}\n\n/**\n * Validate email format\n */\nexport function validateEmail(email: string): boolean {\n  if (typeof email !== \"string\") {\n    return false;\n  }\n\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email) && email.length <= 254;\n}\n\n/**\n * Validate URL format and prevent SSRF\n */\nexport function validateUrl(url: string, allowedProtocols: string[] = [\"https:\", \"http:\"]): { valid: boolean; url?: URL; error?: string } {\n  if (typeof url !== \"string\") {\n    return { valid: false, error: \"URL must be a string\" };\n  }\n\n  try {\n    const parsed = new URL(url);\n\n    // Check protocol\n    if (!allowedProtocols.includes(parsed.protocol)) {\n      return { valid: false, error: `Protocol ${parsed.protocol} is not allowed` };\n    }\n\n    // Prevent localhost and private IPs (basic SSRF protection)\n    const hostname = parsed.hostname.toLowerCase();\n    if (\n      hostname === \"localhost\" ||\n      hostname === \"127.0.0.1\" ||\n      hostname.startsWith(\"192.168.\") ||\n      hostname.startsWith(\"10.\") ||\n      hostname.startsWith(\"172.16.\") ||\n      hostname.startsWith(\"172.17.\") ||\n      hostname.startsWith(\"172.18.\") ||\n      hostname.startsWith(\"172.19.\") ||\n      hostname.startsWith(\"172.20.\") ||\n      hostname.startsWith(\"172.21.\") ||\n      hostname.startsWith(\"172.22.\") ||\n      hostname.startsWith(\"172.23.\") ||\n      hostname.startsWith(\"172.24.\") ||\n      hostname.startsWith(\"172.25.\") ||\n      hostname.startsWith(\"172.26.\") ||\n      hostname.startsWith(\"172.27.\") ||\n      hostname.startsWith(\"172.28.\") ||\n      hostname.startsWith(\"172.29.\") ||\n      hostname.startsWith(\"172.30.\") ||\n      hostname.startsWith(\"172.31.\")\n    ) {\n      return { valid: false, error: \"Local and private IP addresses are not allowed\" };\n    }\n\n    return { valid: true, url: parsed };\n  } catch (error) {\n    return { valid: false, error: \"Invalid URL format\" };\n  }\n}\n\n/**\n * Validate file type by MIME type and extension\n */\nexport function validateFileType(file: File, allowedTypes: string[], allowedExtensions: string[]): { valid: boolean; error?: string } {\n  // Check MIME type\n  if (allowedTypes.length > 0 && !allowedTypes.includes(file.type)) {\n    return { valid: false, error: `File type ${file.type} is not allowed` };\n  }\n\n  // Check extension\n  const extension = \".\" + file.name.split(\".\").pop()?.toLowerCase();\n  if (allowedExtensions.length > 0 && !allowedExtensions.includes(extension)) {\n    return { valid: false, error: `File extension ${extension} is not allowed` };\n  }\n\n  return { valid: true };\n}\n\n\n\n"],"names":[],"mappings":"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"}}]
}