{
  "version": 3,
  "sources": [],
  "debugId": "8b6da056-ace1-fa45-abbb-fa39982576ef",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../src/lib/games/framework/SeededRNG.ts","../../../../src/lib/games/games/signal-hunt/SignalHunt.tsx/__nextjs-internal-proxy.mjs","../../../../src/lib/games/games/signal-hunt/index.ts","../../../../src/lib/games/games/signal-hunt/scenarioGenerator.ts","../../../../src/lib/games/games/signal-hunt/signalGenerator.ts","../../../../src/lib/games/games/signal-hunt/gameState.ts","../../../../src/lib/games/games/signal-hunt/persistence.ts","../../../../src/lib/games/games/signal-hunt/explainabilityAnalyzer.ts","../../../../src/app/games/signal-hunt/page.tsx"],"sourcesContent":["/**\n * Seeded Random Number Generator\n * \n * Uses Linear Congruential Generator (LCG) for deterministic randomness.\n * Same seed always produces same sequence - essential for daily puzzles and replays.\n * \n * Based on technical architecture specification for gold-standard implementation.\n */\n\nexport class SeededRNG {\n  private state: number;\n  \n  constructor(seed: number) {\n    // Ensure seed is positive integer\n    this.state = Math.abs(Math.floor(seed)) || 1;\n  }\n  \n  /**\n   * Generate next random number [0, 1)\n   */\n  next(): number {\n    // LCG: (a * state + c) mod m\n    // Using constants from Numerical Recipes\n    this.state = (this.state * 1664525 + 1013904223) % 2**32;\n    return this.state / 2**32;\n  }\n  \n  /**\n   * Generate random integer in range [min, max] (inclusive)\n   */\n  nextInt(min: number, max: number): number {\n    return Math.floor(this.next() * (max - min + 1)) + min;\n  }\n  \n  /**\n   * Generate random float in range [min, max)\n   */\n  nextFloat(min: number, max: number): number {\n    return min + this.next() * (max - min);\n  }\n  \n  /**\n   * Shuffle array deterministically (Fisher-Yates)\n   */\n  shuffle<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(this.next() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n  \n  /**\n   * Weighted random selection\n   * @param items Array of items to choose from\n   * @param weights Array of weights (must match items length)\n   * @returns Selected item\n   */\n  weightedChoice<T>(items: T[], weights: number[]): T {\n    if (items.length !== weights.length) {\n      throw new Error('Items and weights arrays must have same length');\n    }\n    \n    const totalWeight = weights.reduce((sum, w) => sum + w, 0);\n    if (totalWeight === 0) {\n      throw new Error('Total weight must be greater than 0');\n    }\n    \n    let random = this.next() * totalWeight;\n    \n    for (let i = 0; i < items.length; i++) {\n      random -= weights[i];\n      if (random <= 0) return items[i];\n    }\n    \n    // Fallback (should never reach here, but TypeScript requires it)\n    return items[items.length - 1];\n  }\n  \n  /**\n   * Choose random item from array\n   */\n  choice<T>(array: T[]): T {\n    if (array.length === 0) {\n      throw new Error('Cannot choose from empty array');\n    }\n    return array[this.nextInt(0, array.length - 1)];\n  }\n  \n  /**\n   * Sample n items from array without replacement\n   */\n  sample<T>(array: T[], n: number): T[] {\n    if (n > array.length) {\n      throw new Error('Sample size cannot be larger than array length');\n    }\n    \n    const indices = new Set<number>();\n    const result: T[] = [];\n    \n    while (indices.size < n) {\n      const index = this.nextInt(0, array.length - 1);\n      if (!indices.has(index)) {\n        indices.add(index);\n        result.push(array[index]);\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get current state (for save/restore)\n   */\n  getState(): number {\n    return this.state;\n  }\n  \n  /**\n   * Restore state (for replay)\n   */\n  setState(state: number): void {\n    this.state = Math.abs(Math.floor(state)) || 1;\n  }\n  \n  /**\n   * Create a new RNG instance with same seed (for testing/debugging)\n   */\n  clone(): SeededRNG {\n    const cloned = new SeededRNG(this.state);\n    return cloned;\n  }\n}\n\n/**\n * Generate daily seed from date string (YYYY-MM-DD UTC)\n */\nexport function getDailySeed(): number {\n  const today = new Date();\n  const year = today.getUTCFullYear();\n  const month = String(today.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(today.getUTCDate()).padStart(2, '0');\n  const dateStr = `${year}-${month}-${day}`;\n  \n  // Simple hash function (FNV-1a inspired)\n  let hash = 2166136261; // FNV offset basis\n  for (let i = 0; i < dateStr.length; i++) {\n    hash ^= dateStr.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  \n  return Math.abs(hash >>> 0); // Convert to unsigned 32-bit integer\n}\n\n/**\n * Generate variant seed for different difficulty tiers\n * Same base seed with different variants produces different but deterministic sequences\n */\nexport function getDailySeedVariant(baseSeed: number, variant: string): number {\n  let hash = 2166136261;\n  for (let i = 0; i < variant.length; i++) {\n    hash ^= variant.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  return (baseSeed ^ hash) >>> 0; // XOR for variant\n}\n\n/**\n * Hash string to number (simple implementation)\n */\nexport function hashString(str: string): number {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash);\n}\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/lib/games/games/signal-hunt/SignalHunt.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/games/games/signal-hunt/SignalHunt.tsx\",\n    \"default\",\n);\n","/**\n * Signal Hunt - Exports\n */\n\nexport { default } from './SignalHunt';\nexport * from './types';\nexport * from './scenarioGenerator';\nexport * from './signalGenerator';\nexport * from './gameState';\nexport * from './persistence';\nexport * from './explainabilityAnalyzer';\n","/**\n * Scenario Generator\n * \n * Generates deterministic scenarios for Signal Hunt.\n */\n\nimport { SeededRNG } from '@/lib/games/framework/SeededRNG';\nimport type { Scenario, Difficulty } from './types';\n\nexport function generateScenario(\n  seed: number,\n  difficulty: Difficulty\n): Scenario {\n  const rng = new SeededRNG(seed);\n  const config = getDifficultyConfig(difficulty);\n  \n  return {\n    id: `scenario-${seed}`,\n    name: getScenarioName(difficulty),\n    description: getScenarioDescription(difficulty),\n    adversaryType: getAdversaryType(rng),\n    environmentNoise: config.falsePositiveRate,\n    difficulty,\n    totalTurns: config.totalTurns,\n    initialBudget: {\n      actions: config.initialActions,\n      budget: config.initialBudget,\n    },\n  };\n}\n\ninterface DifficultyConfig {\n  totalTurns: number;\n  falsePositiveRate: number;\n  initialActions: number;\n  initialBudget: number;\n}\n\nfunction getDifficultyConfig(difficulty: Difficulty): DifficultyConfig {\n  switch (difficulty) {\n    case 'foundations':\n      return {\n        totalTurns: 8,\n        falsePositiveRate: 0.2,\n        initialActions: 5,\n        initialBudget: 8,\n      };\n    case 'intermediate':\n      return {\n        totalTurns: 10,\n        falsePositiveRate: 0.35,\n        initialActions: 4,\n        initialBudget: 6,\n      };\n    case 'advanced':\n      return {\n        totalTurns: 12,\n        falsePositiveRate: 0.4,\n        initialActions: 3,\n        initialBudget: 5,\n      };\n    case 'expert':\n      return {\n        totalTurns: 12,\n        falsePositiveRate: 0.5,\n        initialActions: 2,\n        initialBudget: 3,\n      };\n  }\n}\n\nfunction getScenarioName(difficulty: Difficulty): string {\n  const names = {\n    foundations: 'SOC Training Scenario',\n    intermediate: 'Incident Response Challenge',\n    advanced: 'Advanced Threat Triage',\n    expert: 'Elite Security Operations',\n  };\n  return names[difficulty];\n}\n\nfunction getScenarioDescription(difficulty: Difficulty): string {\n  const descriptions = {\n    foundations: 'Learn the basics of security signal triage in a controlled environment.',\n    intermediate: 'Manage security signals under moderate pressure with realistic false positive rates.',\n    advanced: 'Handle complex security incidents with multiple simultaneous threats.',\n    expert: 'Master elite-level security operations with adversarial threats and high noise.',\n  };\n  return descriptions[difficulty];\n}\n\nfunction getAdversaryType(rng: SeededRNG): string {\n  const types = [\n    'Script Kiddie',\n    'Organized Crime',\n    'Advanced Persistent Threat',\n    'Insider Threat',\n    'Nation State Actor',\n  ];\n  return rng.sample(types, 1)[0];\n}\n","/**\n * Signal Generator\n * \n * Generates deterministic security signals based on seed and phase.\n */\n\nimport { SeededRNG } from '@/lib/games/framework/SeededRNG';\nimport type { Signal, Evidence, Difficulty } from './types';\n\nexport function generateSignalQueue(\n  seed: number,\n  turn: number,\n  phase: 1 | 2 | 3 | 4,\n  falsePositiveRate: number\n): Signal[] {\n  const rng = new SeededRNG(seed + turn * 1000);\n  const signalCount = getSignalCountForPhase(phase);\n  const signals: Signal[] = [];\n  \n  for (let i = 0; i < signalCount; i++) {\n    const isFalsePositive = rng.next() < falsePositiveRate;\n    const signal = generateSignal(rng, turn, phase, isFalsePositive);\n    signals.push(signal);\n  }\n  \n  return signals;\n}\n\nfunction generateSignal(\n  rng: SeededRNG,\n  turn: number,\n  phase: number,\n  isFalsePositive: boolean\n): Signal {\n  const signalTypes = [\n    { name: 'Unusual Network Traffic', severity: 'high' as const },\n    { name: 'Suspicious File Activity', severity: 'medium' as const },\n    { name: 'Anomalous Process Behavior', severity: 'high' as const },\n    { name: 'Failed Login Attempts', severity: 'medium' as const },\n    { name: 'Data Exfiltration Pattern', severity: 'critical' as const },\n    { name: 'Malware Signature Detected', severity: 'critical' as const },\n  ];\n  \n  const type = rng.sample(signalTypes, 1)[0];\n  const threatProbability = isFalsePositive \n    ? rng.next() * 0.3  // False positives have low threat probability\n    : 0.7 + rng.next() * 0.3;  // Real threats have high probability\n  \n  const evidence = generateEvidence(rng, phase, isFalsePositive);\n  \n  return {\n    id: `signal-${turn}-${rng.next()}`,\n    name: type.name,\n    description: `${type.name} detected from source ${rng.next().toString(36).substring(2, 8)}`,\n    severity: type.severity,\n    threatProbability,\n    evidence,\n    source: `source-${rng.next()}`,\n    timestamp: turn,\n    isFalsePositive,\n  };\n}\n\nfunction generateEvidence(\n  rng: SeededRNG,\n  phase: number,\n  isFalsePositive: boolean\n): Evidence[] {\n  const evidenceTypes: Evidence['type'][] = ['network', 'file', 'process', 'user', 'system'];\n  const count = phase <= 2 ? 2 : phase === 3 ? 3 : 4;\n  \n  const evidence: Evidence[] = [];\n  for (let i = 0; i < count; i++) {\n    const type = rng.sample(evidenceTypes, 1)[0];\n    const confidence = isFalsePositive\n      ? 0.3 + rng.next() * 0.4  // Lower confidence for false positives\n      : 0.7 + rng.next() * 0.3;  // Higher confidence for real threats\n    \n    evidence.push({\n      id: `evidence-${i}`,\n      type,\n      description: `${type} evidence ${i + 1}`,\n      confidence,\n      revealed: false,\n    });\n  }\n  \n  return evidence;\n}\n\nfunction getSignalCountForPhase(phase: 1 | 2 | 3 | 4): number {\n  switch (phase) {\n    case 1: return 3 + Math.floor(Math.random() * 2); // 3-4\n    case 2: return 5 + Math.floor(Math.random() * 2); // 5-6\n    case 3: return 6 + Math.floor(Math.random() * 2); // 6-8\n    case 4: return 8 + Math.floor(Math.random() * 2); // 8-10\n  }\n}\n","/**\n * Signal Hunt - Game State Management\n * \n * Pure functions for state transitions.\n */\n\nimport type { GameState, Scenario, Action, Threat, Signal } from './types';\nimport { generateSignalQueue } from './signalGenerator';\n\n/**\n * Initialize game state from scenario\n */\nexport function initializeGameState(scenario: Scenario, seed: number): GameState {\n  const initialSignals = generateSignalQueue(seed, 1, 1, scenario.environmentNoise);\n  \n  return {\n    currentTurn: 0,\n    totalTurns: scenario.totalTurns,\n    currentPhase: 1,\n    riskScore: 0,\n    budget: {\n      actions: scenario.initialBudget.actions,\n      budget: scenario.initialBudget.budget,\n    },\n    signalQueue: initialSignals,\n    threats: new Map(),\n    investigationHistory: [],\n    toolingActive: [],\n    posture: 'balanced',\n    seed,\n    status: 'idle',\n  };\n}\n\n/**\n * Start the game\n */\nexport function startGame(state: GameState): GameState {\n  return {\n    ...state,\n    status: 'playing',\n    currentTurn: 1,\n  };\n}\n\n/**\n * Execute turn with actions\n */\nexport function executeTurn(state: GameState, actions: Action[]): GameState {\n  if (state.status !== 'playing') {\n    return state;\n  }\n  \n  let newState = { ...state };\n  \n  // Execute each action\n  for (const action of actions) {\n    newState = applyAction(newState, action);\n  }\n  \n  // Update threat escalation\n  newState = escalateThreats(newState);\n  \n  // Generate new signals for next turn\n  if (newState.currentTurn < newState.totalTurns) {\n    const phase = getPhaseForTurn(newState.currentTurn + 1, newState.totalTurns);\n    const newSignals = generateSignalQueue(\n      newState.seed,\n      newState.currentTurn + 1,\n      phase,\n      newState.signalQueue.length > 0 ? 0.35 : 0.2 // Dynamic false positive rate\n    );\n    newState.signalQueue = [...newState.signalQueue, ...newSignals];\n  }\n  \n  // Update phase\n  newState.currentPhase = getPhaseForTurn(newState.currentTurn, newState.totalTurns);\n  \n  // Calculate risk score\n  newState.riskScore = calculateRiskScore(newState);\n  \n  // Check win/loss conditions\n  if (newState.currentTurn >= newState.totalTurns || newState.riskScore >= 100) {\n    newState.status = 'finished';\n    newState.outcome = newState.riskScore < 50 ? 'win' : 'loss';\n  } else {\n    newState.currentTurn += 1;\n  }\n  \n  return newState;\n}\n\nfunction applyAction(state: GameState, action: Action): GameState {\n  const signal = state.signalQueue.find(s => s.id === action.signalId);\n  if (!signal) return state;\n  \n  const newState = { ...state };\n  \n  switch (action.type) {\n    case 'investigate':\n      // Reveal evidence\n      signal.evidence.forEach(e => e.revealed = true);\n      // Update threat probability based on evidence\n      const avgConfidence = signal.evidence.reduce((sum, e) => sum + e.confidence, 0) / signal.evidence.length;\n      signal.threatProbability = signal.isFalsePositive \n        ? Math.max(0, signal.threatProbability - avgConfidence * 0.3)\n        : Math.min(1, signal.threatProbability + avgConfidence * 0.3);\n      \n      newState.budget.actions -= 1;\n      newState.investigationHistory.push(action);\n      break;\n      \n    case 'contain':\n      // Stop escalation\n      const threat = newState.threats.get(action.signalId);\n      if (threat) {\n        threat.state = 'contained';\n        threat.escalationLevel = Math.max(0, threat.escalationLevel - 20);\n      }\n      newState.budget.actions -= 1;\n      newState.budget.budget -= 1;\n      break;\n      \n    case 'patch':\n      // Root cause fix\n      const patchThreat = newState.threats.get(action.signalId);\n      if (patchThreat) {\n        patchThreat.state = 'resolved';\n        patchThreat.escalationLevel = 0;\n      }\n      newState.budget.actions -= 1;\n      newState.budget.budget -= 2;\n      break;\n      \n    case 'monitor':\n      // Free action, no escalation\n      break;\n      \n    case 'ignore':\n      // Remove from queue\n      newState.signalQueue = newState.signalQueue.filter(s => s.id !== action.signalId);\n      break;\n  }\n  \n  return newState;\n}\n\nfunction escalateThreats(state: GameState): GameState {\n  const newState = { ...state };\n  const newThreats = new Map(newState.threats);\n  \n  // Escalate uncontained threats\n  for (const [signalId, threat] of newThreats.entries()) {\n    if (threat.state !== 'contained' && threat.state !== 'resolved') {\n      threat.escalationLevel += threat.escalationRate;\n      if (threat.escalationLevel >= 100) {\n        threat.state = 'critical';\n      } else if (threat.escalationLevel >= 50) {\n        threat.state = 'escalating';\n      }\n    }\n  }\n  \n  // Create threats from high-probability signals\n  for (const signal of state.signalQueue) {\n    if (!newThreats.has(signal.id) && signal.threatProbability > 0.6) {\n      newThreats.set(signal.id, {\n        signalId: signal.id,\n        state: 'new',\n        escalationLevel: 0,\n        escalationRate: getEscalationRateForPhase(state.currentPhase),\n      });\n    }\n  }\n  \n  newState.threats = newThreats;\n  return newState;\n}\n\nfunction calculateRiskScore(state: GameState): number {\n  let risk = 0;\n  \n  // Base risk from threats\n  for (const threat of state.threats.values()) {\n    risk += threat.escalationLevel * 0.5;\n    if (threat.state === 'critical') {\n      risk += 30;\n    }\n  }\n  \n  // Risk from unprocessed high-severity signals\n  for (const signal of state.signalQueue) {\n    if (signal.severity === 'critical') {\n      risk += 10;\n    } else if (signal.severity === 'high') {\n      risk += 5;\n    }\n  }\n  \n  return Math.min(100, risk);\n}\n\nfunction getPhaseForTurn(turn: number, totalTurns: number): 1 | 2 | 3 | 4 {\n  const phaseSize = totalTurns / 4;\n  if (turn <= phaseSize) return 1;\n  if (turn <= phaseSize * 2) return 2;\n  if (turn <= phaseSize * 3) return 3;\n  return 4;\n}\n\nfunction getEscalationRateForPhase(phase: 1 | 2 | 3 | 4): number {\n  switch (phase) {\n    case 1: return 10; // Slow\n    case 2: return 15; // Moderate\n    case 3: return 25; // Fast\n    case 4: return 40; // Very fast\n  }\n}\n\n/**\n * Check win condition\n */\nexport function checkWinCondition(state: GameState): boolean {\n  return state.riskScore < 50 && \n         Array.from(state.threats.values()).every(t => t.state !== 'critical');\n}\n\n/**\n * Check loss condition\n */\nexport function checkLossCondition(state: GameState): boolean {\n  return state.riskScore >= 100 || \n         state.budget.actions <= 0 && state.budget.budget <= 0;\n}\n","/**\n * Signal Hunt - Persistence\n * \n * localStorage schema and persistence functions.\n */\n\nimport type { GameState } from './types';\n\nexport interface SignalHuntProgress {\n  version: 1;\n  xp: number;\n  currentTier: 'novice' | 'analyst' | 'expert' | 'master' | 'legend';\n  tierProgress: number;\n  unlockedTooling: string[];\n  unlockedPostures: string[];\n  unlockedScenarios: string[];\n  personalBests: Record<string, {\n    bestScore: number;\n    bestTurns: number;\n    bestAccuracy: number;\n  }>;\n  currentStreak: number;\n  longestStreak: number;\n  lastPlayedDate: string;\n  completedChallenges: Array<{\n    challengeCode: string;\n    completedDate: string;\n    score: number;\n    outcome: 'win' | 'loss';\n  }>;\n  stats: {\n    gamesPlayed: number;\n    gamesWon: number;\n    totalSignalsProcessed: number;\n    totalFalsePositives: number;\n    averageResponseTime: number;\n  };\n}\n\nconst STORAGE_KEY = 'signal-hunt-progress';\n\nexport function getProgress(): SignalHuntProgress {\n  if (typeof window === 'undefined') {\n    return getDefaultProgress();\n  }\n  \n  try {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (stored) {\n      const parsed = JSON.parse(stored);\n      return migrateProgress(parsed);\n    }\n  } catch (error) {\n    console.error('Error loading progress:', error);\n  }\n  \n  return getDefaultProgress();\n}\n\nexport function saveProgress(progress: SignalHuntProgress): void {\n  if (typeof window === 'undefined') return;\n  \n  try {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));\n  } catch (error) {\n    console.error('Error saving progress:', error);\n  }\n}\n\nfunction getDefaultProgress(): SignalHuntProgress {\n  return {\n    version: 1,\n    xp: 0,\n    currentTier: 'novice',\n    tierProgress: 0,\n    unlockedTooling: ['basic-investigation', 'basic-containment'],\n    unlockedPostures: ['aggressive', 'balanced', 'defensive'],\n    unlockedScenarios: ['basic-training'],\n    personalBests: {},\n    currentStreak: 0,\n    longestStreak: 0,\n    lastPlayedDate: '',\n    completedChallenges: [],\n    stats: {\n      gamesPlayed: 0,\n      gamesWon: 0,\n      totalSignalsProcessed: 0,\n      totalFalsePositives: 0,\n      averageResponseTime: 0,\n    },\n  };\n}\n\nfunction migrateProgress(progress: any): SignalHuntProgress {\n  // Migration logic for future versions\n  if (progress.version === 1) {\n    return progress as SignalHuntProgress;\n  }\n  \n  return getDefaultProgress();\n}\n\nexport function updateProgressAfterGame(\n  progress: SignalHuntProgress,\n  state: GameState,\n  score: number,\n  accuracy: number\n): SignalHuntProgress {\n  const updated = { ...progress };\n  \n  updated.stats.gamesPlayed += 1;\n  if (state.outcome === 'win') {\n    updated.stats.gamesWon += 1;\n  }\n  \n  // Update personal bests\n  const scenarioId = `scenario-${state.seed}`;\n  const currentBest = updated.personalBests[scenarioId];\n  if (!currentBest || score > currentBest.bestScore) {\n    updated.personalBests[scenarioId] = {\n      bestScore: score,\n      bestTurns: state.currentTurn,\n      bestAccuracy: accuracy,\n    };\n  }\n  \n  // Update tier\n  const tierThresholds = {\n    novice: 0,\n    analyst: 100,\n    expert: 300,\n    master: 600,\n    legend: 1000,\n  };\n  \n  const currentTierXP = tierThresholds[updated.currentTier];\n  const nextTier = getNextTier(updated.currentTier);\n  const nextTierXP = tierThresholds[nextTier];\n  \n  if (updated.xp >= nextTierXP) {\n    updated.currentTier = nextTier;\n    updated.tierProgress = 0;\n  } else {\n    updated.tierProgress = (updated.xp - currentTierXP) / (nextTierXP - currentTierXP);\n  }\n  \n  return updated;\n}\n\nfunction getNextTier(tier: SignalHuntProgress['currentTier']): SignalHuntProgress['currentTier'] {\n  const tiers: SignalHuntProgress['currentTier'][] = ['novice', 'analyst', 'expert', 'master', 'legend'];\n  const index = tiers.indexOf(tier);\n  return index < tiers.length - 1 ? tiers[index + 1] : tier;\n}\n","/**\n * Signal Hunt - Explainability Analyzer\n * \n * Generates deterministic post-run analysis.\n */\n\nimport type { GameState, Action } from './types';\n\nexport interface Analysis {\n  keyDecisions: Array<{\n    turn: number;\n    description: string;\n    impact: 'positive' | 'negative' | 'neutral';\n    reasoning: string;\n  }>;\n  mistakes: Array<{\n    turn: number;\n    description: string;\n    cost: string;\n    recommendation: string;\n  }>;\n  recommendations: Array<{\n    type: 'strategy' | 'tooling' | 'posture';\n    description: string;\n    rationale: string;\n  }>;\n  summary: string;\n}\n\nexport function analyzeRun(state: GameState): Analysis {\n  const keyDecisions: Analysis['keyDecisions'] = [];\n  const mistakes: Analysis['mistakes'] = [];\n  const recommendations: Analysis['recommendations'] = [];\n  \n  // Analyze investigation history\n  let falsePositiveCount = 0;\n  let truePositiveCount = 0;\n  \n  for (const action of state.investigationHistory) {\n    const signal = state.signalQueue.find(s => s.id === action.signalId);\n    if (signal) {\n      if (signal.isFalsePositive) {\n        falsePositiveCount++;\n        mistakes.push({\n          turn: action.timestamp,\n          description: `Investigated false positive: ${signal.name}`,\n          cost: 'Wasted 1 action token',\n          recommendation: 'Use Deep Investigation tooling to reduce false positives',\n        });\n      } else {\n        truePositiveCount++;\n        keyDecisions.push({\n          turn: action.timestamp,\n          description: `Investigated true threat: ${signal.name}`,\n          impact: 'positive',\n          reasoning: 'Investigation revealed threat, enabling optimal containment',\n        });\n      }\n    }\n  }\n  \n  // Analyze threat containment\n  for (const threat of state.threats.values()) {\n    if (threat.state === 'critical') {\n      mistakes.push({\n        turn: state.currentTurn,\n        description: `Threat escalated to critical: ${threat.signalId}`,\n        cost: 'Increased risk score significantly',\n        recommendation: 'Contain threats earlier, before escalation',\n      });\n    }\n  }\n  \n  // Generate recommendations\n  const falsePositiveRate = state.investigationHistory.length > 0\n    ? falsePositiveCount / state.investigationHistory.length\n    : 0;\n  \n  if (falsePositiveRate > 0.3) {\n    recommendations.push({\n      type: 'tooling',\n      description: 'Use Deep Investigation tooling to reduce false positives',\n      rationale: `Your false positive rate is ${Math.round(falsePositiveRate * 100)}%, which is inefficient`,\n    });\n  }\n  \n  if (state.riskScore > 70) {\n    recommendations.push({\n      type: 'strategy',\n      description: 'Focus on containment earlier in the game',\n      rationale: 'High risk score indicates threats were allowed to escalate',\n    });\n  }\n  \n  // Generate summary\n  const win = state.outcome === 'win';\n  const summary = win\n    ? `Successfully managed security signals with ${Math.round((1 - falsePositiveRate) * 100)}% accuracy. Final risk score: ${Math.round(state.riskScore)}.`\n    : `Failed to maintain security posture. Risk score exceeded threshold at ${state.currentTurn} turns. False positive rate: ${Math.round(falsePositiveRate * 100)}%.`;\n  \n  return {\n    keyDecisions,\n    mistakes: mistakes.slice(0, 3), // Top 3 mistakes\n    recommendations,\n    summary,\n  };\n}\n","import SignalHunt from \"@/lib/games/games/signal-hunt\";\n\nexport default function SignalHuntPage() {\n  return <SignalHunt />;\n}\n"],"names":[],"mappings":"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","ignoreList":[1]}}]
}