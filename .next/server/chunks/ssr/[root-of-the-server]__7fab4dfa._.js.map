{
  "version": 3,
  "sources": [],
  "debugId": "4fc456c5-4f90-1b7c-ef12-13e0ff4390c3",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../src/lib/games/framework/SeededRNG.ts","../../../../src/lib/games/games/packet-route/PacketRoute.tsx/__nextjs-internal-proxy.mjs","../../../../src/lib/games/games/packet-route/index.ts","../../../../src/lib/games/games/packet-route/topologyGenerator.ts","../../../../src/lib/games/games/packet-route/trafficGenerator.ts","../../../../src/lib/games/games/packet-route/routingEngine.ts","../../../../src/lib/games/games/packet-route/failureEngine.ts","../../../../src/lib/games/games/packet-route/gameState.ts","../../../../src/lib/games/games/packet-route/persistence.ts","../../../../src/lib/games/games/packet-route/explainabilityAnalyzer.ts","../../../../src/app/games/packet-route/page.tsx"],"sourcesContent":["/**\n * Seeded Random Number Generator\n * \n * Uses Linear Congruential Generator (LCG) for deterministic randomness.\n * Same seed always produces same sequence - essential for daily puzzles and replays.\n * \n * Based on technical architecture specification for gold-standard implementation.\n */\n\nexport class SeededRNG {\n  private state: number;\n  \n  constructor(seed: number) {\n    // Ensure seed is positive integer\n    this.state = Math.abs(Math.floor(seed)) || 1;\n  }\n  \n  /**\n   * Generate next random number [0, 1)\n   */\n  next(): number {\n    // LCG: (a * state + c) mod m\n    // Using constants from Numerical Recipes\n    this.state = (this.state * 1664525 + 1013904223) % 2**32;\n    return this.state / 2**32;\n  }\n  \n  /**\n   * Generate random integer in range [min, max] (inclusive)\n   */\n  nextInt(min: number, max: number): number {\n    return Math.floor(this.next() * (max - min + 1)) + min;\n  }\n  \n  /**\n   * Generate random float in range [min, max)\n   */\n  nextFloat(min: number, max: number): number {\n    return min + this.next() * (max - min);\n  }\n  \n  /**\n   * Shuffle array deterministically (Fisher-Yates)\n   */\n  shuffle<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(this.next() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n  \n  /**\n   * Weighted random selection\n   * @param items Array of items to choose from\n   * @param weights Array of weights (must match items length)\n   * @returns Selected item\n   */\n  weightedChoice<T>(items: T[], weights: number[]): T {\n    if (items.length !== weights.length) {\n      throw new Error('Items and weights arrays must have same length');\n    }\n    \n    const totalWeight = weights.reduce((sum, w) => sum + w, 0);\n    if (totalWeight === 0) {\n      throw new Error('Total weight must be greater than 0');\n    }\n    \n    let random = this.next() * totalWeight;\n    \n    for (let i = 0; i < items.length; i++) {\n      random -= weights[i];\n      if (random <= 0) return items[i];\n    }\n    \n    // Fallback (should never reach here, but TypeScript requires it)\n    return items[items.length - 1];\n  }\n  \n  /**\n   * Choose random item from array\n   */\n  choice<T>(array: T[]): T {\n    if (array.length === 0) {\n      throw new Error('Cannot choose from empty array');\n    }\n    return array[this.nextInt(0, array.length - 1)];\n  }\n  \n  /**\n   * Sample n items from array without replacement\n   */\n  sample<T>(array: T[], n: number): T[] {\n    if (n > array.length) {\n      throw new Error('Sample size cannot be larger than array length');\n    }\n    \n    const indices = new Set<number>();\n    const result: T[] = [];\n    \n    while (indices.size < n) {\n      const index = this.nextInt(0, array.length - 1);\n      if (!indices.has(index)) {\n        indices.add(index);\n        result.push(array[index]);\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get current state (for save/restore)\n   */\n  getState(): number {\n    return this.state;\n  }\n  \n  /**\n   * Restore state (for replay)\n   */\n  setState(state: number): void {\n    this.state = Math.abs(Math.floor(state)) || 1;\n  }\n  \n  /**\n   * Create a new RNG instance with same seed (for testing/debugging)\n   */\n  clone(): SeededRNG {\n    const cloned = new SeededRNG(this.state);\n    return cloned;\n  }\n}\n\n/**\n * Generate daily seed from date string (YYYY-MM-DD UTC)\n */\nexport function getDailySeed(): number {\n  const today = new Date();\n  const year = today.getUTCFullYear();\n  const month = String(today.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(today.getUTCDate()).padStart(2, '0');\n  const dateStr = `${year}-${month}-${day}`;\n  \n  // Simple hash function (FNV-1a inspired)\n  let hash = 2166136261; // FNV offset basis\n  for (let i = 0; i < dateStr.length; i++) {\n    hash ^= dateStr.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  \n  return Math.abs(hash >>> 0); // Convert to unsigned 32-bit integer\n}\n\n/**\n * Generate variant seed for different difficulty tiers\n * Same base seed with different variants produces different but deterministic sequences\n */\nexport function getDailySeedVariant(baseSeed: number, variant: string): number {\n  let hash = 2166136261;\n  for (let i = 0; i < variant.length; i++) {\n    hash ^= variant.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  return (baseSeed ^ hash) >>> 0; // XOR for variant\n}\n\n/**\n * Hash string to number (simple implementation)\n */\nexport function hashString(str: string): number {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash);\n}\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/lib/games/games/packet-route/PacketRoute.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/games/games/packet-route/PacketRoute.tsx\",\n    \"default\",\n);\n","/**\n * Packet Route - Exports\n */\n\nexport { default } from './PacketRoute';\nexport * from './types';\nexport * from './topologyGenerator';\nexport * from './trafficGenerator';\nexport * from './routingEngine';\nexport * from './failureEngine';\nexport * from './gameState';\nexport * from './persistence';\nexport * from './explainabilityAnalyzer';\n","/**\n * Packet Route - Topology Generator\n * \n * Generates deterministic network topologies.\n */\n\nimport { SeededRNG } from '@/lib/games/framework/SeededRNG';\nimport type { Topology, Node, Link, TopologyType, Difficulty } from './types';\n\nexport function generateTopology(\n  seed: number,\n  topologyType: TopologyType,\n  difficulty: Difficulty\n): Topology {\n  const rng = new SeededRNG(seed);\n  const config = getDifficultyConfig(difficulty);\n  \n  const { nodes, links } = generateTopologyStructure(topologyType, config, rng);\n  \n  return {\n    id: `topology-${seed}`,\n    name: `${topologyType} Network ${seed}`,\n    type: topologyType,\n    difficulty,\n    nodes,\n    links,\n    seed,\n  };\n}\n\ninterface DifficultyConfig {\n  nodeCount: number;\n  linkCapacity: number;\n  baseLatency: number;\n}\n\nfunction getDifficultyConfig(difficulty: Difficulty): DifficultyConfig {\n  switch (difficulty) {\n    case 'foundations':\n      return { nodeCount: 5, linkCapacity: 1000, baseLatency: 10 };\n    case 'intermediate':\n      return { nodeCount: 10, linkCapacity: 800, baseLatency: 15 };\n    case 'advanced':\n      return { nodeCount: 15, linkCapacity: 600, baseLatency: 20 };\n    case 'expert':\n      return { nodeCount: 20, linkCapacity: 500, baseLatency: 25 };\n  }\n}\n\nfunction generateTopologyStructure(\n  type: TopologyType,\n  config: DifficultyConfig,\n  rng: SeededRNG\n): { nodes: Node[]; links: Link[] } {\n  const nodes: Node[] = [];\n  const links: Link[] = [];\n  \n  // Generate nodes\n  for (let i = 0; i < config.nodeCount; i++) {\n    nodes.push({\n      id: `node-${i}`,\n      name: `Node ${i}`,\n      x: (i % 5) * 100 + 50,\n      y: Math.floor(i / 5) * 100 + 50,\n      capacity: 1000 + rng.next() * 500,\n      currentLoad: 0,\n    });\n  }\n  \n  // Generate links based on topology type\n  switch (type) {\n    case 'mesh':\n      // Fully connected\n      for (let i = 0; i < nodes.length; i++) {\n        for (let j = i + 1; j < nodes.length; j++) {\n          links.push(createLink(nodes[i].id, nodes[j].id, config, rng));\n        }\n      }\n      break;\n    case 'star':\n      // Central node connected to all others\n      const center = nodes[0];\n      for (let i = 1; i < nodes.length; i++) {\n        links.push(createLink(center.id, nodes[i].id, config, rng));\n      }\n      break;\n    case 'tree':\n      // Tree structure\n      for (let i = 1; i < nodes.length; i++) {\n        const parent = nodes[Math.floor((i - 1) / 2)];\n        links.push(createLink(parent.id, nodes[i].id, config, rng));\n      }\n      break;\n    case 'ring':\n      // Ring structure\n      for (let i = 0; i < nodes.length; i++) {\n        const next = nodes[(i + 1) % nodes.length];\n        links.push(createLink(nodes[i].id, next.id, config, rng));\n      }\n      break;\n    case 'hybrid':\n      // Combination (simplified)\n      // Start with ring, add some cross-connections\n      for (let i = 0; i < nodes.length; i++) {\n        const next = nodes[(i + 1) % nodes.length];\n        links.push(createLink(nodes[i].id, next.id, config, rng));\n      }\n      // Add some random cross-connections\n      for (let i = 0; i < nodes.length / 2; i++) {\n        const from = rng.sample(nodes, 1)[0];\n        const to = rng.sample(nodes.filter(n => n.id !== from.id), 1)[0];\n        if (!links.find(l => (l.from === from.id && l.to === to.id) || (l.from === to.id && l.to === from.id))) {\n          links.push(createLink(from.id, to.id, config, rng));\n        }\n      }\n      break;\n  }\n  \n  return { nodes, links };\n}\n\nfunction createLink(\n  from: string,\n  to: string,\n  config: DifficultyConfig,\n  rng: SeededRNG\n): Link {\n  return {\n    id: `link-${from}-${to}`,\n    from,\n    to,\n    capacity: config.linkCapacity + rng.next() * 200,\n    latency: config.baseLatency + rng.next() * 10,\n    currentLoad: 0,\n    failed: false,\n  };\n}\n","/**\n * Packet Route - Traffic Generator\n * \n * Generates deterministic traffic patterns.\n */\n\nimport { SeededRNG } from '@/lib/games/framework/SeededRNG';\nimport type { TrafficFlow, Node } from './types';\n\nexport function generateTrafficPattern(\n  seed: number,\n  tick: number,\n  nodes: Node[]\n): TrafficFlow[] {\n  const rng = new SeededRNG(seed + tick * 1000);\n  const flowCount = 3 + Math.floor(rng.next() * 3); // 3-5 flows\n  const flows: TrafficFlow[] = [];\n  \n  for (let i = 0; i < flowCount; i++) {\n    const source = rng.sample(nodes, 1)[0];\n    const destination = rng.sample(nodes.filter(n => n.id !== source.id), 1)[0];\n    \n    flows.push({\n      id: `flow-${tick}-${i}`,\n      source: source.id,\n      destination: destination.id,\n      rate: 100 + rng.next() * 200, // packets per second\n      route: [], // Will be calculated by routing engine\n    });\n  }\n  \n  return flows;\n}\n","/**\n * Packet Route - Routing Engine\n * \n * Calculates routes based on routing policy.\n */\n\nimport type { GameState, TrafficFlow, Node, Link, RoutingPolicyConfig } from './types';\n\n/**\n * Calculate routes for all traffic flows\n */\nexport function calculateRoutes(state: GameState): TrafficFlow[] {\n  const flows: TrafficFlow[] = [];\n  \n  for (const flow of state.trafficFlows) {\n    const route = calculateRoute(\n      flow.source,\n      flow.destination,\n      state.topology.nodes,\n      state.topology.links,\n      state.routingPolicy\n    );\n    flows.push({\n      ...flow,\n      route,\n    });\n  }\n  \n  return flows;\n}\n\nfunction calculateRoute(\n  source: string,\n  destination: string,\n  nodes: Node[],\n  links: Link[],\n  policy: RoutingPolicyConfig\n): string[] {\n  // Simplified routing - in full implementation, would use Dijkstra's algorithm\n  // or other routing algorithms based on policy\n  \n  switch (policy.type) {\n    case 'shortest-path':\n      return calculateShortestPath(source, destination, nodes, links);\n    case 'load-balanced':\n      return calculateLoadBalancedPath(source, destination, nodes, links);\n    case 'resilient':\n      return calculateResilientPath(source, destination, nodes, links);\n    case 'hybrid':\n      return calculateShortestPath(source, destination, nodes, links); // Simplified\n    default:\n      return calculateShortestPath(source, destination, nodes, links);\n  }\n}\n\nfunction calculateShortestPath(\n  source: string,\n  destination: string,\n  nodes: Node[],\n  links: Link[]\n): string[] {\n  // Simplified shortest path (Dijkstra's would be used in full implementation)\n  const sourceNode = nodes.find(n => n.id === source);\n  const destNode = nodes.find(n => n.id === destination);\n  \n  if (!sourceNode || !destNode) return [source];\n  \n  // Find direct link\n  const directLink = links.find(l => \n    (l.from === source && l.to === destination) && !l.failed\n  );\n  if (directLink) {\n    return [source, destination];\n  }\n  \n  // Find path through one intermediate node\n  for (const node of nodes) {\n    if (node.id === source || node.id === destination) continue;\n    const link1 = links.find(l => l.from === source && l.to === node.id && !l.failed);\n    const link2 = links.find(l => l.from === node.id && l.to === destination && !l.failed);\n    if (link1 && link2) {\n      return [source, node.id, destination];\n    }\n  }\n  \n  return [source]; // No path found\n}\n\nfunction calculateLoadBalancedPath(\n  source: string,\n  destination: string,\n  nodes: Node[],\n  links: Link[]\n): string[] {\n  // Simplified - would consider current link loads\n  return calculateShortestPath(source, destination, nodes, links);\n}\n\nfunction calculateResilientPath(\n  source: string,\n  destination: string,\n  nodes: Node[],\n  links: Link[]\n): string[] {\n  // Simplified - would prefer paths with redundancy\n  return calculateShortestPath(source, destination, nodes, links);\n}\n\n/**\n * Simulate packet flow and calculate metrics\n */\nexport function simulatePacketFlow(state: GameState): GameState {\n  const flows = calculateRoutes(state);\n  \n  // Update link loads\n  const updatedLinks = state.topology.links.map(link => {\n    let load = 0;\n    for (const flow of flows) {\n      for (let i = 0; i < flow.route.length - 1; i++) {\n        if ((flow.route[i] === link.from && flow.route[i + 1] === link.to) ||\n            (flow.route[i] === link.to && flow.route[i + 1] === link.from)) {\n          load += flow.rate;\n        }\n      }\n    }\n    return {\n      ...link,\n      currentLoad: Math.min(1, load / link.capacity),\n    };\n  });\n  \n  // Calculate metrics\n  const totalLatency = flows.reduce((sum, flow) => {\n    let latency = 0;\n    for (let i = 0; i < flow.route.length - 1; i++) {\n      const link = updatedLinks.find(l =>\n        (l.from === flow.route[i] && l.to === flow.route[i + 1]) ||\n        (l.from === flow.route[i + 1] && l.to === flow.route[i])\n      );\n      if (link) {\n        latency += link.latency * (1 + link.currentLoad); // Latency increases with load\n      }\n    }\n    return sum + latency;\n  }, 0);\n  \n  const averageLatency = flows.length > 0 ? totalLatency / flows.length : 0;\n  const throughput = flows.reduce((sum, flow) => sum + flow.rate, 0);\n  const packetLoss = updatedLinks.reduce((sum, link) => {\n    return sum + Math.max(0, link.currentLoad - 1); // Loss when overloaded\n  }, 0) / updatedLinks.length;\n  \n  const congestionLevel = updatedLinks.reduce((sum, link) => sum + link.currentLoad, 0) / updatedLinks.length;\n  \n  // Check SLA compliance\n  const slaMet = averageLatency <= state.slaTargets.maxLatency &&\n                 throughput >= state.slaTargets.minThroughput &&\n                 packetLoss <= state.slaTargets.maxLoss;\n  \n  const availability = state.metrics.availability * 0.9 + (slaMet ? 0.1 : 0);\n  \n  return {\n    ...state,\n    topology: {\n      ...state.topology,\n      links: updatedLinks,\n    },\n    trafficFlows: flows,\n    metrics: {\n      averageLatency,\n      throughput,\n      packetLoss,\n      congestionLevel,\n      availability,\n    },\n  };\n}\n","/**\n * Packet Route - Failure Engine\n * \n * Generates and applies network failures.\n */\n\nimport { SeededRNG } from '@/lib/games/framework/SeededRNG';\nimport type { GameState, Link } from './types';\n\n/**\n * Generate failures for a tick\n */\nexport function generateFailures(\n  seed: number,\n  tick: number,\n  phase: number,\n  links: Link[]\n): string[] {\n  const rng = new SeededRNG(seed + tick * 2000);\n  const failureRate = getFailureRateForPhase(phase);\n  \n  const failures: string[] = [];\n  for (const link of links) {\n    if (!link.failed && rng.next() < failureRate) {\n      failures.push(link.id);\n    }\n  }\n  \n  return failures;\n}\n\n/**\n * Apply failures to game state\n */\nexport function applyFailures(state: GameState, failureIds: string[]): GameState {\n  const updatedLinks = state.topology.links.map(link => ({\n    ...link,\n    failed: link.failed || failureIds.includes(link.id),\n  }));\n  \n  return {\n    ...state,\n    topology: {\n      ...state.topology,\n      links: updatedLinks,\n    },\n    failures: [...state.failures, ...failureIds],\n  };\n}\n\nfunction getFailureRateForPhase(phase: number): number {\n  switch (phase) {\n    case 1: return 0.05; // 5% chance\n    case 2: return 0.10; // 10% chance\n    case 3: return 0.20; // 20% chance\n    case 4: return 0.30; // 30% chance\n    default: return 0.10;\n  }\n}\n","/**\n * Packet Route - Game State Management\n */\n\nimport type { GameState, Topology, RoutingPolicyConfig, SLATargets } from './types';\nimport { generateTrafficPattern } from './trafficGenerator';\nimport { simulatePacketFlow } from './routingEngine';\nimport { generateFailures, applyFailures } from './failureEngine';\n\n/**\n * Initialize game state\n */\nexport function initializeGameState(\n  topology: Topology,\n  slaTargets: SLATargets,\n  seed: number\n): GameState {\n  const initialTraffic = generateTrafficPattern(seed, 1, topology.nodes);\n  \n  return {\n    topology,\n    currentTick: 0,\n    totalTicks: getTotalTicksForDifficulty(topology.difficulty),\n    routingPolicy: {\n      type: 'shortest-path',\n      parameters: {},\n    },\n    trafficFlows: initialTraffic,\n    slaTargets,\n    metrics: {\n      averageLatency: 0,\n      throughput: 0,\n      packetLoss: 0,\n      congestionLevel: 0,\n      availability: 1.0,\n    },\n    failures: [],\n    seed,\n    status: 'idle',\n  };\n}\n\n/**\n * Start the game\n */\nexport function startGame(state: GameState): GameState {\n  return {\n    ...state,\n    status: 'playing',\n    currentTick: 1,\n  };\n}\n\n/**\n * Execute tick\n */\nexport function executeTick(state: GameState): GameState {\n  if (state.status !== 'playing') return state;\n  \n  let newState = { ...state };\n  \n  // Generate new traffic\n  const newTraffic = generateTrafficPattern(newState.seed, newState.currentTick, newState.topology.nodes);\n  newState.trafficFlows = newTraffic;\n  \n  // Generate failures\n  const phase = getPhaseForTick(newState.currentTick, newState.totalTicks);\n  const failures = generateFailures(newState.seed, newState.currentTick, phase, newState.topology.links);\n  newState = applyFailures(newState, failures);\n  \n  // Simulate packet flow\n  newState = simulatePacketFlow(newState);\n  \n  // Advance tick\n  newState.currentTick += 1;\n  \n  // Check win/loss\n  if (newState.currentTick > newState.totalTicks) {\n    newState.status = 'finished';\n    newState.outcome = newState.metrics.availability >= 0.95 ? 'win' : 'loss';\n  } else if (newState.metrics.availability < 0.5) {\n    // Critical failure\n    newState.status = 'finished';\n    newState.outcome = 'loss';\n  }\n  \n  return newState;\n}\n\n/**\n * Update routing policy\n */\nexport function updateRoutingPolicy(\n  state: GameState,\n  policy: RoutingPolicyConfig\n): GameState {\n  return {\n    ...state,\n    routingPolicy: policy,\n  };\n}\n\nfunction getTotalTicksForDifficulty(difficulty: GameState['topology']['difficulty']): number {\n  switch (difficulty) {\n    case 'foundations': return 20;\n    case 'intermediate': return 30;\n    case 'advanced': return 40;\n    case 'expert': return 40;\n  }\n}\n\nfunction getPhaseForTick(tick: number, totalTicks: number): number {\n  const phaseSize = totalTicks / 4;\n  if (tick <= phaseSize) return 1;\n  if (tick <= phaseSize * 2) return 2;\n  if (tick <= phaseSize * 3) return 3;\n  return 4;\n}\n\n/**\n * Check win condition\n */\nexport function checkWinCondition(state: GameState): boolean {\n  return state.metrics.availability >= 0.95;\n}\n\n/**\n * Check loss condition\n */\nexport function checkLossCondition(state: GameState): boolean {\n  return state.metrics.availability < 0.5;\n}\n","/**\n * Packet Route - Persistence\n */\n\nimport type { GameState } from './types';\n\nexport interface PacketRouteProgress {\n  version: 1;\n  xp: number;\n  currentTier: 'operator' | 'engineer' | 'architect' | 'master' | 'legend';\n  tierProgress: number;\n  unlockedTopologies: string[];\n  unlockedPolicyTypes: string[];\n  unlockedTools: string[];\n  personalBests: Record<string, {\n    bestScore: number;\n    bestLatency: number;\n    bestThroughput: number;\n    bestAvailability: number;\n  }>;\n  currentStreak: number;\n  longestStreak: number;\n  lastPlayedDate: string;\n  completedChallenges: Array<{\n    challengeCode: string;\n    completedDate: string;\n    score: number;\n    latency: number;\n    throughput: number;\n    availability: number;\n    policyHash: string;\n  }>;\n  stats: {\n    topologiesCompleted: number;\n    averageLatency: number;\n    averageThroughput: number;\n    averageAvailability: number;\n    bottleneckIdentifications: number;\n    policyChanges: number;\n    topologyTypeStats: Record<string, {\n      completed: number;\n      averageScore: number;\n      averageLatency: number;\n    }>;\n  };\n}\n\nconst STORAGE_KEY = 'packet-route-progress';\n\nexport function getProgress(): PacketRouteProgress {\n  if (typeof window === 'undefined') {\n    return getDefaultProgress();\n  }\n  \n  try {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (stored) {\n      return JSON.parse(stored);\n    }\n  } catch (error) {\n    console.error('Error loading progress:', error);\n  }\n  \n  return getDefaultProgress();\n}\n\nexport function saveProgress(progress: PacketRouteProgress): void {\n  if (typeof window === 'undefined') return;\n  \n  try {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));\n  } catch (error) {\n    console.error('Error saving progress:', error);\n  }\n}\n\nfunction getDefaultProgress(): PacketRouteProgress {\n  return {\n    version: 1,\n    xp: 0,\n    currentTier: 'operator',\n    tierProgress: 0,\n    unlockedTopologies: ['mesh', 'star'],\n    unlockedPolicyTypes: ['shortest-path', 'load-balanced'],\n    unlockedTools: [],\n    personalBests: {},\n    currentStreak: 0,\n    longestStreak: 0,\n    lastPlayedDate: '',\n    completedChallenges: [],\n    stats: {\n      topologiesCompleted: 0,\n      averageLatency: 0,\n      averageThroughput: 0,\n      averageAvailability: 0,\n      bottleneckIdentifications: 0,\n      policyChanges: 0,\n      topologyTypeStats: {},\n    },\n  };\n}\n\nexport function updateProgressAfterGame(\n  progress: PacketRouteProgress,\n  state: GameState,\n  score: number\n): PacketRouteProgress {\n  const updated = { ...progress };\n  \n  updated.stats.topologiesCompleted += 1;\n  updated.stats.averageLatency = \n    (updated.stats.averageLatency * (updated.stats.topologiesCompleted - 1) + state.metrics.averageLatency) / \n    updated.stats.topologiesCompleted;\n  updated.stats.averageThroughput = \n    (updated.stats.averageThroughput * (updated.stats.topologiesCompleted - 1) + state.metrics.throughput) / \n    updated.stats.topologiesCompleted;\n  updated.stats.averageAvailability = \n    (updated.stats.averageAvailability * (updated.stats.topologiesCompleted - 1) + state.metrics.availability) / \n    updated.stats.topologiesCompleted;\n  \n  // Update personal bests\n  const topologyId = `topology-${state.seed}`;\n  const currentBest = updated.personalBests[topologyId];\n  if (!currentBest || score > currentBest.bestScore) {\n    updated.personalBests[topologyId] = {\n      bestScore: score,\n      bestLatency: state.metrics.averageLatency,\n      bestThroughput: state.metrics.throughput,\n      bestAvailability: state.metrics.availability,\n    };\n  }\n  \n  return updated;\n}\n","/**\n * Packet Route - Explainability Analyzer\n */\n\nimport type { GameState } from './types';\n\nexport interface Analysis {\n  keyDecisions: Array<{\n    tick: number;\n    description: string;\n    impact: 'positive' | 'negative' | 'neutral';\n    reasoning: string;\n  }>;\n  mistakes: Array<{\n    tick: number;\n    description: string;\n    cost: string;\n    recommendation: string;\n  }>;\n  recommendations: Array<{\n    type: 'policy' | 'routing' | 'resilience';\n    description: string;\n    rationale: string;\n  }>;\n  summary: string;\n}\n\nexport function analyzeRun(state: GameState): Analysis {\n  const keyDecisions: Analysis['keyDecisions'] = [];\n  const mistakes: Analysis['mistakes'] = [];\n  const recommendations: Analysis['recommendations'] = [];\n  \n  // Analyze congestion\n  const congestedLinks = state.topology.links.filter(l => l.currentLoad > 0.8);\n  if (congestedLinks.length > 0) {\n    mistakes.push({\n      tick: state.currentTick,\n      description: `${congestedLinks.length} links are congested (>80% load)`,\n      cost: 'Increased latency and packet loss',\n      recommendation: 'Use load balancing policy to distribute traffic',\n    });\n  }\n  \n  // Analyze failures\n  if (state.failures.length > 0) {\n    keyDecisions.push({\n      tick: state.currentTick,\n      description: `Handled ${state.failures.length} link failures`,\n      impact: state.metrics.availability > 0.9 ? 'positive' : 'negative',\n      reasoning: state.metrics.availability > 0.9 \n        ? 'Failures handled well, maintained availability'\n        : 'Failures caused availability issues',\n    });\n  }\n  \n  // Generate recommendations\n  if (state.metrics.congestionLevel > 0.7) {\n    recommendations.push({\n      type: 'routing',\n      description: 'Switch to load-balanced routing policy',\n      rationale: 'High congestion indicates need for better traffic distribution',\n    });\n  }\n  \n  if (state.failures.length > 0 && state.metrics.availability < 0.9) {\n    recommendations.push({\n      type: 'resilience',\n      description: 'Implement resilient routing with backup paths',\n      rationale: 'Failures caused availability issues, need better resilience',\n    });\n  }\n  \n  const win = state.outcome === 'win';\n  const summary = win\n    ? `Successfully maintained SLA targets with ${(state.metrics.availability * 100).toFixed(1)}% availability. Average latency: ${state.metrics.averageLatency.toFixed(1)}ms.`\n    : `Failed to maintain SLA targets. Availability dropped to ${(state.metrics.availability * 100).toFixed(1)}%.`;\n  \n  return {\n    keyDecisions: keyDecisions.slice(0, 3),\n    mistakes: mistakes.slice(0, 3),\n    recommendations,\n    summary,\n  };\n}\n","import PacketRoute from \"@/lib/games/games/packet-route\";\n\nexport default function PacketRoutePage() {\n  return <PacketRoute />;\n}\n"],"names":[],"mappings":"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","ignoreList":[1]}}]
}