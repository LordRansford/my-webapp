{
  "version": 3,
  "sources": [],
  "debugId": "8e91a0b2-c2a4-d1d5-d27f-7092352b8c9d",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../src/lib/security/rateLimit.ts","../../../src/lib/security/origin.ts","../../../src/lib/security/requestLog.ts","../../../src/lib/credits/store.ts","../../../src/lib/credits/deductFromLots.ts","../../../src/lib/credits/enforceCreditGate.ts","../../../src/lib/cpd/courseVersion.ts","../../../src/lib/cpd/assessmentCredits.ts","../../../src/lib/cpd/calculations.core.js","../../../src/lib/cpd/evidence.core.ts","../../../src/lib/cpd/evidence.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport crypto from \"crypto\";\n\ntype Options = {\n  keyPrefix: string;\n  limit: number;\n  windowMs: number;\n  keySuffix?: string;\n  message?: string;\n};\n\ntype Entry = { count: number; resetAt: number };\n\nconst buckets = new Map<string, Entry>();\n\nfunction hash(value: string) {\n  return crypto.createHash(\"sha256\").update(value).digest(\"hex\").slice(0, 24);\n}\n\nfunction getClientKey(req: Request, keySuffix?: string) {\n  // Privacy: we do not persist IPs; we only keep a short-lived hash in memory.\n  const forwarded = req.headers.get(\"x-forwarded-for\") || \"\";\n  const ip = forwarded.split(\",\")[0]?.trim() || req.headers.get(\"x-real-ip\") || \"unknown\";\n  const ua = req.headers.get(\"user-agent\") || \"unknown\";\n  return hash(`${ip}|${ua}|${keySuffix || \"\"}`);\n}\n\nexport function rateLimit(req: Request, opts: Options) {\n  const now = Date.now();\n  const key = `${opts.keyPrefix}:${getClientKey(req, opts.keySuffix)}`;\n  const existing = buckets.get(key);\n  if (!existing || existing.resetAt <= now) {\n    buckets.set(key, { count: 1, resetAt: now + opts.windowMs });\n    return null;\n  }\n  existing.count += 1;\n  if (existing.count > opts.limit) {\n    const retryAfter = Math.max(1, Math.ceil((existing.resetAt - now) / 1000));\n    return NextResponse.json(\n      { error: opts.message || \"Too many requests. Please try again shortly.\" },\n      { status: 429, headers: { \"retry-after\": String(retryAfter) } }\n    );\n  }\n  return null;\n}\n\n\n","import { NextResponse } from \"next/server\";\n\nfunction getSiteOrigin() {\n  try {\n    return new URL(process.env.NEXT_PUBLIC_SITE_URL || \"http://localhost:3000\").origin;\n  } catch {\n    return \"http://localhost:3000\";\n  }\n}\n\nexport function requireSameOrigin(req: Request) {\n  // Lightweight CSRF protection for browser-invoked state changes:\n  // require Origin/Referer to match our configured site origin.\n  const origin = req.headers.get(\"origin\");\n  const referer = req.headers.get(\"referer\");\n  const siteOrigin = getSiteOrigin();\n  let requestOrigin: string | null = null;\n  try {\n    requestOrigin = new URL(req.url).origin;\n  } catch {\n    requestOrigin = null;\n  }\n\n  const candidate = origin || (referer ? (() => { try { return new URL(referer).origin; } catch { return null; } })() : null);\n  // Some same-site requests may not include Origin or Referer.\n  // For CSRF prevention we only need to reject cross-site browser requests, which do send Origin.\n  // If the request has no Origin/Referer we allow it when the request origin is known.\n  if (!candidate) {\n    if (requestOrigin) return null;\n    return NextResponse.json({ error: \"Missing origin\" }, { status: 403 });\n  }\n  // Accept either:\n  // - the configured canonical site origin (e.g. production custom domain), or\n  // - the request origin (e.g. Vercel preview domain), as long as the browser supplies Origin/Referer.\n  if (candidate !== siteOrigin && (!requestOrigin || candidate !== requestOrigin)) {\n    return NextResponse.json({ error: \"Invalid origin\" }, { status: 403 });\n  }\n  return null;\n}\n\n\n","import crypto from \"crypto\";\n\nexport function getRequestId(req: Request) {\n  return req.headers.get(\"x-request-id\") || crypto.randomUUID();\n}\n\nexport async function withRequestLogging<T>(\n  req: Request,\n  meta: { route: string },\n  fn: (ctx: { requestId: string }) => Promise<T>\n) {\n  const requestId = getRequestId(req);\n  const start = Date.now();\n  try {\n    const result = await fn({ requestId });\n    const durationMs = Date.now() - start;\n    console.info(\"req\", { requestId, route: meta.route, status: \"ok\", durationMs });\n    return result;\n  } catch (err: any) {\n    const durationMs = Date.now() - start;\n    console.error(\"req\", { requestId, route: meta.route, status: \"error\", durationMs, message: err?.message || \"error\" });\n    throw err;\n  }\n}\n\n\n","import { prisma } from \"@/lib/db/prisma\";\n\nconst DEFAULT_CREDIT_EXPIRY_DAYS = 365 * 2; // 24 months (recommended default)\nconst CREDIT_EXPIRY_DAYS = (() => {\n  const raw = process.env.CREDITS_EXPIRY_DAYS;\n  const n = raw ? Number(raw) : NaN;\n  return Number.isFinite(n) && n > 0 ? Math.floor(n) : DEFAULT_CREDIT_EXPIRY_DAYS;\n})();\n\nfunction addDays(date: Date, days: number) {\n  const d = new Date(date);\n  d.setDate(d.getDate() + days);\n  return d;\n}\n\nexport async function getOrCreateCredits(userId: string) {\n  const existing = await prisma.credits.findUnique({ where: { userId } });\n  if (existing) return existing;\n  return await prisma.credits.create({ data: { userId, balance: 0, expiresAt: null } });\n}\n\nexport async function getCreditsAggregate() {\n  const totalUsersWithCredits = await prisma.credits.count();\n  const sum = await prisma.credits.aggregate({ _sum: { balance: true } });\n  return {\n    totalUsersWithCredits,\n    totalCredits: sum._sum.balance ?? 0,\n  };\n}\n\nexport async function enforceCreditExpiry(userId: string) {\n  const credits = await prisma.credits.findUnique({ where: { userId } });\n  if (!credits) return null;\n  if (!credits.expiresAt) return credits;\n  const now = new Date();\n  if (credits.expiresAt.getTime() > now.getTime()) return credits;\n  // Expired: reset to zero but keep record.\n  return await prisma.credits.update({ where: { userId }, data: { balance: 0 } });\n}\n\nexport async function createCreditUsageEvent(input: {\n  userId: string;\n  toolId: string;\n  consumed: number;\n  units: number;\n  freeUnits: number;\n  paidUnits: number;\n  runId?: string | null;\n  baseFree?: boolean;\n  estimatedCredits?: number;\n  actualCredits?: number;\n  meteringUnit?: string;\n  durationMs?: number;\n  inputBytes?: number;\n  outputBytes?: number;\n  freeTierAppliedMs?: number;\n  paidMs?: number;\n}) {\n  return prisma.creditUsageEvent.create({\n    data: {\n      userId: input.userId,\n      toolId: input.toolId,\n      consumed: input.consumed,\n      units: input.units,\n      freeUnits: input.freeUnits,\n      paidUnits: input.paidUnits,\n      runId: input.runId || null,\n      baseFree: Boolean(input.baseFree),\n      estimatedCredits: Math.max(0, Math.round(Number(input.estimatedCredits) || 0)),\n      actualCredits: Math.max(0, Math.round(Number(input.actualCredits) || 0)),\n      meteringUnit: input.meteringUnit || \"ms\",\n      durationMs: Math.max(0, Math.round(Number(input.durationMs) || 0)),\n      inputBytes: Math.max(0, Math.round(Number(input.inputBytes) || 0)),\n      outputBytes: Math.max(0, Math.round(Number(input.outputBytes) || 0)),\n      freeTierAppliedMs: Math.max(0, Math.round(Number(input.freeTierAppliedMs) || 0)),\n      paidMs: Math.max(0, Math.round(Number(input.paidMs) || 0)),\n    },\n  });\n}\n\nexport async function listCreditUsage(userId: string, limit = 50) {\n  return prisma.creditUsageEvent.findMany({\n    where: { userId },\n    orderBy: { occurredAt: \"desc\" },\n    take: Math.max(1, Math.min(200, limit)),\n  });\n}\n\nexport function computeNewExpiry(from = new Date()) {\n  return addDays(from, CREDIT_EXPIRY_DAYS);\n}\n\nexport async function createCreditLot(input: {\n  userId: string;\n  credits: number;\n  source: string;\n  stripeEventId?: string | null;\n  stripePriceId?: string | null;\n  stripeCheckoutSessionId?: string | null;\n  stripePaymentIntentId?: string | null;\n  expiresAt?: Date | null;\n}) {\n  const credits = Math.max(0, Math.round(Number(input.credits) || 0));\n  return prisma.creditLot.create({\n    data: {\n      userId: input.userId,\n      credits,\n      amountCredits: credits,\n      remainingCredits: credits,\n      source: input.source,\n      stripeEventId: input.stripeEventId || null,\n      stripePriceId: input.stripePriceId || null,\n      stripeCheckoutSessionId: input.stripeCheckoutSessionId || null,\n      stripePaymentIntentId: input.stripePaymentIntentId || null,\n      expiresAt: input.expiresAt || null,\n    },\n  });\n}\n\nexport async function grantCredits(input: {\n  userId: string;\n  credits: number;\n  source: string;\n  stripeEventId?: string | null;\n  stripePriceId?: string | null;\n  stripeCheckoutSessionId?: string | null;\n  stripePaymentIntentId?: string | null;\n}) {\n  const creditsToAdd = Math.max(0, Math.round(Number(input.credits) || 0));\n  if (!creditsToAdd) return { ok: false as const, balance: null as number | null };\n\n  const expiresAt = computeNewExpiry(new Date());\n\n  const result = await prisma.$transaction(async (tx) => {\n    const current = await tx.credits.findUnique({ where: { userId: input.userId } });\n    const currentBalance = current?.balance ?? 0;\n    const nextBalance = currentBalance + creditsToAdd;\n\n    const updated = await tx.credits.upsert({\n      where: { userId: input.userId },\n      update: {\n        balance: nextBalance,\n        // Keep the furthest expiry (simple model; lots are for audit trail).\n        expiresAt: current?.expiresAt && current.expiresAt > expiresAt ? current.expiresAt : expiresAt,\n      },\n      create: {\n        userId: input.userId,\n        balance: nextBalance,\n        expiresAt,\n      },\n    });\n\n    await tx.creditLot.create({\n      data: {\n        userId: input.userId,\n        credits: creditsToAdd,\n        amountCredits: creditsToAdd,\n        remainingCredits: creditsToAdd,\n        source: input.source,\n        stripeEventId: input.stripeEventId || null,\n        stripePriceId: input.stripePriceId || null,\n        stripeCheckoutSessionId: input.stripeCheckoutSessionId || null,\n        stripePaymentIntentId: input.stripePaymentIntentId || null,\n        expiresAt,\n      },\n    });\n\n    return { ok: true as const, balance: updated.balance };\n  });\n\n  return result;\n}\n\n\n","import { prisma } from \"@/lib/db/prisma\";\n\nexport async function deductCreditsFromLots(params: { userId: string; credits: number }) {\n  const creditsToDeduct = Math.max(0, Math.round(Number(params.credits) || 0));\n  if (!creditsToDeduct) return { ok: true as const, remainingBalance: null as number | null };\n\n  return prisma.$transaction(async (tx) => {\n    const userId = params.userId;\n    const creditsRow = await tx.credits.findUnique({ where: { userId } });\n    const balance = creditsRow?.balance ?? 0;\n    if (balance < creditsToDeduct) {\n      return { ok: false as const, remainingBalance: balance };\n    }\n\n    // Prefer earliest expiry first, then oldest purchasedAt.\n    const lots = await tx.creditLot.findMany({\n      where: {\n        userId,\n        OR: [{ remainingCredits: { gt: 0 } }, { remainingCredits: 0, credits: { gt: 0 } }],\n      },\n      orderBy: [{ expiresAt: \"asc\" }, { purchasedAt: \"asc\" }, { createdAt: \"asc\" }],\n      take: 200,\n    });\n\n    let remaining = creditsToDeduct;\n    for (const lot of lots) {\n      if (remaining <= 0) break;\n      const available = Math.max(0, lot.remainingCredits || lot.credits || 0);\n      if (!available) continue;\n      const take = Math.min(available, remaining);\n      remaining -= take;\n      await tx.creditLot.update({\n        where: { id: lot.id },\n        data: {\n          remainingCredits: Math.max(0, available - take),\n          amountCredits: lot.amountCredits && lot.amountCredits > 0 ? lot.amountCredits : lot.credits,\n        },\n      });\n    }\n\n    if (remaining > 0) {\n      return { ok: false as const, remainingBalance: balance };\n    }\n\n    const updated = await tx.credits.update({\n      where: { userId },\n      data: { balance: balance - creditsToDeduct },\n    });\n\n    return { ok: true as const, remainingBalance: updated.balance };\n  });\n}\n\n\n","import { NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth/options\";\nimport { prisma } from \"@/lib/db/prisma\";\nimport { enforceCreditExpiry } from \"@/lib/credits/store\";\n\nexport type CreditGateResult =\n  | {\n      ok: true;\n      userId: string;\n      balance: number;\n      remainingAfter: number;\n    }\n  | {\n      ok: false;\n      status: number;\n      message: string;\n      requiredCredits?: number;\n      currentBalance?: number;\n    };\n\n/**\n * Enforces credit gate for operations requiring server-side computation.\n * \n * This utility:\n * - Validates user is authenticated\n * - Checks current credit balance\n * - Validates sufficient credits (with safety buffer)\n * - Returns standardized error responses\n * \n * @param estimatedCredits - Estimated credit cost for the operation\n * @param safetyBuffer - Multiplier for safety buffer (default 1.25 = 25% buffer)\n * @returns CreditGateResult indicating if operation can proceed\n */\nexport async function enforceCreditGate(\n  estimatedCredits: number,\n  safetyBuffer = 1.25\n): Promise<CreditGateResult> {\n  // Get authenticated user\n  const session = await getServerSession(authOptions);\n  if (!session?.user?.id) {\n    return {\n      ok: false,\n      status: 401,\n      message: \"Authentication required. Please sign in to use this feature.\",\n    };\n  }\n\n  const userId = session.user.id;\n\n  // If no credits required, allow operation\n  if (estimatedCredits <= 0) {\n    return {\n      ok: true,\n      userId,\n      balance: 0,\n      remainingAfter: 0,\n    };\n  }\n\n  // Enforce credit expiry\n  await enforceCreditExpiry(userId);\n\n  // Get current balance\n  const creditsRow = await prisma.credits.findUnique({ where: { userId } });\n  const currentBalance = creditsRow?.balance ?? 0;\n\n  // Check for expired credits\n  if (creditsRow?.expiresAt && creditsRow.expiresAt.getTime() <= Date.now()) {\n    return {\n      ok: false,\n      status: 402,\n      message: \"Your credits have expired. Please purchase more credits to continue.\",\n      requiredCredits: estimatedCredits,\n      currentBalance: 0,\n    };\n  }\n\n  // Calculate required credits with safety buffer\n  const requiredCredits = Math.ceil(estimatedCredits * safetyBuffer);\n\n  // Check if user has sufficient credits\n  if (currentBalance < requiredCredits) {\n    return {\n      ok: false,\n      status: 402,\n      message: `Insufficient credits. This operation requires approximately ${estimatedCredits} credits (${requiredCredits} with safety buffer), but you only have ${currentBalance} credits available.`,\n      requiredCredits,\n      currentBalance,\n    };\n  }\n\n  return {\n    ok: true,\n    userId,\n    balance: currentBalance,\n    remainingAfter: currentBalance - requiredCredits, // Note: actual deduction happens separately\n  };\n}\n\n/**\n * Creates a standardized NextResponse for credit gate failures\n */\nexport function creditGateErrorResponse(result: Extract<CreditGateResult, { ok: false }>): NextResponse {\n  return NextResponse.json(\n    {\n      code: result.status === 401 ? \"UNAUTHORIZED\" : \"INSUFFICIENT_CREDITS\",\n      message: result.message,\n      requiredCredits: result.requiredCredits,\n      currentBalance: result.currentBalance,\n    },\n    { status: result.status }\n  );\n}\n\n","const DEFAULT_VERSION = \"2025.01\";\n\nexport const activeCourseVersionByCourseId: Record<string, string> = {\n  ai: DEFAULT_VERSION,\n  cybersecurity: DEFAULT_VERSION,\n  \"software-architecture\": DEFAULT_VERSION,\n  data: DEFAULT_VERSION,\n  digitalisation: DEFAULT_VERSION,\n};\n\nexport function getActiveCourseVersion(courseId: string) {\n  const v = activeCourseVersionByCourseId[courseId];\n  return typeof v === \"string\" && v.trim() ? v.trim() : DEFAULT_VERSION;\n}\n\n\n","export const ASSESSMENT_ATTEMPT_CREDITS_DEFAULT = 80;\n\nconst byCourseLevel: Record<string, number> = {\n  \"cybersecurity:foundations\": 80,\n  \"cybersecurity:applied\": 80,\n  \"cybersecurity:practice\": 80,\n};\n\nexport function getAssessmentAttemptCredits(params: { courseId: string; levelId: string }): number {\n  const key = `${params.courseId}:${params.levelId}`;\n  const v = byCourseLevel[key];\n  const n = typeof v === \"number\" ? v : ASSESSMENT_ATTEMPT_CREDITS_DEFAULT;\n  return Math.max(0, Math.round(n));\n}\n\n","import crypto from \"crypto\";\n\nexport const CPD_RULES_VERSION = \"v1\";\n\nexport function minutesToHours(minutes) {\n  const m = Number(minutes) || 0;\n  return Math.round((m / 60) * 10) / 10;\n}\n\nexport function hoursToMinutes(hours) {\n  const h = Number(hours) || 0;\n  return Math.max(0, Math.round(h * 60));\n}\n\nexport function validateCpdState(state) {\n  if (!state || typeof state !== \"object\") return { ok: false, error: \"State must be an object\" };\n  if (!Array.isArray(state.sections) || !Array.isArray(state.activity)) {\n    return { ok: false, error: \"State must contain sections and activity arrays\" };\n  }\n  for (const s of state.sections) {\n    if (!s.trackId || !s.levelId || !s.sectionId) return { ok: false, error: \"Section missing identifiers\" };\n    if (Number(s.minutes) < 0) return { ok: false, error: \"Section minutes must be non-negative\" };\n  }\n  for (const a of state.activity) {\n    if (!a.id || !a.trackId || !a.levelId || !a.sectionId || !a.timestamp) return { ok: false, error: \"Activity missing fields\" };\n    if (!Number.isFinite(Number(a.minutesDelta))) return { ok: false, error: \"Activity minutesDelta must be numeric\" };\n  }\n  return { ok: true };\n}\n\nexport function buildEvidenceRecord(input) {\n  const payload = {\n    ...input,\n    rulesVersion: CPD_RULES_VERSION,\n  };\n  const canonical = JSON.stringify(payload);\n  const hash = crypto.createHash(\"sha256\").update(canonical).digest(\"hex\");\n  return { ...payload, hash };\n}\n\nexport function explainCredits(state, trackId) {\n  const activity = (state?.activity || []).filter((a) => a.trackId === trackId);\n  const totalMinutesFromActivity = activity.reduce((sum, a) => sum + (Number(a.minutesDelta) || 0), 0);\n  return {\n    trackId,\n    totalMinutesFromActivity,\n    totalHoursFromActivity: minutesToHours(totalMinutesFromActivity),\n    recent: activity.slice(0, 50).map((a) => ({\n      id: a.id,\n      timestamp: a.timestamp,\n      minutesDelta: a.minutesDelta,\n      note: a.note || \"\",\n      levelId: a.levelId,\n      sectionId: a.sectionId,\n    })),\n  };\n}\n\n\n","import type { CPDActivity, CPDState, CPDTrackId } from \"@/lib/cpd\";\nimport { CPD_RULES_VERSION, buildEvidenceRecord } from \"@/lib/cpd/calculations.core\";\n\nexport type EvidenceSource = \"reading\" | \"tool\" | \"quiz\" | \"manual\";\n\nexport type EvidenceRecord = {\n  id: string;\n  timestamp: string;\n  source: EvidenceSource;\n  trackId: CPDTrackId;\n  levelId: string;\n  sectionId: string;\n  minutesDelta: number;\n  note?: string;\n  rulesVersion: string;\n  hash: string;\n};\n\nexport function evidenceFromActivity(entry: CPDActivity, source: EvidenceSource = \"manual\"): EvidenceRecord {\n  const record = buildEvidenceRecord({\n    id: String(entry.id),\n    timestamp: String(entry.timestamp),\n    source,\n    trackId: entry.trackId,\n    levelId: entry.levelId,\n    sectionId: entry.sectionId,\n    minutesDelta: Number(entry.minutesDelta) || 0,\n    note: entry.note || \"\",\n  });\n  return record as EvidenceRecord;\n}\n\nexport function buildEvidenceRecords(state: CPDState, source: EvidenceSource = \"manual\"): EvidenceRecord[] {\n  return (state.activity || []).map((a) => evidenceFromActivity(a, source));\n}\n\nexport function getEvidenceRulesVersion(): string {\n  return CPD_RULES_VERSION;\n}\n\n\n","export { evidenceFromActivity, buildEvidenceRecords, getEvidenceRulesVersion } from \"@/lib/cpd/evidence.core\";\nexport type { EvidenceRecord, EvidenceSource } from \"@/lib/cpd/evidence.core\";\n\nimport { prisma } from \"@/lib/db/prisma\";\n\nexport type EvidenceType = \"progress\" | \"quiz\" | \"tool\" | \"manual\";\n\nexport type RequestMeta = {\n  ip?: string | null;\n  userAgent?: string | null;\n};\n\nfunction safeJsonValue(value: any, depth = 0): any {\n  if (depth > 4) return null;\n  if (value === null) return null;\n  if (value === undefined) return null;\n  if (typeof value === \"string\") {\n    // Avoid storing secrets/tokens. Basic heuristic only.\n    const s = value.length > 2_000 ? value.slice(0, 2_000) : value;\n    const lower = s.toLowerCase();\n    if (lower.includes(\"sk_\") || lower.includes(\"whsec_\") || lower.includes(\"bearer \")) return \"[redacted]\";\n    return s;\n  }\n  if (typeof value === \"number\") return Number.isFinite(value) ? value : 0;\n  if (typeof value === \"boolean\") return value;\n  if (Array.isArray(value)) return value.slice(0, 50).map((v) => safeJsonValue(v, depth + 1));\n  if (typeof value === \"object\") {\n    const out: Record<string, any> = {};\n    const keys = Object.keys(value).slice(0, 50);\n    for (const k of keys) out[k] = safeJsonValue((value as any)[k], depth + 1);\n    return out;\n  }\n  return null;\n}\n\nexport async function recordEvidence(params: {\n  userId: string;\n  courseId: string;\n  evidenceType: EvidenceType;\n  payload: any;\n  requestMeta?: RequestMeta;\n}) {\n  const userId = String(params.userId || \"\").trim();\n  const courseId = String(params.courseId || \"\").trim();\n  const evidenceType = params.evidenceType;\n  const payload = safeJsonValue(params.payload);\n\n  const ip = params.requestMeta?.ip ? String(params.requestMeta.ip).slice(0, 128) : null;\n  const userAgent = params.requestMeta?.userAgent ? String(params.requestMeta.userAgent).slice(0, 256) : null;\n\n  const evidence = (prisma as any).courseCompletionEvidence as {\n    create: (args: any) => Promise<any>;\n  };\n  const audit = (prisma as any).auditEvent as {\n    create: (args: any) => Promise<any>;\n  };\n\n  const created = await evidence.create({\n    data: {\n      userId,\n      courseId,\n      evidenceType,\n      payload,\n    },\n  });\n\n  await audit.create({\n    data: {\n      actorUserId: userId,\n      action: \"EVIDENCE_RECORDED\",\n      entityType: \"evidence\",\n      entityId: created.id,\n      details: { courseId, evidenceType },\n      ip,\n      userAgent,\n    },\n  });\n\n  return created;\n}\n\n\n"],"names":[],"mappings":"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"}}]
}