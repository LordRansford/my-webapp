{
  "version": 3,
  "sources": [],
  "debugId": "7eac769f-8a70-9536-b0ec-a1d249554db9",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../src/lib/security/rateLimit.ts","../../../src/lib/security/origin.ts","../../../src/lib/security/requestLog.ts","../../../src/lib/credits/store.ts","../../../src/lib/credits/deductFromLots.ts","../../../src/lib/credits/enforceCreditGate.ts","../../../src/lib/credits/deductCredits.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport crypto from \"crypto\";\n\ntype Options = {\n  keyPrefix: string;\n  limit: number;\n  windowMs: number;\n  keySuffix?: string;\n  message?: string;\n};\n\ntype Entry = { count: number; resetAt: number };\n\nconst buckets = new Map<string, Entry>();\n\nfunction hash(value: string) {\n  return crypto.createHash(\"sha256\").update(value).digest(\"hex\").slice(0, 24);\n}\n\nfunction getClientKey(req: Request, keySuffix?: string) {\n  // Privacy: we do not persist IPs; we only keep a short-lived hash in memory.\n  const forwarded = req.headers.get(\"x-forwarded-for\") || \"\";\n  const ip = forwarded.split(\",\")[0]?.trim() || req.headers.get(\"x-real-ip\") || \"unknown\";\n  const ua = req.headers.get(\"user-agent\") || \"unknown\";\n  return hash(`${ip}|${ua}|${keySuffix || \"\"}`);\n}\n\nexport function rateLimit(req: Request, opts: Options) {\n  const now = Date.now();\n  const key = `${opts.keyPrefix}:${getClientKey(req, opts.keySuffix)}`;\n  const existing = buckets.get(key);\n  if (!existing || existing.resetAt <= now) {\n    buckets.set(key, { count: 1, resetAt: now + opts.windowMs });\n    return null;\n  }\n  existing.count += 1;\n  if (existing.count > opts.limit) {\n    const retryAfter = Math.max(1, Math.ceil((existing.resetAt - now) / 1000));\n    return NextResponse.json(\n      { error: opts.message || \"Too many requests. Please try again shortly.\" },\n      { status: 429, headers: { \"retry-after\": String(retryAfter) } }\n    );\n  }\n  return null;\n}\n\n\n","import { NextResponse } from \"next/server\";\n\nfunction getSiteOrigin() {\n  try {\n    return new URL(process.env.NEXT_PUBLIC_SITE_URL || \"http://localhost:3000\").origin;\n  } catch {\n    return \"http://localhost:3000\";\n  }\n}\n\nexport function requireSameOrigin(req: Request) {\n  // Lightweight CSRF protection for browser-invoked state changes:\n  // require Origin/Referer to match our configured site origin.\n  const origin = req.headers.get(\"origin\");\n  const referer = req.headers.get(\"referer\");\n  const siteOrigin = getSiteOrigin();\n  let requestOrigin: string | null = null;\n  try {\n    requestOrigin = new URL(req.url).origin;\n  } catch {\n    requestOrigin = null;\n  }\n\n  const candidate = origin || (referer ? (() => { try { return new URL(referer).origin; } catch { return null; } })() : null);\n  // Some same-site requests may not include Origin or Referer.\n  // For CSRF prevention we only need to reject cross-site browser requests, which do send Origin.\n  // If the request has no Origin/Referer we allow it when the request origin is known.\n  if (!candidate) {\n    if (requestOrigin) return null;\n    return NextResponse.json({ error: \"Missing origin\" }, { status: 403 });\n  }\n  // Accept either:\n  // - the configured canonical site origin (e.g. production custom domain), or\n  // - the request origin (e.g. Vercel preview domain), as long as the browser supplies Origin/Referer.\n  if (candidate !== siteOrigin && (!requestOrigin || candidate !== requestOrigin)) {\n    return NextResponse.json({ error: \"Invalid origin\" }, { status: 403 });\n  }\n  return null;\n}\n\n\n","import crypto from \"crypto\";\n\nexport function getRequestId(req: Request) {\n  return req.headers.get(\"x-request-id\") || crypto.randomUUID();\n}\n\nexport async function withRequestLogging<T>(\n  req: Request,\n  meta: { route: string },\n  fn: (ctx: { requestId: string }) => Promise<T>\n) {\n  const requestId = getRequestId(req);\n  const start = Date.now();\n  try {\n    const result = await fn({ requestId });\n    const durationMs = Date.now() - start;\n    console.info(\"req\", { requestId, route: meta.route, status: \"ok\", durationMs });\n    return result;\n  } catch (err: any) {\n    const durationMs = Date.now() - start;\n    console.error(\"req\", { requestId, route: meta.route, status: \"error\", durationMs, message: err?.message || \"error\" });\n    throw err;\n  }\n}\n\n\n","import { prisma } from \"@/lib/db/prisma\";\n\nconst DEFAULT_CREDIT_EXPIRY_DAYS = 365 * 2; // 24 months (recommended default)\nconst CREDIT_EXPIRY_DAYS = (() => {\n  const raw = process.env.CREDITS_EXPIRY_DAYS;\n  const n = raw ? Number(raw) : NaN;\n  return Number.isFinite(n) && n > 0 ? Math.floor(n) : DEFAULT_CREDIT_EXPIRY_DAYS;\n})();\n\nfunction addDays(date: Date, days: number) {\n  const d = new Date(date);\n  d.setDate(d.getDate() + days);\n  return d;\n}\n\nexport async function getOrCreateCredits(userId: string) {\n  const existing = await prisma.credits.findUnique({ where: { userId } });\n  if (existing) return existing;\n  return await prisma.credits.create({ data: { userId, balance: 0, expiresAt: null } });\n}\n\nexport async function getCreditsAggregate() {\n  const totalUsersWithCredits = await prisma.credits.count();\n  const sum = await prisma.credits.aggregate({ _sum: { balance: true } });\n  return {\n    totalUsersWithCredits,\n    totalCredits: sum._sum.balance ?? 0,\n  };\n}\n\nexport async function enforceCreditExpiry(userId: string) {\n  const credits = await prisma.credits.findUnique({ where: { userId } });\n  if (!credits) return null;\n  if (!credits.expiresAt) return credits;\n  const now = new Date();\n  if (credits.expiresAt.getTime() > now.getTime()) return credits;\n  // Expired: reset to zero but keep record.\n  return await prisma.credits.update({ where: { userId }, data: { balance: 0 } });\n}\n\nexport async function createCreditUsageEvent(input: {\n  userId: string;\n  toolId: string;\n  consumed: number;\n  units: number;\n  freeUnits: number;\n  paidUnits: number;\n  runId?: string | null;\n  baseFree?: boolean;\n  estimatedCredits?: number;\n  actualCredits?: number;\n  meteringUnit?: string;\n  durationMs?: number;\n  inputBytes?: number;\n  outputBytes?: number;\n  freeTierAppliedMs?: number;\n  paidMs?: number;\n}) {\n  return prisma.creditUsageEvent.create({\n    data: {\n      userId: input.userId,\n      toolId: input.toolId,\n      consumed: input.consumed,\n      units: input.units,\n      freeUnits: input.freeUnits,\n      paidUnits: input.paidUnits,\n      runId: input.runId || null,\n      baseFree: Boolean(input.baseFree),\n      estimatedCredits: Math.max(0, Math.round(Number(input.estimatedCredits) || 0)),\n      actualCredits: Math.max(0, Math.round(Number(input.actualCredits) || 0)),\n      meteringUnit: input.meteringUnit || \"ms\",\n      durationMs: Math.max(0, Math.round(Number(input.durationMs) || 0)),\n      inputBytes: Math.max(0, Math.round(Number(input.inputBytes) || 0)),\n      outputBytes: Math.max(0, Math.round(Number(input.outputBytes) || 0)),\n      freeTierAppliedMs: Math.max(0, Math.round(Number(input.freeTierAppliedMs) || 0)),\n      paidMs: Math.max(0, Math.round(Number(input.paidMs) || 0)),\n    },\n  });\n}\n\nexport async function listCreditUsage(userId: string, limit = 50) {\n  return prisma.creditUsageEvent.findMany({\n    where: { userId },\n    orderBy: { occurredAt: \"desc\" },\n    take: Math.max(1, Math.min(200, limit)),\n  });\n}\n\nexport function computeNewExpiry(from = new Date()) {\n  return addDays(from, CREDIT_EXPIRY_DAYS);\n}\n\nexport async function createCreditLot(input: {\n  userId: string;\n  credits: number;\n  source: string;\n  stripeEventId?: string | null;\n  stripePriceId?: string | null;\n  stripeCheckoutSessionId?: string | null;\n  stripePaymentIntentId?: string | null;\n  expiresAt?: Date | null;\n}) {\n  const credits = Math.max(0, Math.round(Number(input.credits) || 0));\n  return prisma.creditLot.create({\n    data: {\n      userId: input.userId,\n      credits,\n      amountCredits: credits,\n      remainingCredits: credits,\n      source: input.source,\n      stripeEventId: input.stripeEventId || null,\n      stripePriceId: input.stripePriceId || null,\n      stripeCheckoutSessionId: input.stripeCheckoutSessionId || null,\n      stripePaymentIntentId: input.stripePaymentIntentId || null,\n      expiresAt: input.expiresAt || null,\n    },\n  });\n}\n\nexport async function grantCredits(input: {\n  userId: string;\n  credits: number;\n  source: string;\n  stripeEventId?: string | null;\n  stripePriceId?: string | null;\n  stripeCheckoutSessionId?: string | null;\n  stripePaymentIntentId?: string | null;\n}) {\n  const creditsToAdd = Math.max(0, Math.round(Number(input.credits) || 0));\n  if (!creditsToAdd) return { ok: false as const, balance: null as number | null };\n\n  const expiresAt = computeNewExpiry(new Date());\n\n  const result = await prisma.$transaction(async (tx) => {\n    const current = await tx.credits.findUnique({ where: { userId: input.userId } });\n    const currentBalance = current?.balance ?? 0;\n    const nextBalance = currentBalance + creditsToAdd;\n\n    const updated = await tx.credits.upsert({\n      where: { userId: input.userId },\n      update: {\n        balance: nextBalance,\n        // Keep the furthest expiry (simple model; lots are for audit trail).\n        expiresAt: current?.expiresAt && current.expiresAt > expiresAt ? current.expiresAt : expiresAt,\n      },\n      create: {\n        userId: input.userId,\n        balance: nextBalance,\n        expiresAt,\n      },\n    });\n\n    await tx.creditLot.create({\n      data: {\n        userId: input.userId,\n        credits: creditsToAdd,\n        amountCredits: creditsToAdd,\n        remainingCredits: creditsToAdd,\n        source: input.source,\n        stripeEventId: input.stripeEventId || null,\n        stripePriceId: input.stripePriceId || null,\n        stripeCheckoutSessionId: input.stripeCheckoutSessionId || null,\n        stripePaymentIntentId: input.stripePaymentIntentId || null,\n        expiresAt,\n      },\n    });\n\n    return { ok: true as const, balance: updated.balance };\n  });\n\n  return result;\n}\n\n\n","import { prisma } from \"@/lib/db/prisma\";\n\nexport async function deductCreditsFromLots(params: { userId: string; credits: number }) {\n  const creditsToDeduct = Math.max(0, Math.round(Number(params.credits) || 0));\n  if (!creditsToDeduct) return { ok: true as const, remainingBalance: null as number | null };\n\n  return prisma.$transaction(async (tx) => {\n    const userId = params.userId;\n    const creditsRow = await tx.credits.findUnique({ where: { userId } });\n    const balance = creditsRow?.balance ?? 0;\n    if (balance < creditsToDeduct) {\n      return { ok: false as const, remainingBalance: balance };\n    }\n\n    // Prefer earliest expiry first, then oldest purchasedAt.\n    const lots = await tx.creditLot.findMany({\n      where: {\n        userId,\n        OR: [{ remainingCredits: { gt: 0 } }, { remainingCredits: 0, credits: { gt: 0 } }],\n      },\n      orderBy: [{ expiresAt: \"asc\" }, { purchasedAt: \"asc\" }, { createdAt: \"asc\" }],\n      take: 200,\n    });\n\n    let remaining = creditsToDeduct;\n    for (const lot of lots) {\n      if (remaining <= 0) break;\n      const available = Math.max(0, lot.remainingCredits || lot.credits || 0);\n      if (!available) continue;\n      const take = Math.min(available, remaining);\n      remaining -= take;\n      await tx.creditLot.update({\n        where: { id: lot.id },\n        data: {\n          remainingCredits: Math.max(0, available - take),\n          amountCredits: lot.amountCredits && lot.amountCredits > 0 ? lot.amountCredits : lot.credits,\n        },\n      });\n    }\n\n    if (remaining > 0) {\n      return { ok: false as const, remainingBalance: balance };\n    }\n\n    const updated = await tx.credits.update({\n      where: { userId },\n      data: { balance: balance - creditsToDeduct },\n    });\n\n    return { ok: true as const, remainingBalance: updated.balance };\n  });\n}\n\n\n","import { NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth/options\";\nimport { prisma } from \"@/lib/db/prisma\";\nimport { enforceCreditExpiry } from \"@/lib/credits/store\";\n\nexport type CreditGateResult =\n  | {\n      ok: true;\n      userId: string;\n      balance: number;\n      remainingAfter: number;\n    }\n  | {\n      ok: false;\n      status: number;\n      message: string;\n      requiredCredits?: number;\n      currentBalance?: number;\n    };\n\n/**\n * Enforces credit gate for operations requiring server-side computation.\n * \n * This utility:\n * - Validates user is authenticated\n * - Checks current credit balance\n * - Validates sufficient credits (with safety buffer)\n * - Returns standardized error responses\n * \n * @param estimatedCredits - Estimated credit cost for the operation\n * @param safetyBuffer - Multiplier for safety buffer (default 1.25 = 25% buffer)\n * @returns CreditGateResult indicating if operation can proceed\n */\nexport async function enforceCreditGate(\n  estimatedCredits: number,\n  safetyBuffer = 1.25\n): Promise<CreditGateResult> {\n  // Get authenticated user\n  const session = await getServerSession(authOptions);\n  if (!session?.user?.id) {\n    return {\n      ok: false,\n      status: 401,\n      message: \"Authentication required. Please sign in to use this feature.\",\n    };\n  }\n\n  const userId = session.user.id;\n\n  // If no credits required, allow operation\n  if (estimatedCredits <= 0) {\n    return {\n      ok: true,\n      userId,\n      balance: 0,\n      remainingAfter: 0,\n    };\n  }\n\n  // Enforce credit expiry\n  await enforceCreditExpiry(userId);\n\n  // Get current balance\n  const creditsRow = await prisma.credits.findUnique({ where: { userId } });\n  const currentBalance = creditsRow?.balance ?? 0;\n\n  // Check for expired credits\n  if (creditsRow?.expiresAt && creditsRow.expiresAt.getTime() <= Date.now()) {\n    return {\n      ok: false,\n      status: 402,\n      message: \"Your credits have expired. Please purchase more credits to continue.\",\n      requiredCredits: estimatedCredits,\n      currentBalance: 0,\n    };\n  }\n\n  // Calculate required credits with safety buffer\n  const requiredCredits = Math.ceil(estimatedCredits * safetyBuffer);\n\n  // Check if user has sufficient credits\n  if (currentBalance < requiredCredits) {\n    return {\n      ok: false,\n      status: 402,\n      message: `Insufficient credits. This operation requires approximately ${estimatedCredits} credits (${requiredCredits} with safety buffer), but you only have ${currentBalance} credits available.`,\n      requiredCredits,\n      currentBalance,\n    };\n  }\n\n  return {\n    ok: true,\n    userId,\n    balance: currentBalance,\n    remainingAfter: currentBalance - requiredCredits, // Note: actual deduction happens separately\n  };\n}\n\n/**\n * Creates a standardized NextResponse for credit gate failures\n */\nexport function creditGateErrorResponse(result: Extract<CreditGateResult, { ok: false }>): NextResponse {\n  return NextResponse.json(\n    {\n      code: result.status === 401 ? \"UNAUTHORIZED\" : \"INSUFFICIENT_CREDITS\",\n      message: result.message,\n      requiredCredits: result.requiredCredits,\n      currentBalance: result.currentBalance,\n    },\n    { status: result.status }\n  );\n}\n\n","import { deductCreditsFromLots } from \"@/lib/credits/deductFromLots\";\nimport { createCreditUsageEvent } from \"@/lib/credits/store\";\n\n/**\n * Deducts credits after a successful operation.\n * This should be called AFTER the operation completes successfully.\n * \n * @param userId - User ID\n * @param credits - Actual credits to deduct (not estimate)\n * @param toolId - Tool/operation ID (e.g., \"certificate-pdf\", \"template-download\")\n * @param metadata - Optional metadata about the operation\n * @returns Updated balance or error\n */\nexport async function deductCredits(params: {\n  userId: string;\n  credits: number;\n  toolId: string;\n  metadata?: Record<string, any>;\n}): Promise<{ ok: true; remainingBalance: number } | { ok: false; remainingBalance: number | null; error: string }> {\n  const creditsToDeduct = Math.max(0, Math.round(Number(params.credits) || 0));\n  \n  if (creditsToDeduct <= 0) {\n    // No credits to deduct, but still return success\n    return { ok: true, remainingBalance: null as any };\n  }\n\n  try {\n    // Deduct from credit lots\n    const result = await deductCreditsFromLots({\n      userId: params.userId,\n      credits: creditsToDeduct,\n    });\n\n    if (!result.ok) {\n      return {\n        ok: false,\n        remainingBalance: result.remainingBalance,\n        error: \"Insufficient credits for deduction\",\n      };\n    }\n\n    // Create credit usage event\n    await createCreditUsageEvent({\n      userId: params.userId,\n      toolId: params.toolId,\n      consumed: creditsToDeduct,\n      units: creditsToDeduct,\n      freeUnits: 0,\n      paidUnits: creditsToDeduct,\n      baseFree: false,\n      estimatedCredits: creditsToDeduct,\n      actualCredits: creditsToDeduct,\n      meteringUnit: \"fixed\",\n      durationMs: 0,\n      inputBytes: 0,\n      outputBytes: 0,\n      freeTierAppliedMs: 0,\n      paidMs: 0,\n    }).catch(() => null); // Don't fail if event creation fails\n\n    return {\n      ok: true,\n      remainingBalance: result.remainingBalance ?? 0,\n    };\n  } catch (error) {\n    return {\n      ok: false,\n      remainingBalance: null,\n      error: error instanceof Error ? error.message : \"Unknown error during credit deduction\",\n    };\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}