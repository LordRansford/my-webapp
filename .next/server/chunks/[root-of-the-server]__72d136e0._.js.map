{
  "version": 3,
  "sources": [],
  "debugId": "741d3519-6b2f-cf81-1e38-0040a9f4f2e8",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../src/lib/audit/creditAudit.ts","../../../src/lib/billing/creditStore.ts"],"sourcesContent":["/**\n * Credit System Audit Logging\n * \n * Logs all credit-related events for compliance and monitoring.\n */\n\nimport fs from \"fs\";\nimport path from \"path\";\n\nconst AUDIT_LOG_DIR = path.join(process.cwd(), \"data\", \"audit\");\nconst CREDIT_AUDIT_LOG = path.join(AUDIT_LOG_DIR, \"credits.jsonl\");\n\n// Ensure audit log directory exists\nfunction ensureAuditLogDir() {\n  if (!fs.existsSync(AUDIT_LOG_DIR)) {\n    fs.mkdirSync(AUDIT_LOG_DIR, { recursive: true });\n  }\n}\n\nexport type CreditAuditEventType =\n  | \"credit_estimate_requested\"\n  | \"credit_charged\"\n  | \"credit_refunded\"\n  | \"credit_granted\"\n  | \"credit_purchase_initiated\"\n  | \"credit_purchase_completed\"\n  | \"credit_purchase_failed\"\n  | \"spend_limit_exceeded\"\n  | \"insufficient_credits\"\n  | \"tool_execution_blocked\"\n  | \"tool_execution_allowed\"\n  | \"tool_execution_completed\"\n  | \"tool_execution_failed\";\n\nexport interface CreditAuditEvent {\n  id: string;\n  timestamp: string;\n  type: CreditAuditEventType;\n  userId: string | null;\n  toolId?: string;\n  runId?: string;\n  credits?: number;\n  balance?: number;\n  metadata?: Record<string, unknown>;\n  ip?: string | null;\n  userAgent?: string | null;\n}\n\n/**\n * Log a credit audit event\n */\nexport function logCreditEvent(event: Omit<CreditAuditEvent, \"id\" | \"timestamp\">): void {\n  try {\n    ensureAuditLogDir();\n\n    const auditEvent: CreditAuditEvent = {\n      ...event,\n      id: `${Date.now()}-${Math.random().toString(36).substring(7)}`,\n      timestamp: new Date().toISOString(),\n    };\n\n    // Append to JSONL file\n    const line = JSON.stringify(auditEvent) + \"\\n\";\n    fs.appendFileSync(CREDIT_AUDIT_LOG, line, \"utf-8\");\n  } catch (error) {\n    // Don't throw - audit logging should never break the application\n    console.error(\"Failed to log credit audit event:\", error);\n  }\n}\n\n/**\n * Read audit log entries (for admin viewing)\n */\nexport function readCreditAuditLog(\n  filters?: {\n    userId?: string;\n    type?: CreditAuditEventType;\n    startDate?: Date;\n    endDate?: Date;\n    limit?: number;\n  }\n): CreditAuditEvent[] {\n  try {\n    if (!fs.existsSync(CREDIT_AUDIT_LOG)) {\n      return [];\n    }\n\n    const content = fs.readFileSync(CREDIT_AUDIT_LOG, \"utf-8\");\n    const lines = content.trim().split(\"\\n\").filter(Boolean);\n    const events: CreditAuditEvent[] = lines.map((line) => JSON.parse(line));\n\n    // Apply filters\n    let filtered = events;\n\n    if (filters?.userId) {\n      filtered = filtered.filter((e) => e.userId === filters.userId);\n    }\n\n    if (filters?.type) {\n      filtered = filtered.filter((e) => e.type === filters.type);\n    }\n\n    if (filters?.startDate) {\n      filtered = filtered.filter((e) => new Date(e.timestamp) >= filters.startDate!);\n    }\n\n    if (filters?.endDate) {\n      filtered = filtered.filter((e) => new Date(e.timestamp) <= filters.endDate!);\n    }\n\n    // Sort by timestamp (newest first)\n    filtered.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n\n    // Apply limit\n    if (filters?.limit) {\n      filtered = filtered.slice(0, filters.limit);\n    }\n\n    return filtered;\n  } catch (error) {\n    console.error(\"Failed to read credit audit log:\", error);\n    return [];\n  }\n}\n\n/**\n * Get audit statistics\n */\nexport function getCreditAuditStats(userId?: string): {\n  totalEvents: number;\n  totalCreditsCharged: number;\n  totalCreditsGranted: number;\n  totalCreditsRefunded: number;\n  toolExecutions: number;\n  blockedExecutions: number;\n} {\n  try {\n    const events = readCreditAuditLog({ userId });\n\n    let totalCreditsCharged = 0;\n    let totalCreditsGranted = 0;\n    let totalCreditsRefunded = 0;\n    let toolExecutions = 0;\n    let blockedExecutions = 0;\n\n    events.forEach((event) => {\n      if (event.credits) {\n        if (event.type === \"credit_charged\") {\n          totalCreditsCharged += event.credits;\n        } else if (event.type === \"credit_granted\" || event.type === \"credit_purchase_completed\") {\n          totalCreditsGranted += event.credits;\n        } else if (event.type === \"credit_refunded\") {\n          totalCreditsRefunded += event.credits;\n        }\n      }\n\n      if (event.type === \"tool_execution_completed\" || event.type === \"tool_execution_allowed\") {\n        toolExecutions++;\n      }\n\n      if (event.type === \"tool_execution_blocked\" || event.type === \"spend_limit_exceeded\" || event.type === \"insufficient_credits\") {\n        blockedExecutions++;\n      }\n    });\n\n    return {\n      totalEvents: events.length,\n      totalCreditsCharged,\n      totalCreditsGranted,\n      totalCreditsRefunded,\n      toolExecutions,\n      blockedExecutions,\n    };\n  } catch (error) {\n    console.error(\"Failed to get credit audit stats:\", error);\n    return {\n      totalEvents: 0,\n      totalCreditsCharged: 0,\n      totalCreditsGranted: 0,\n      totalCreditsRefunded: 0,\n      toolExecutions: 0,\n      blockedExecutions: 0,\n    };\n  }\n}\n","/**\n * Credit Balance Store\n * \n * Manages user credit balances, purchases, and consumption.\n * Uses Prisma if available, falls back to file-based storage.\n */\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport crypto from \"crypto\";\nimport { logCreditEvent } from \"@/lib/audit/creditAudit\";\n\nconst CREDITS_FILE = path.join(process.cwd(), \"data\", \"credits.json\");\n\n// Note: This module integrates with the existing Prisma credit store\n// (src/lib/credits/store.ts) when available, falling back to file-based storage\n\ninterface CreditTransaction {\n  id: string;\n  userId: string;\n  type: \"purchase\" | \"consumption\" | \"refund\" | \"monthly_allocation\";\n  amount: number; // Positive for purchase/allocation, negative for consumption\n  toolId?: string;\n  runId?: string;\n  timestamp: string;\n  metadata?: Record<string, unknown>;\n}\n\ninterface UserCredits {\n  userId: string;\n  balance: number;\n  monthlyAllocation: number;\n  dailyCap: number;\n  transactions: CreditTransaction[];\n  lastUpdated: string;\n}\n\ninterface CreditsStore {\n  users: Record<string, UserCredits>;\n}\n\nfunction loadStore(): CreditsStore {\n  try {\n    if (fs.existsSync(CREDITS_FILE)) {\n      const content = fs.readFileSync(CREDITS_FILE, \"utf-8\");\n      return JSON.parse(content);\n    }\n  } catch (error) {\n    console.error(\"Failed to load credits store:\", error);\n  }\n  return { users: {} };\n}\n\nfunction saveStore(store: CreditsStore): void {\n  try {\n    // Ensure directory exists\n    const dir = path.dirname(CREDITS_FILE);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n    fs.writeFileSync(CREDITS_FILE, JSON.stringify(store, null, 2));\n  } catch (error) {\n    console.error(\"Failed to save credits store:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get user's credit balance\n */\nexport async function getCreditBalance(userId: string): Promise<number> {\n  // Try existing Prisma store first\n  try {\n    const { getOrCreateCredits } = await import(\"@/lib/credits/store\");\n    const credits = await getOrCreateCredits(userId);\n    return credits.balance ?? 0;\n  } catch (error) {\n    // Prisma not available, fallback to file-based\n    const store = loadStore();\n    const user = store.users[userId];\n    return user?.balance ?? 0;\n  }\n}\n\n/**\n * Get user's credit account (full details)\n */\nexport function getUserCredits(userId: string): UserCredits | null {\n  const store = loadStore();\n  return store.users[userId] || null;\n}\n\n/**\n * Initialize user credits (first time)\n */\nfunction initializeUserCredits(userId: string, monthlyAllocation: number, dailyCap: number): UserCredits {\n  return {\n    userId,\n    balance: monthlyAllocation, // Start with monthly allocation\n    monthlyAllocation,\n    dailyCap,\n    transactions: [\n      {\n        id: crypto.randomUUID(),\n        userId,\n        type: \"monthly_allocation\",\n        amount: monthlyAllocation,\n        timestamp: new Date().toISOString(),\n      },\n    ],\n    lastUpdated: new Date().toISOString(),\n  };\n}\n\n/**\n * Add credits (purchase or monthly allocation)\n */\nexport function addCredits(\n  userId: string,\n  amount: number,\n  type: \"purchase\" | \"monthly_allocation\" = \"purchase\",\n  metadata?: Record<string, unknown>\n): { success: boolean; newBalance: number; transactionId: string } {\n  const store = loadStore();\n  let user = store.users[userId];\n\n  if (!user) {\n    // Initialize with default values (will be updated by plan)\n    user = initializeUserCredits(userId, 0, 0);\n    store.users[userId] = user;\n  }\n\n  const transaction: CreditTransaction = {\n    id: crypto.randomUUID(),\n    userId,\n    type,\n    amount,\n    timestamp: new Date().toISOString(),\n    metadata,\n  };\n\n  user.balance += amount;\n  user.transactions.push(transaction);\n  user.lastUpdated = new Date().toISOString();\n\n  // Keep only last 1000 transactions per user\n  if (user.transactions.length > 1000) {\n    user.transactions = user.transactions.slice(-1000);\n  }\n\n  saveStore(store);\n\n  // Audit log\n  logCreditEvent({\n    type: type === \"purchase\" ? \"credit_granted\" : \"credit_granted\",\n    userId,\n    credits: amount,\n    balance: user.balance,\n    metadata: { type, ...metadata },\n  });\n\n  return {\n    success: true,\n    newBalance: user.balance,\n    transactionId: transaction.id,\n  };\n}\n\n/**\n * Consume credits (tool execution)\n */\nexport async function consumeCredits(\n  userId: string,\n  amount: number,\n  toolId: string,\n  runId?: string,\n  metadata?: Record<string, unknown>\n): Promise<{ success: boolean; newBalance: number; transactionId: string }> {\n  // Try existing Prisma store first\n  try {\n    const { getOrCreateCredits, createCreditUsageEvent } = await import(\"@/lib/credits/store\");\n    const { prisma } = await import(\"@/lib/db/prisma\");\n    \n    const credits = await getOrCreateCredits(userId);\n    \n    if (credits.balance < amount) {\n      throw new Error(\"Insufficient credits\");\n    }\n\n    const newBalance = credits.balance - amount;\n    await prisma.credits.update({\n      where: { userId },\n      data: { balance: newBalance },\n    });\n\n    await createCreditUsageEvent({\n      userId,\n      toolId,\n      consumed: amount,\n      units: 1,\n      freeUnits: 0,\n      paidUnits: amount,\n      runId: runId || null,\n      actualCredits: amount,\n      estimatedCredits: metadata && typeof metadata === \"object\" && \"estimated\" in metadata ? (metadata.estimated as number) : undefined,\n      durationMs: metadata && typeof metadata === \"object\" && \"usage\" in metadata && metadata.usage && typeof metadata.usage === \"object\" && \"durationMs\" in metadata.usage ? (metadata.usage.durationMs as number) : undefined,\n    });\n\n    return {\n      success: true,\n      newBalance,\n      transactionId: runId || crypto.randomUUID(),\n    };\n  } catch (error) {\n    // Prisma not available or error, fallback to file-based\n    console.warn(\"Prisma credit consumption failed, using file-based:\", error);\n  }\n\n  // Fallback to file-based\n  const store = loadStore();\n  let user = store.users[userId];\n\n  if (!user) {\n    throw new Error(\"User credits not initialized\");\n  }\n\n  if (user.balance < amount) {\n    throw new Error(\"Insufficient credits\");\n  }\n\n  const transaction: CreditTransaction = {\n    id: crypto.randomUUID(),\n    userId,\n    type: \"consumption\",\n    amount: -amount,\n    toolId,\n    runId,\n    timestamp: new Date().toISOString(),\n    metadata,\n  };\n\n      user.balance -= amount;\n      user.transactions.push(transaction);\n      user.lastUpdated = new Date().toISOString();\n\n      saveStore(store);\n\n      // Audit log\n      logCreditEvent({\n        type: \"credit_charged\",\n        userId,\n        toolId,\n        runId,\n        credits: amount,\n        balance: user.balance,\n        metadata,\n      });\n\n      return {\n        success: true,\n        newBalance: user.balance,\n        transactionId: transaction.id,\n      };\n}\n\n/**\n * Refund credits (platform error)\n */\nexport function refundCredits(\n  userId: string,\n  amount: number,\n  originalTransactionId: string,\n  reason: string,\n  metadata?: Record<string, unknown>\n): { success: boolean; newBalance: number; transactionId: string } {\n  const store = loadStore();\n  const user = store.users[userId];\n\n  if (!user) {\n    throw new Error(\"User credits not initialized\");\n  }\n\n  const transaction: CreditTransaction = {\n    id: crypto.randomUUID(),\n    userId,\n    type: \"refund\",\n    amount,\n    timestamp: new Date().toISOString(),\n    metadata: {\n      ...metadata,\n      originalTransactionId,\n      reason,\n    },\n  };\n\n  user.balance += amount;\n  user.transactions.push(transaction);\n  user.lastUpdated = new Date().toISOString();\n\n  saveStore(store);\n\n  return {\n    success: true,\n    newBalance: user.balance,\n    transactionId: transaction.id,\n  };\n}\n\n/**\n * Get daily credits consumed today\n */\nexport async function getDailyCreditsConsumed(userId: string): Promise<number> {\n  // Try existing Prisma store first\n  try {\n    const { prisma } = await import(\"@/lib/db/prisma\");\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    const events = await prisma.creditUsageEvent.findMany({\n      where: {\n        userId,\n        occurredAt: { gte: today },\n      },\n      select: { consumed: true },\n    });\n\n    return events.reduce((sum, e) => sum + (e.consumed || 0), 0);\n  } catch (error) {\n    // Prisma not available, fallback to file-based\n    console.warn(\"Prisma daily credits query failed, using file-based:\", error);\n  }\n\n  // Fallback to file-based\n  const store = loadStore();\n  const user = store.users[userId];\n  if (!user) return 0;\n\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  const todayISO = today.toISOString();\n\n  return user.transactions\n    .filter((t) => {\n      const txDate = new Date(t.timestamp);\n      return txDate >= today && t.type === \"consumption\" && t.amount < 0;\n    })\n    .reduce((sum, t) => sum + Math.abs(t.amount), 0);\n}\n\n/**\n * Get monthly credits consumed this month\n */\nexport async function getMonthlyCreditsConsumed(userId: string): Promise<number> {\n  // Try existing Prisma store first\n  try {\n    const { prisma } = await import(\"@/lib/db/prisma\");\n    const now = new Date();\n    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);\n\n    const events = await prisma.creditUsageEvent.findMany({\n      where: {\n        userId,\n        occurredAt: { gte: monthStart },\n      },\n      select: { consumed: true },\n    });\n\n    return events.reduce((sum, e) => sum + (e.consumed || 0), 0);\n  } catch (error) {\n    // Prisma not available, fallback to file-based\n    console.warn(\"Prisma monthly credits query failed, using file-based:\", error);\n  }\n\n  // Fallback to file-based\n  const store = loadStore();\n  const user = store.users[userId];\n  if (!user) return 0;\n\n  const now = new Date();\n  const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);\n\n  return user.transactions\n    .filter((t) => {\n      const txDate = new Date(t.timestamp);\n      return txDate >= monthStart && t.type === \"consumption\" && t.amount < 0;\n    })\n    .reduce((sum, t) => sum + Math.abs(t.amount), 0);\n}\n\n/**\n * Update user's plan limits (monthly allocation, daily cap)\n */\nexport function updateUserPlanLimits(\n  userId: string,\n  monthlyAllocation: number,\n  dailyCap: number\n): void {\n  const store = loadStore();\n  let user = store.users[userId];\n\n  if (!user) {\n    user = initializeUserCredits(userId, monthlyAllocation, dailyCap);\n    store.users[userId] = user;\n  } else {\n    // If monthly allocation increased, add the difference to balance\n    const allocationDiff = monthlyAllocation - user.monthlyAllocation;\n    if (allocationDiff > 0) {\n      addCredits(userId, allocationDiff, \"monthly_allocation\", {\n        reason: \"Plan upgrade\",\n      });\n    }\n\n    user.monthlyAllocation = monthlyAllocation;\n    user.dailyCap = dailyCap;\n    user.lastUpdated = new Date().toISOString();\n  }\n\n  saveStore(store);\n}\n\n/**\n * Get credit transaction history\n */\nexport function getTransactionHistory(\n  userId: string,\n  limit: number = 100\n): CreditTransaction[] {\n  const store = loadStore();\n  const user = store.users[userId];\n  if (!user) return [];\n\n  return user.transactions\n    .slice(-limit)\n    .reverse(); // Most recent first\n}\n"],"names":[],"mappings":"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"}}]
}