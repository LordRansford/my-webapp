{
  "version": 3,
  "sources": [],
  "debugId": "08d699a7-2a97-de25-bbc5-eab8b603ea1c",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../src/lib/security/rateLimit.ts","../../../src/lib/security/origin.ts","../../../src/lib/security/requestLog.ts","../../../src/lib/credits/store.ts","../../../src/lib/credits/deductFromLots.ts","../../../src/lib/credits/enforceCreditGate.ts","../../../src/lib/cpd/calculations.core.js","../../../src/lib/cpd/calculations.ts","../../../src/lib/storage/certificates.ts","../../../src/lib/cpd/courseVersion.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport crypto from \"crypto\";\n\ntype Options = {\n  keyPrefix: string;\n  limit: number;\n  windowMs: number;\n  keySuffix?: string;\n  message?: string;\n};\n\ntype Entry = { count: number; resetAt: number };\n\nconst buckets = new Map<string, Entry>();\n\nfunction hash(value: string) {\n  return crypto.createHash(\"sha256\").update(value).digest(\"hex\").slice(0, 24);\n}\n\nfunction getClientKey(req: Request, keySuffix?: string) {\n  // Privacy: we do not persist IPs; we only keep a short-lived hash in memory.\n  const forwarded = req.headers.get(\"x-forwarded-for\") || \"\";\n  const ip = forwarded.split(\",\")[0]?.trim() || req.headers.get(\"x-real-ip\") || \"unknown\";\n  const ua = req.headers.get(\"user-agent\") || \"unknown\";\n  return hash(`${ip}|${ua}|${keySuffix || \"\"}`);\n}\n\nexport function rateLimit(req: Request, opts: Options) {\n  const now = Date.now();\n  const key = `${opts.keyPrefix}:${getClientKey(req, opts.keySuffix)}`;\n  const existing = buckets.get(key);\n  if (!existing || existing.resetAt <= now) {\n    buckets.set(key, { count: 1, resetAt: now + opts.windowMs });\n    return null;\n  }\n  existing.count += 1;\n  if (existing.count > opts.limit) {\n    const retryAfter = Math.max(1, Math.ceil((existing.resetAt - now) / 1000));\n    return NextResponse.json(\n      { error: opts.message || \"Too many requests. Please try again shortly.\" },\n      { status: 429, headers: { \"retry-after\": String(retryAfter) } }\n    );\n  }\n  return null;\n}\n\n\n","import { NextResponse } from \"next/server\";\n\nfunction getSiteOrigin() {\n  try {\n    return new URL(process.env.NEXT_PUBLIC_SITE_URL || \"http://localhost:3000\").origin;\n  } catch {\n    return \"http://localhost:3000\";\n  }\n}\n\nexport function requireSameOrigin(req: Request) {\n  // Lightweight CSRF protection for browser-invoked state changes:\n  // require Origin/Referer to match our configured site origin.\n  const origin = req.headers.get(\"origin\");\n  const referer = req.headers.get(\"referer\");\n  const siteOrigin = getSiteOrigin();\n\n  const candidate = origin || (referer ? (() => { try { return new URL(referer).origin; } catch { return null; } })() : null);\n  if (!candidate) {\n    return NextResponse.json({ error: \"Missing origin\" }, { status: 403 });\n  }\n  if (candidate !== siteOrigin) {\n    return NextResponse.json({ error: \"Invalid origin\" }, { status: 403 });\n  }\n  return null;\n}\n\n\n","import crypto from \"crypto\";\n\nexport function getRequestId(req: Request) {\n  return req.headers.get(\"x-request-id\") || crypto.randomUUID();\n}\n\nexport async function withRequestLogging<T>(\n  req: Request,\n  meta: { route: string },\n  fn: (ctx: { requestId: string }) => Promise<T>\n) {\n  const requestId = getRequestId(req);\n  const start = Date.now();\n  try {\n    const result = await fn({ requestId });\n    const durationMs = Date.now() - start;\n    console.info(\"req\", { requestId, route: meta.route, status: \"ok\", durationMs });\n    return result;\n  } catch (err: any) {\n    const durationMs = Date.now() - start;\n    console.error(\"req\", { requestId, route: meta.route, status: \"error\", durationMs, message: err?.message || \"error\" });\n    throw err;\n  }\n}\n\n\n","import { prisma } from \"@/lib/db/prisma\";\n\nconst DEFAULT_CREDIT_EXPIRY_DAYS = 365 * 2; // 24 months (recommended default)\nconst CREDIT_EXPIRY_DAYS = (() => {\n  const raw = process.env.CREDITS_EXPIRY_DAYS;\n  const n = raw ? Number(raw) : NaN;\n  return Number.isFinite(n) && n > 0 ? Math.floor(n) : DEFAULT_CREDIT_EXPIRY_DAYS;\n})();\n\nfunction addDays(date: Date, days: number) {\n  const d = new Date(date);\n  d.setDate(d.getDate() + days);\n  return d;\n}\n\nexport async function getOrCreateCredits(userId: string) {\n  const existing = await prisma.credits.findUnique({ where: { userId } });\n  if (existing) return existing;\n  return await prisma.credits.create({ data: { userId, balance: 0, expiresAt: null } });\n}\n\nexport async function getCreditsAggregate() {\n  const totalUsersWithCredits = await prisma.credits.count();\n  const sum = await prisma.credits.aggregate({ _sum: { balance: true } });\n  return {\n    totalUsersWithCredits,\n    totalCredits: sum._sum.balance ?? 0,\n  };\n}\n\nexport async function enforceCreditExpiry(userId: string) {\n  const credits = await prisma.credits.findUnique({ where: { userId } });\n  if (!credits) return null;\n  if (!credits.expiresAt) return credits;\n  const now = new Date();\n  if (credits.expiresAt.getTime() > now.getTime()) return credits;\n  // Expired: reset to zero but keep record.\n  return await prisma.credits.update({ where: { userId }, data: { balance: 0 } });\n}\n\nexport async function createCreditUsageEvent(input: {\n  userId: string;\n  toolId: string;\n  consumed: number;\n  units: number;\n  freeUnits: number;\n  paidUnits: number;\n  runId?: string | null;\n  baseFree?: boolean;\n  estimatedCredits?: number;\n  actualCredits?: number;\n  meteringUnit?: string;\n  durationMs?: number;\n  inputBytes?: number;\n  outputBytes?: number;\n  freeTierAppliedMs?: number;\n  paidMs?: number;\n}) {\n  return prisma.creditUsageEvent.create({\n    data: {\n      userId: input.userId,\n      toolId: input.toolId,\n      consumed: input.consumed,\n      units: input.units,\n      freeUnits: input.freeUnits,\n      paidUnits: input.paidUnits,\n      runId: input.runId || null,\n      baseFree: Boolean(input.baseFree),\n      estimatedCredits: Math.max(0, Math.round(Number(input.estimatedCredits) || 0)),\n      actualCredits: Math.max(0, Math.round(Number(input.actualCredits) || 0)),\n      meteringUnit: input.meteringUnit || \"ms\",\n      durationMs: Math.max(0, Math.round(Number(input.durationMs) || 0)),\n      inputBytes: Math.max(0, Math.round(Number(input.inputBytes) || 0)),\n      outputBytes: Math.max(0, Math.round(Number(input.outputBytes) || 0)),\n      freeTierAppliedMs: Math.max(0, Math.round(Number(input.freeTierAppliedMs) || 0)),\n      paidMs: Math.max(0, Math.round(Number(input.paidMs) || 0)),\n    },\n  });\n}\n\nexport async function listCreditUsage(userId: string, limit = 50) {\n  return prisma.creditUsageEvent.findMany({\n    where: { userId },\n    orderBy: { occurredAt: \"desc\" },\n    take: Math.max(1, Math.min(200, limit)),\n  });\n}\n\nexport function computeNewExpiry(from = new Date()) {\n  return addDays(from, CREDIT_EXPIRY_DAYS);\n}\n\nexport async function createCreditLot(input: {\n  userId: string;\n  credits: number;\n  source: string;\n  stripeEventId?: string | null;\n  stripePriceId?: string | null;\n  stripeCheckoutSessionId?: string | null;\n  stripePaymentIntentId?: string | null;\n  expiresAt?: Date | null;\n}) {\n  const credits = Math.max(0, Math.round(Number(input.credits) || 0));\n  return prisma.creditLot.create({\n    data: {\n      userId: input.userId,\n      credits,\n      amountCredits: credits,\n      remainingCredits: credits,\n      source: input.source,\n      stripeEventId: input.stripeEventId || null,\n      stripePriceId: input.stripePriceId || null,\n      stripeCheckoutSessionId: input.stripeCheckoutSessionId || null,\n      stripePaymentIntentId: input.stripePaymentIntentId || null,\n      expiresAt: input.expiresAt || null,\n    },\n  });\n}\n\nexport async function grantCredits(input: {\n  userId: string;\n  credits: number;\n  source: string;\n  stripeEventId?: string | null;\n  stripePriceId?: string | null;\n  stripeCheckoutSessionId?: string | null;\n  stripePaymentIntentId?: string | null;\n}) {\n  const creditsToAdd = Math.max(0, Math.round(Number(input.credits) || 0));\n  if (!creditsToAdd) return { ok: false as const, balance: null as number | null };\n\n  const expiresAt = computeNewExpiry(new Date());\n\n  const result = await prisma.$transaction(async (tx) => {\n    const current = await tx.credits.findUnique({ where: { userId: input.userId } });\n    const currentBalance = current?.balance ?? 0;\n    const nextBalance = currentBalance + creditsToAdd;\n\n    const updated = await tx.credits.upsert({\n      where: { userId: input.userId },\n      update: {\n        balance: nextBalance,\n        // Keep the furthest expiry (simple model; lots are for audit trail).\n        expiresAt: current?.expiresAt && current.expiresAt > expiresAt ? current.expiresAt : expiresAt,\n      },\n      create: {\n        userId: input.userId,\n        balance: nextBalance,\n        expiresAt,\n      },\n    });\n\n    await tx.creditLot.create({\n      data: {\n        userId: input.userId,\n        credits: creditsToAdd,\n        amountCredits: creditsToAdd,\n        remainingCredits: creditsToAdd,\n        source: input.source,\n        stripeEventId: input.stripeEventId || null,\n        stripePriceId: input.stripePriceId || null,\n        stripeCheckoutSessionId: input.stripeCheckoutSessionId || null,\n        stripePaymentIntentId: input.stripePaymentIntentId || null,\n        expiresAt,\n      },\n    });\n\n    return { ok: true as const, balance: updated.balance };\n  });\n\n  return result;\n}\n\n\n","import { prisma } from \"@/lib/db/prisma\";\n\nexport async function deductCreditsFromLots(params: { userId: string; credits: number }) {\n  const creditsToDeduct = Math.max(0, Math.round(Number(params.credits) || 0));\n  if (!creditsToDeduct) return { ok: true as const, remainingBalance: null as number | null };\n\n  return prisma.$transaction(async (tx) => {\n    const userId = params.userId;\n    const creditsRow = await tx.credits.findUnique({ where: { userId } });\n    const balance = creditsRow?.balance ?? 0;\n    if (balance < creditsToDeduct) {\n      return { ok: false as const, remainingBalance: balance };\n    }\n\n    // Prefer earliest expiry first, then oldest purchasedAt.\n    const lots = await tx.creditLot.findMany({\n      where: {\n        userId,\n        OR: [{ remainingCredits: { gt: 0 } }, { remainingCredits: 0, credits: { gt: 0 } }],\n      },\n      orderBy: [{ expiresAt: \"asc\" }, { purchasedAt: \"asc\" }, { createdAt: \"asc\" }],\n      take: 200,\n    });\n\n    let remaining = creditsToDeduct;\n    for (const lot of lots) {\n      if (remaining <= 0) break;\n      const available = Math.max(0, lot.remainingCredits || lot.credits || 0);\n      if (!available) continue;\n      const take = Math.min(available, remaining);\n      remaining -= take;\n      await tx.creditLot.update({\n        where: { id: lot.id },\n        data: {\n          remainingCredits: Math.max(0, available - take),\n          amountCredits: lot.amountCredits && lot.amountCredits > 0 ? lot.amountCredits : lot.credits,\n        },\n      });\n    }\n\n    if (remaining > 0) {\n      return { ok: false as const, remainingBalance: balance };\n    }\n\n    const updated = await tx.credits.update({\n      where: { userId },\n      data: { balance: balance - creditsToDeduct },\n    });\n\n    return { ok: true as const, remainingBalance: updated.balance };\n  });\n}\n\n\n","import { NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth/options\";\nimport { prisma } from \"@/lib/db/prisma\";\nimport { enforceCreditExpiry } from \"@/lib/credits/store\";\n\nexport type CreditGateResult =\n  | {\n      ok: true;\n      userId: string;\n      balance: number;\n      remainingAfter: number;\n    }\n  | {\n      ok: false;\n      status: number;\n      message: string;\n      requiredCredits?: number;\n      currentBalance?: number;\n    };\n\n/**\n * Enforces credit gate for operations requiring server-side computation.\n * \n * This utility:\n * - Validates user is authenticated\n * - Checks current credit balance\n * - Validates sufficient credits (with safety buffer)\n * - Returns standardized error responses\n * \n * @param estimatedCredits - Estimated credit cost for the operation\n * @param safetyBuffer - Multiplier for safety buffer (default 1.25 = 25% buffer)\n * @returns CreditGateResult indicating if operation can proceed\n */\nexport async function enforceCreditGate(\n  estimatedCredits: number,\n  safetyBuffer = 1.25\n): Promise<CreditGateResult> {\n  // Get authenticated user\n  const session = await getServerSession(authOptions);\n  if (!session?.user?.id) {\n    return {\n      ok: false,\n      status: 401,\n      message: \"Authentication required. Please sign in to use this feature.\",\n    };\n  }\n\n  const userId = session.user.id;\n\n  // If no credits required, allow operation\n  if (estimatedCredits <= 0) {\n    return {\n      ok: true,\n      userId,\n      balance: 0,\n      remainingAfter: 0,\n    };\n  }\n\n  // Enforce credit expiry\n  await enforceCreditExpiry(userId);\n\n  // Get current balance\n  const creditsRow = await prisma.credits.findUnique({ where: { userId } });\n  const currentBalance = creditsRow?.balance ?? 0;\n\n  // Check for expired credits\n  if (creditsRow?.expiresAt && creditsRow.expiresAt.getTime() <= Date.now()) {\n    return {\n      ok: false,\n      status: 402,\n      message: \"Your credits have expired. Please purchase more credits to continue.\",\n      requiredCredits: estimatedCredits,\n      currentBalance: 0,\n    };\n  }\n\n  // Calculate required credits with safety buffer\n  const requiredCredits = Math.ceil(estimatedCredits * safetyBuffer);\n\n  // Check if user has sufficient credits\n  if (currentBalance < requiredCredits) {\n    return {\n      ok: false,\n      status: 402,\n      message: `Insufficient credits. This operation requires approximately ${estimatedCredits} credits (${requiredCredits} with safety buffer), but you only have ${currentBalance} credits available.`,\n      requiredCredits,\n      currentBalance,\n    };\n  }\n\n  return {\n    ok: true,\n    userId,\n    balance: currentBalance,\n    remainingAfter: currentBalance - requiredCredits, // Note: actual deduction happens separately\n  };\n}\n\n/**\n * Creates a standardized NextResponse for credit gate failures\n */\nexport function creditGateErrorResponse(result: Extract<CreditGateResult, { ok: false }>): NextResponse {\n  return NextResponse.json(\n    {\n      code: result.status === 401 ? \"UNAUTHORIZED\" : \"INSUFFICIENT_CREDITS\",\n      message: result.message,\n      requiredCredits: result.requiredCredits,\n      currentBalance: result.currentBalance,\n    },\n    { status: result.status }\n  );\n}\n\n","import crypto from \"crypto\";\n\nexport const CPD_RULES_VERSION = \"v1\";\n\nexport function minutesToHours(minutes) {\n  const m = Number(minutes) || 0;\n  return Math.round((m / 60) * 10) / 10;\n}\n\nexport function hoursToMinutes(hours) {\n  const h = Number(hours) || 0;\n  return Math.max(0, Math.round(h * 60));\n}\n\nexport function validateCpdState(state) {\n  if (!state || typeof state !== \"object\") return { ok: false, error: \"State must be an object\" };\n  if (!Array.isArray(state.sections) || !Array.isArray(state.activity)) {\n    return { ok: false, error: \"State must contain sections and activity arrays\" };\n  }\n  for (const s of state.sections) {\n    if (!s.trackId || !s.levelId || !s.sectionId) return { ok: false, error: \"Section missing identifiers\" };\n    if (Number(s.minutes) < 0) return { ok: false, error: \"Section minutes must be non-negative\" };\n  }\n  for (const a of state.activity) {\n    if (!a.id || !a.trackId || !a.levelId || !a.sectionId || !a.timestamp) return { ok: false, error: \"Activity missing fields\" };\n    if (!Number.isFinite(Number(a.minutesDelta))) return { ok: false, error: \"Activity minutesDelta must be numeric\" };\n  }\n  return { ok: true };\n}\n\nexport function buildEvidenceRecord(input) {\n  const payload = {\n    ...input,\n    rulesVersion: CPD_RULES_VERSION,\n  };\n  const canonical = JSON.stringify(payload);\n  const hash = crypto.createHash(\"sha256\").update(canonical).digest(\"hex\");\n  return { ...payload, hash };\n}\n\nexport function explainCredits(state, trackId) {\n  const activity = (state?.activity || []).filter((a) => a.trackId === trackId);\n  const totalMinutesFromActivity = activity.reduce((sum, a) => sum + (Number(a.minutesDelta) || 0), 0);\n  return {\n    trackId,\n    totalMinutesFromActivity,\n    totalHoursFromActivity: minutesToHours(totalMinutesFromActivity),\n    recent: activity.slice(0, 50).map((a) => ({\n      id: a.id,\n      timestamp: a.timestamp,\n      minutesDelta: a.minutesDelta,\n      note: a.note || \"\",\n      levelId: a.levelId,\n      sectionId: a.sectionId,\n    })),\n  };\n}\n\n\n","import type { CPDState, CPDTrackId } from \"@/lib/cpd\";\nimport {\n  CPD_RULES_VERSION,\n  minutesToHours,\n  hoursToMinutes,\n  validateCpdState,\n  explainCredits,\n} from \"@/lib/cpd/calculations.core\";\n\nexport { CPD_RULES_VERSION, minutesToHours, hoursToMinutes };\n\nexport type CpdValidationResult = { ok: true } | { ok: false; error: string };\n\nexport function validateCpdStateOrThrow(state: CPDState): void {\n  const result = validateCpdState(state) as CpdValidationResult;\n  if (!result.ok) throw new Error(result.error);\n}\n\nexport type CpdCreditExplanation = ReturnType<typeof explainCredits>;\n\nexport function explainTrackCredits(state: CPDState, trackId: CPDTrackId): CpdCreditExplanation {\n  return explainCredits(state as any, trackId);\n}\n\n\n","import fs from \"node:fs\";\nimport path from \"node:path\";\n\ntype PutParams = { key: string; bytes: Uint8Array; contentType: string };\ntype GetUrlParams = { key: string; expiresInSeconds: number };\n\nconst BLOB_BASE = \"https://blob.vercel-storage.com\";\n\nfunction getLocalDir() {\n  return path.join(process.cwd(), \"prisma\", \"data\", \"certificates\");\n}\n\nfunction requireKey(key: string) {\n  const k = String(key || \"\").trim();\n  if (!k || k.includes(\"..\")) throw new Error(\"Invalid storage key\");\n  return k.replace(/^\\//, \"\");\n}\n\nexport async function putCertificatePdf(params: PutParams): Promise<{ key: string }> {\n  const key = requireKey(params.key);\n  const token = process.env.BLOB_READ_WRITE_TOKEN || \"\";\n\n  if (token) {\n    // Private upload to Vercel Blob via simple HTTP API.\n    const url = `${BLOB_BASE}/${encodeURIComponent(key)}`;\n    const res = await fetch(url, {\n      method: \"PUT\",\n      headers: {\n        authorization: `Bearer ${token}`,\n        \"content-type\": params.contentType,\n        // default access is private\n      },\n      body: params.bytes as any,\n    });\n    if (!res.ok) throw new Error(\"CERT_STORAGE_PUT_FAILED\");\n    return { key };\n  }\n\n  // Local dev fallback: store on disk.\n  const dir = getLocalDir();\n  fs.mkdirSync(dir, { recursive: true });\n  fs.writeFileSync(path.join(dir, key), Buffer.from(params.bytes));\n  return { key };\n}\n\nexport async function getCertificatePdfUrl(params: GetUrlParams): Promise<{ url: string }> {\n  const key = requireKey(params.key);\n  const token = process.env.BLOB_READ_WRITE_TOKEN || \"\";\n\n  if (token) {\n    // We do not rely on signed URLs here; instead, download is mediated by our API endpoint.\n    // Return a stable internal URL (expires is handled by our auth gate, not the blob).\n    return { url: `/api/certificates/download?key=${encodeURIComponent(key)}` };\n  }\n\n  return { url: `/api/certificates/download?key=${encodeURIComponent(key)}` };\n}\n\nexport async function getCertificatePdfBytes(params: { key: string }): Promise<Uint8Array> {\n  const key = requireKey(params.key);\n  const token = process.env.BLOB_READ_WRITE_TOKEN || \"\";\n\n  if (token) {\n    const url = `${BLOB_BASE}/${encodeURIComponent(key)}`;\n    const res = await fetch(url, { headers: { authorization: `Bearer ${token}` } });\n    if (!res.ok) throw new Error(\"CERT_STORAGE_GET_FAILED\");\n    const ab = await res.arrayBuffer();\n    return new Uint8Array(ab);\n  }\n\n  const p = path.join(getLocalDir(), key);\n  if (!fs.existsSync(p)) throw new Error(\"CERT_STORAGE_NOT_FOUND\");\n  return new Uint8Array(fs.readFileSync(p));\n}\n\n\n","const DEFAULT_VERSION = \"2025.01\";\n\nexport const activeCourseVersionByCourseId: Record<string, string> = {\n  ai: DEFAULT_VERSION,\n  cybersecurity: DEFAULT_VERSION,\n  \"software-architecture\": DEFAULT_VERSION,\n  data: DEFAULT_VERSION,\n  digitalisation: DEFAULT_VERSION,\n};\n\nexport function getActiveCourseVersion(courseId: string) {\n  const v = activeCourseVersionByCourseId[courseId];\n  return typeof v === \"string\" && v.trim() ? v.trim() : DEFAULT_VERSION;\n}\n\n\n"],"names":[],"mappings":"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"}}]
}