{
  "version": 3,
  "sources": [],
  "debugId": "23d4e0c6-4af9-b4ed-38f2-0bb78b91508b",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../src/lib/credits/store.ts","../../../src/lib/credits/deductFromLots.ts","../../../src/lib/credits/deductCredits.ts"],"sourcesContent":["import { prisma } from \"@/lib/db/prisma\";\n\nconst DEFAULT_CREDIT_EXPIRY_DAYS = 365 * 2; // 24 months (recommended default)\nconst CREDIT_EXPIRY_DAYS = (() => {\n  const raw = process.env.CREDITS_EXPIRY_DAYS;\n  const n = raw ? Number(raw) : NaN;\n  return Number.isFinite(n) && n > 0 ? Math.floor(n) : DEFAULT_CREDIT_EXPIRY_DAYS;\n})();\n\nfunction addDays(date: Date, days: number) {\n  const d = new Date(date);\n  d.setDate(d.getDate() + days);\n  return d;\n}\n\nexport async function getOrCreateCredits(userId: string) {\n  const existing = await prisma.credits.findUnique({ where: { userId } });\n  if (existing) return existing;\n  return await prisma.credits.create({ data: { userId, balance: 0, expiresAt: null } });\n}\n\nexport async function getCreditsAggregate() {\n  const totalUsersWithCredits = await prisma.credits.count();\n  const sum = await prisma.credits.aggregate({ _sum: { balance: true } });\n  return {\n    totalUsersWithCredits,\n    totalCredits: sum._sum.balance ?? 0,\n  };\n}\n\nexport async function enforceCreditExpiry(userId: string) {\n  const credits = await prisma.credits.findUnique({ where: { userId } });\n  if (!credits) return null;\n  if (!credits.expiresAt) return credits;\n  const now = new Date();\n  if (credits.expiresAt.getTime() > now.getTime()) return credits;\n  // Expired: reset to zero but keep record.\n  return await prisma.credits.update({ where: { userId }, data: { balance: 0 } });\n}\n\nexport async function createCreditUsageEvent(input: {\n  userId: string;\n  toolId: string;\n  consumed: number;\n  units: number;\n  freeUnits: number;\n  paidUnits: number;\n  runId?: string | null;\n  baseFree?: boolean;\n  estimatedCredits?: number;\n  actualCredits?: number;\n  meteringUnit?: string;\n  durationMs?: number;\n  inputBytes?: number;\n  outputBytes?: number;\n  freeTierAppliedMs?: number;\n  paidMs?: number;\n}) {\n  return prisma.creditUsageEvent.create({\n    data: {\n      userId: input.userId,\n      toolId: input.toolId,\n      consumed: input.consumed,\n      units: input.units,\n      freeUnits: input.freeUnits,\n      paidUnits: input.paidUnits,\n      runId: input.runId || null,\n      baseFree: Boolean(input.baseFree),\n      estimatedCredits: Math.max(0, Math.round(Number(input.estimatedCredits) || 0)),\n      actualCredits: Math.max(0, Math.round(Number(input.actualCredits) || 0)),\n      meteringUnit: input.meteringUnit || \"ms\",\n      durationMs: Math.max(0, Math.round(Number(input.durationMs) || 0)),\n      inputBytes: Math.max(0, Math.round(Number(input.inputBytes) || 0)),\n      outputBytes: Math.max(0, Math.round(Number(input.outputBytes) || 0)),\n      freeTierAppliedMs: Math.max(0, Math.round(Number(input.freeTierAppliedMs) || 0)),\n      paidMs: Math.max(0, Math.round(Number(input.paidMs) || 0)),\n    },\n  });\n}\n\nexport async function listCreditUsage(userId: string, limit = 50) {\n  return prisma.creditUsageEvent.findMany({\n    where: { userId },\n    orderBy: { occurredAt: \"desc\" },\n    take: Math.max(1, Math.min(200, limit)),\n  });\n}\n\nexport function computeNewExpiry(from = new Date()) {\n  return addDays(from, CREDIT_EXPIRY_DAYS);\n}\n\nexport async function createCreditLot(input: {\n  userId: string;\n  credits: number;\n  source: string;\n  stripeEventId?: string | null;\n  stripePriceId?: string | null;\n  stripeCheckoutSessionId?: string | null;\n  stripePaymentIntentId?: string | null;\n  expiresAt?: Date | null;\n}) {\n  const credits = Math.max(0, Math.round(Number(input.credits) || 0));\n  return prisma.creditLot.create({\n    data: {\n      userId: input.userId,\n      credits,\n      amountCredits: credits,\n      remainingCredits: credits,\n      source: input.source,\n      stripeEventId: input.stripeEventId || null,\n      stripePriceId: input.stripePriceId || null,\n      stripeCheckoutSessionId: input.stripeCheckoutSessionId || null,\n      stripePaymentIntentId: input.stripePaymentIntentId || null,\n      expiresAt: input.expiresAt || null,\n    },\n  });\n}\n\nexport async function grantCredits(input: {\n  userId: string;\n  credits: number;\n  source: string;\n  stripeEventId?: string | null;\n  stripePriceId?: string | null;\n  stripeCheckoutSessionId?: string | null;\n  stripePaymentIntentId?: string | null;\n}) {\n  const creditsToAdd = Math.max(0, Math.round(Number(input.credits) || 0));\n  if (!creditsToAdd) return { ok: false as const, balance: null as number | null };\n\n  const expiresAt = computeNewExpiry(new Date());\n\n  const result = await prisma.$transaction(async (tx) => {\n    const current = await tx.credits.findUnique({ where: { userId: input.userId } });\n    const currentBalance = current?.balance ?? 0;\n    const nextBalance = currentBalance + creditsToAdd;\n\n    const updated = await tx.credits.upsert({\n      where: { userId: input.userId },\n      update: {\n        balance: nextBalance,\n        // Keep the furthest expiry (simple model; lots are for audit trail).\n        expiresAt: current?.expiresAt && current.expiresAt > expiresAt ? current.expiresAt : expiresAt,\n      },\n      create: {\n        userId: input.userId,\n        balance: nextBalance,\n        expiresAt,\n      },\n    });\n\n    await tx.creditLot.create({\n      data: {\n        userId: input.userId,\n        credits: creditsToAdd,\n        amountCredits: creditsToAdd,\n        remainingCredits: creditsToAdd,\n        source: input.source,\n        stripeEventId: input.stripeEventId || null,\n        stripePriceId: input.stripePriceId || null,\n        stripeCheckoutSessionId: input.stripeCheckoutSessionId || null,\n        stripePaymentIntentId: input.stripePaymentIntentId || null,\n        expiresAt,\n      },\n    });\n\n    return { ok: true as const, balance: updated.balance };\n  });\n\n  return result;\n}\n\n\n","import { prisma } from \"@/lib/db/prisma\";\n\nexport async function deductCreditsFromLots(params: { userId: string; credits: number }) {\n  const creditsToDeduct = Math.max(0, Math.round(Number(params.credits) || 0));\n  if (!creditsToDeduct) return { ok: true as const, remainingBalance: null as number | null };\n\n  return prisma.$transaction(async (tx) => {\n    const userId = params.userId;\n    const creditsRow = await tx.credits.findUnique({ where: { userId } });\n    const balance = creditsRow?.balance ?? 0;\n    if (balance < creditsToDeduct) {\n      return { ok: false as const, remainingBalance: balance };\n    }\n\n    // Prefer earliest expiry first, then oldest purchasedAt.\n    const lots = await tx.creditLot.findMany({\n      where: {\n        userId,\n        OR: [{ remainingCredits: { gt: 0 } }, { remainingCredits: 0, credits: { gt: 0 } }],\n      },\n      orderBy: [{ expiresAt: \"asc\" }, { purchasedAt: \"asc\" }, { createdAt: \"asc\" }],\n      take: 200,\n    });\n\n    let remaining = creditsToDeduct;\n    for (const lot of lots) {\n      if (remaining <= 0) break;\n      const available = Math.max(0, lot.remainingCredits || lot.credits || 0);\n      if (!available) continue;\n      const take = Math.min(available, remaining);\n      remaining -= take;\n      await tx.creditLot.update({\n        where: { id: lot.id },\n        data: {\n          remainingCredits: Math.max(0, available - take),\n          amountCredits: lot.amountCredits && lot.amountCredits > 0 ? lot.amountCredits : lot.credits,\n        },\n      });\n    }\n\n    if (remaining > 0) {\n      return { ok: false as const, remainingBalance: balance };\n    }\n\n    const updated = await tx.credits.update({\n      where: { userId },\n      data: { balance: balance - creditsToDeduct },\n    });\n\n    return { ok: true as const, remainingBalance: updated.balance };\n  });\n}\n\n\n","import { deductCreditsFromLots } from \"@/lib/credits/deductFromLots\";\nimport { createCreditUsageEvent } from \"@/lib/credits/store\";\n\n/**\n * Deducts credits after a successful operation.\n * This should be called AFTER the operation completes successfully.\n * \n * @param userId - User ID\n * @param credits - Actual credits to deduct (not estimate)\n * @param toolId - Tool/operation ID (e.g., \"certificate-pdf\", \"template-download\")\n * @param metadata - Optional metadata about the operation\n * @returns Updated balance or error\n */\nexport async function deductCredits(params: {\n  userId: string;\n  credits: number;\n  toolId: string;\n  metadata?: Record<string, any>;\n}): Promise<{ ok: true; remainingBalance: number } | { ok: false; remainingBalance: number | null; error: string }> {\n  const creditsToDeduct = Math.max(0, Math.round(Number(params.credits) || 0));\n  \n  if (creditsToDeduct <= 0) {\n    // No credits to deduct, but still return success\n    return { ok: true, remainingBalance: null as any };\n  }\n\n  try {\n    // Deduct from credit lots\n    const result = await deductCreditsFromLots({\n      userId: params.userId,\n      credits: creditsToDeduct,\n    });\n\n    if (!result.ok) {\n      return {\n        ok: false,\n        remainingBalance: result.remainingBalance,\n        error: \"Insufficient credits for deduction\",\n      };\n    }\n\n    // Create credit usage event\n    await createCreditUsageEvent({\n      userId: params.userId,\n      toolId: params.toolId,\n      consumed: creditsToDeduct,\n      units: creditsToDeduct,\n      freeUnits: 0,\n      paidUnits: creditsToDeduct,\n      baseFree: false,\n      estimatedCredits: creditsToDeduct,\n      actualCredits: creditsToDeduct,\n      meteringUnit: \"fixed\",\n      durationMs: 0,\n      inputBytes: 0,\n      outputBytes: 0,\n      freeTierAppliedMs: 0,\n      paidMs: 0,\n    }).catch(() => null); // Don't fail if event creation fails\n\n    return {\n      ok: true,\n      remainingBalance: result.remainingBalance ?? 0,\n    };\n  } catch (error) {\n    return {\n      ok: false,\n      remainingBalance: null,\n      error: error instanceof Error ? error.message : \"Unknown error during credit deduction\",\n    };\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}