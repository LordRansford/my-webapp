{
  "version": 3,
  "sources": [],
  "debugId": "f61dc5e5-a9a5-0ac2-28cf-69ea0673bb11",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../src/lib/studios/auth-gating.ts","../../../src/server/logger.ts","../../../src/lib/studios/toolMetrics.ts","../../../src/lib/studios/responseCache.ts","../../../src/lib/studios/toolExecutionHelper.ts","../../../src/lib/security/headers.ts","../../../src/lib/studios/circuitBreaker.ts"],"sourcesContent":["/**\n * Account Gating Middleware\n * \n * Enforces authentication requirements for server-side tools and credit purchases.\n * Provides structured error responses with actionable guidance.\n */\n\nimport { NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth/options\";\nimport { getToolDefinition, toolRequiresAuth, isClientSideOnly } from \"@/lib/tools/registry\";\n\nexport interface AuthGateResult {\n  allowed: boolean;\n  userId?: string;\n  reason?: string;\n  action?: string;\n  statusCode?: number;\n}\n\n/**\n * Require authentication for server-side tools\n * \n * Returns error response if:\n * - Tool requires auth and user is not authenticated\n * - Tool is server_required and user is anonymous\n */\nexport async function requireAuthForServerTools(\n  toolId: string\n): Promise<AuthGateResult | NextResponse> {\n  const tool = getToolDefinition(toolId);\n  \n  if (!tool) {\n    return NextResponse.json(\n      {\n        error: \"Tool not found\",\n        code: \"TOOL_NOT_FOUND\",\n        action: \"Check tool ID and try again\",\n      },\n      { status: 404 }\n    );\n  }\n\n  // Client-side only tools don't require auth\n  if (isClientSideOnly(toolId)) {\n    return { allowed: true };\n  }\n\n  // Check if tool requires auth\n  if (toolRequiresAuth(toolId)) {\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.user?.id) {\n      return NextResponse.json(\n        {\n          error: \"Authentication required\",\n          code: \"AUTH_REQUIRED\",\n          reason: \"This tool requires server-side execution, which needs an account\",\n          action: \"Sign in to continue\",\n          signInUrl: \"/api/auth/signin\",\n        },\n        { status: 401 }\n      );\n    }\n\n    return {\n      allowed: true,\n      userId: session.user.id,\n    };\n  }\n\n  // Hybrid tools: auth optional but recommended for save/share\n  return { allowed: true };\n}\n\n/**\n * Deny anonymous users from server-side operations\n * \n * Use this for any server-side API endpoint that should not be accessible\n * to anonymous users, even if the tool itself is hybrid.\n */\nexport async function denyIfAnonymous(\n  operation: string\n): Promise<AuthGateResult | NextResponse> {\n  const session = await getServerSession(authOptions);\n  \n  if (!session?.user?.id) {\n    return NextResponse.json(\n      {\n        error: \"Authentication required\",\n        code: \"AUTH_REQUIRED\",\n        reason: `${operation} requires an account`,\n        action: \"Sign in to continue\",\n        signInUrl: \"/api/auth/signin\",\n      },\n      { status: 401 }\n    );\n  }\n\n  return {\n    allowed: true,\n    userId: session.user.id,\n  };\n}\n\n/**\n * Deny if insufficient credits\n * \n * Checks if user has enough credits for estimated maximum charge.\n * Returns structured error with upgrade/purchase options.\n */\nexport async function denyIfInsufficientCredits(\n  userId: string,\n  estimatedMaxCharge: number,\n  currentBalance: number\n): Promise<AuthGateResult | NextResponse> {\n  if (currentBalance < estimatedMaxCharge) {\n    const shortfall = estimatedMaxCharge - currentBalance;\n    \n    return NextResponse.json(\n      {\n        error: \"Insufficient credits\",\n        code: \"INSUFFICIENT_CREDITS\",\n        reason: `This operation requires ${estimatedMaxCharge} credits, but you have ${currentBalance}`,\n        shortfall,\n        estimatedMaxCharge,\n        currentBalance,\n        action: \"Purchase credits or upgrade your plan\",\n        purchaseUrl: \"/account/credits\",\n        upgradeUrl: \"/account/upgrade\",\n      },\n      { status: 402 } // 402 Payment Required\n    );\n  }\n\n  return { allowed: true, userId };\n}\n\n/**\n * Get user ID from session (helper)\n */\nexport async function getUserIdFromSession(): Promise<string | null> {\n  const session = await getServerSession(authOptions);\n  return session?.user?.id || null;\n}\n\n/**\n * Require authentication (generic)\n * \n * Use this for any endpoint that requires authentication.\n */\nexport async function requireAuth(\n  reason?: string\n): Promise<AuthGateResult | NextResponse> {\n  const session = await getServerSession(authOptions);\n  \n  if (!session?.user?.id) {\n    return NextResponse.json(\n      {\n        error: \"Authentication required\",\n        code: \"AUTH_REQUIRED\",\n        reason: reason || \"This operation requires an account\",\n        action: \"Sign in to continue\",\n        signInUrl: \"/api/auth/signin\",\n      },\n      { status: 401 }\n    );\n  }\n\n  return {\n    allowed: true,\n    userId: session.user.id,\n  };\n}\n","export type LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nexport type LogContext = {\n  requestId?: string;\n  route?: string;\n};\n\ntype LogPayload = Record<string, unknown>;\n\nfunction write(level: LogLevel, event: string, ctx: LogContext, payload?: LogPayload) {\n  const record = {\n    level,\n    event,\n    requestId: ctx.requestId,\n    route: ctx.route,\n    ...payload,\n    ts: new Date().toISOString(),\n  };\n\n  // Keep it simple and server-safe: console.* only.\n  // Never log sensitive data; callers should pass only safe fields.\n  if (level === \"error\") console.error(event, record);\n  else if (level === \"warn\") console.warn(event, record);\n  else console.info(event, record);\n}\n\nexport const logger = {\n  debug: (event: string, ctx: LogContext, payload?: LogPayload) => write(\"debug\", event, ctx, payload),\n  info: (event: string, ctx: LogContext, payload?: LogPayload) => write(\"info\", event, ctx, payload),\n  warn: (event: string, ctx: LogContext, payload?: LogPayload) => write(\"warn\", event, ctx, payload),\n  error: (event: string, ctx: LogContext, payload?: LogPayload) => write(\"error\", event, ctx, payload),\n};\n\n\n","/**\n * Tool Execution Metrics and Monitoring\n * \n * Provides utilities for tracking and analyzing tool execution performance,\n * success rates, and usage patterns.\n */\n\nimport fs from \"fs\";\nimport path from \"path\";\n\nconst METRICS_DIR = path.join(process.cwd(), \"data\", \"metrics\");\nconst TOOL_METRICS_FILE = path.join(METRICS_DIR, \"tool-execution-metrics.jsonl\");\n\ninterface ToolExecutionMetric {\n  id: string;\n  timestamp: string;\n  toolId: string;\n  userId: string;\n  requestId: string;\n  success: boolean;\n  durationMs: number;\n  phaseDurations: Record<string, number>;\n  creditEstimate: number;\n  creditCharged: number;\n  errorType?: string;\n  errorCode?: string;\n  retryCount?: number;\n  timeout?: boolean;\n}\n\nfunction ensureMetricsDir(): void {\n  if (!fs.existsSync(METRICS_DIR)) {\n    fs.mkdirSync(METRICS_DIR, { recursive: true });\n  }\n}\n\n/**\n * Record a tool execution metric\n */\nexport function recordToolMetric(metric: Omit<ToolExecutionMetric, \"id\" | \"timestamp\">): void {\n  try {\n    ensureMetricsDir();\n\n    const fullMetric: ToolExecutionMetric = {\n      ...metric,\n      id: `${Date.now()}-${Math.random().toString(36).substring(7)}`,\n      timestamp: new Date().toISOString(),\n    };\n\n    const line = JSON.stringify(fullMetric) + \"\\n\";\n    fs.appendFileSync(TOOL_METRICS_FILE, line, \"utf-8\");\n  } catch (error) {\n    // Don't throw - metrics should never break the application\n    console.error(\"Failed to record tool metric:\", error);\n  }\n}\n\n/**\n * Get tool performance statistics\n */\nexport function getToolPerformanceStats(\n  toolId?: string,\n  startDate?: Date,\n  endDate?: Date\n): {\n  totalExecutions: number;\n  successfulExecutions: number;\n  failedExecutions: number;\n  averageDurationMs: number;\n  p50DurationMs: number;\n  p95DurationMs: number;\n  p99DurationMs: number;\n  totalCreditsCharged: number;\n  averageCreditsPerExecution: number;\n  errorBreakdown: Record<string, number>;\n  timeoutRate: number;\n  retryRate: number;\n} {\n  try {\n    if (!fs.existsSync(TOOL_METRICS_FILE)) {\n      return getEmptyStats();\n    }\n\n    const content = fs.readFileSync(TOOL_METRICS_FILE, \"utf-8\");\n    const lines = content.trim().split(\"\\n\").filter(Boolean);\n    let metrics: ToolExecutionMetric[] = lines.map((line) => JSON.parse(line));\n\n    // Apply filters\n    if (toolId) {\n      metrics = metrics.filter((m) => m.toolId === toolId);\n    }\n\n    if (startDate) {\n      metrics = metrics.filter((m) => new Date(m.timestamp) >= startDate);\n    }\n\n    if (endDate) {\n      metrics = metrics.filter((m) => new Date(m.timestamp) <= endDate);\n    }\n\n    if (metrics.length === 0) {\n      return getEmptyStats();\n    }\n\n    const durations = metrics.map((m) => m.durationMs).sort((a, b) => a - b);\n    const successful = metrics.filter((m) => m.success);\n    const failed = metrics.filter((m) => !m.success);\n    const timeouts = metrics.filter((m) => m.timeout).length;\n    const retries = metrics.filter((m) => (m.retryCount || 0) > 0).length;\n\n    const errorBreakdown: Record<string, number> = {};\n    failed.forEach((m) => {\n      const errorKey = m.errorCode || m.errorType || \"unknown\";\n      errorBreakdown[errorKey] = (errorBreakdown[errorKey] || 0) + 1;\n    });\n\n    const totalCredits = metrics.reduce((sum, m) => sum + m.creditCharged, 0);\n\n    return {\n      totalExecutions: metrics.length,\n      successfulExecutions: successful.length,\n      failedExecutions: failed.length,\n      averageDurationMs: durations.reduce((a, b) => a + b, 0) / durations.length,\n      p50DurationMs: durations[Math.floor(durations.length * 0.5)] || 0,\n      p95DurationMs: durations[Math.floor(durations.length * 0.95)] || 0,\n      p99DurationMs: durations[Math.floor(durations.length * 0.99)] || 0,\n      totalCreditsCharged: totalCredits,\n      averageCreditsPerExecution: totalCredits / metrics.length,\n      errorBreakdown,\n      timeoutRate: timeouts / metrics.length,\n      retryRate: retries / metrics.length,\n    };\n  } catch (error) {\n    console.error(\"Failed to get tool performance stats:\", error);\n    return getEmptyStats();\n  }\n}\n\nfunction getEmptyStats() {\n  return {\n    totalExecutions: 0,\n    successfulExecutions: 0,\n    failedExecutions: 0,\n    averageDurationMs: 0,\n    p50DurationMs: 0,\n    p95DurationMs: 0,\n    p99DurationMs: 0,\n    totalCreditsCharged: 0,\n    averageCreditsPerExecution: 0,\n    errorBreakdown: {},\n    timeoutRate: 0,\n    retryRate: 0,\n  };\n}\n\n/**\n * Get user tool usage statistics\n */\nexport function getUserToolStats(\n  userId: string,\n  startDate?: Date,\n  endDate?: Date\n): {\n  totalExecutions: number;\n  toolsUsed: string[];\n  totalCreditsSpent: number;\n  averageExecutionTime: number;\n  mostUsedTool: string | null;\n} {\n  try {\n    if (!fs.existsSync(TOOL_METRICS_FILE)) {\n      return {\n        totalExecutions: 0,\n        toolsUsed: [],\n        totalCreditsSpent: 0,\n        averageExecutionTime: 0,\n        mostUsedTool: null,\n      };\n    }\n\n    const content = fs.readFileSync(TOOL_METRICS_FILE, \"utf-8\");\n    const lines = content.trim().split(\"\\n\").filter(Boolean);\n    let metrics: ToolExecutionMetric[] = lines\n      .map((line) => JSON.parse(line))\n      .filter((m) => m.userId === userId);\n\n    if (startDate) {\n      metrics = metrics.filter((m) => new Date(m.timestamp) >= startDate);\n    }\n\n    if (endDate) {\n      metrics = metrics.filter((m) => new Date(m.timestamp) <= endDate);\n    }\n\n    const toolCounts: Record<string, number> = {};\n    let totalCredits = 0;\n    let totalDuration = 0;\n\n    metrics.forEach((m) => {\n      toolCounts[m.toolId] = (toolCounts[m.toolId] || 0) + 1;\n      totalCredits += m.creditCharged;\n      totalDuration += m.durationMs;\n    });\n\n    const toolsUsed = Object.keys(toolCounts);\n    const mostUsedTool =\n      toolsUsed.length > 0\n        ? toolsUsed.reduce((a, b) => (toolCounts[a] > toolCounts[b] ? a : b))\n        : null;\n\n    return {\n      totalExecutions: metrics.length,\n      toolsUsed,\n      totalCreditsSpent: totalCredits,\n      averageExecutionTime: metrics.length > 0 ? totalDuration / metrics.length : 0,\n      mostUsedTool,\n    };\n  } catch (error) {\n    console.error(\"Failed to get user tool stats:\", error);\n    return {\n      totalExecutions: 0,\n      toolsUsed: [],\n      totalCreditsSpent: 0,\n      averageExecutionTime: 0,\n      mostUsedTool: null,\n    };\n  }\n}\n","/**\n * Response Caching Utilities\n * \n * Provides intelligent caching for tool execution results\n * to improve performance and reduce credit costs for repeated queries.\n */\n\nimport crypto from \"crypto\";\n\ninterface CacheEntry<T> {\n  key: string;\n  value: T;\n  expiresAt: number;\n  createdAt: number;\n  hitCount: number;\n}\n\n// In-memory cache (for production, consider Redis or similar)\nconst cache = new Map<string, CacheEntry<unknown>>();\n\n// Cache configuration\nconst DEFAULT_TTL_MS = 5 * 60 * 1000; // 5 minutes\nconst MAX_CACHE_SIZE = 1000; // Maximum number of entries\n\n/**\n * Generate cache key from tool ID and request body\n */\nexport function generateCacheKey(toolId: string, body: any): string {\n  // Create a deterministic key from tool ID and normalized body\n  const normalized = JSON.stringify(body, Object.keys(body || {}).sort());\n  const hash = crypto.createHash(\"sha256\").update(`${toolId}:${normalized}`).digest(\"hex\").slice(0, 16);\n  return `tool:${toolId}:${hash}`;\n}\n\n/**\n * Get cached value if available and not expired\n */\nexport function getCached<T>(key: string): T | null {\n  const entry = cache.get(key) as CacheEntry<T> | undefined;\n  \n  if (!entry) {\n    return null;\n  }\n\n  // Check if expired\n  if (Date.now() > entry.expiresAt) {\n    cache.delete(key);\n    return null;\n  }\n\n  // Update hit count\n  entry.hitCount++;\n  return entry.value;\n}\n\n/**\n * Set cache value with TTL\n */\nexport function setCached<T>(key: string, value: T, ttlMs: number = DEFAULT_TTL_MS): void {\n  // Evict oldest entries if cache is full\n  if (cache.size >= MAX_CACHE_SIZE) {\n    const entries = Array.from(cache.entries());\n    entries.sort((a, b) => a[1].createdAt - b[1].createdAt);\n    // Remove oldest 10% of entries\n    const toRemove = Math.ceil(MAX_CACHE_SIZE * 0.1);\n    for (let i = 0; i < toRemove; i++) {\n      cache.delete(entries[i][0]);\n    }\n  }\n\n  const now = Date.now();\n  cache.set(key, {\n    key,\n    value,\n    expiresAt: now + ttlMs,\n    createdAt: now,\n    hitCount: 0,\n  });\n}\n\n/**\n * Invalidate cache entries for a tool\n */\nexport function invalidateToolCache(toolId: string): void {\n  const prefix = `tool:${toolId}:`;\n  const keysToDelete: string[] = [];\n  \n  cache.forEach((_, key) => {\n    if (key.startsWith(prefix)) {\n      keysToDelete.push(key);\n    }\n  });\n\n  keysToDelete.forEach((key) => cache.delete(key));\n}\n\n/**\n * Clear all cache entries\n */\nexport function clearCache(): void {\n  cache.clear();\n}\n\n/**\n * Get cache statistics\n */\nexport function getCacheStats(): {\n  size: number;\n  maxSize: number;\n  hitRate: number;\n  totalHits: number;\n  totalEntries: number;\n} {\n  let totalHits = 0;\n  let totalEntries = 0;\n\n  cache.forEach((entry) => {\n    totalHits += entry.hitCount;\n    totalEntries++;\n  });\n\n  return {\n    size: cache.size,\n    maxSize: MAX_CACHE_SIZE,\n    hitRate: totalEntries > 0 ? totalHits / totalEntries : 0,\n    totalHits,\n    totalEntries,\n  };\n}\n\n/**\n * Determine if a tool result should be cached\n */\nexport function shouldCache(toolId: string, result: unknown): boolean {\n  // Don't cache errors\n  if (result && typeof result === \"object\" && \"error\" in result) {\n    return false;\n  }\n\n  // Don't cache results that contain sensitive data\n  if (result && typeof result === \"object\") {\n    const resultStr = JSON.stringify(result);\n    const sensitivePatterns = [\n      /password/i,\n      /token/i,\n      /secret/i,\n      /key/i,\n      /credential/i,\n      /auth/i,\n    ];\n    \n    if (sensitivePatterns.some((pattern) => pattern.test(resultStr))) {\n      return false;\n    }\n  }\n\n  // Cache successful results for read-only tools\n  const readOnlyTools = [\n    \"data-studio-schema\",\n    \"data-studio-catalog\",\n    \"cyber-studio-vulnerability-scanner\",\n  ];\n\n  return readOnlyTools.includes(toolId);\n}\n","/**\n * Tool Execution Route Helper\n * \n * Provides a reusable pattern for creating tool execution API routes\n * with credit enforcement, auth gating, error handling, and comprehensive observability.\n * \n * Features:\n * - Structured logging with request IDs\n * - Performance metrics and timing\n * - Timeout handling\n * - Error categorization and recovery\n * - Credit audit trail\n * - Request/response logging\n */\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport crypto from \"crypto\";\nimport { rateLimit } from \"@/lib/security/rateLimit\";\nimport { requireAuthForServerTools, getUserIdFromSession } from \"@/lib/studios/auth-gating\";\nimport { getToolDefinition, isClientSideOnly } from \"@/lib/tools/registry\";\nimport {\n  estimateCredits,\n  computeAuthoritativeCharge,\n  validateSpendLimits,\n  getUserSpendLimits,\n  hasSufficientCredits,\n} from \"@/lib/billing/credits\";\nimport { getCreditBalance, consumeCredits } from \"@/lib/billing/creditStore\";\nimport { logCreditEvent } from \"@/lib/audit/creditAudit\";\nimport { logger } from \"@/server/logger\";\nimport { recordToolMetric } from \"@/lib/studios/toolMetrics\";\nimport { generateCacheKey, getCached, setCached, shouldCache } from \"@/lib/studios/responseCache\";\nimport { applySecurityHeaders } from \"@/lib/security/headers\";\nimport { getCircuitBreaker } from \"@/lib/studios/circuitBreaker\";\n\nexport interface ToolExecutionOptions {\n  toolId: string;\n  executeTool: (userId: string, body: any) => Promise<{\n    result: unknown;\n    actualUsage: { cpuMs: number; memMb: number; durationMs: number };\n    platformError?: boolean;\n  }>;\n  rateLimitKey?: string;\n  rateLimitWindow?: number;\n  timeoutMs?: number; // Execution timeout (default: 30s)\n  enableRetry?: boolean; // Enable retry for transient failures\n  maxRetries?: number; // Maximum retry attempts (default: 1)\n}\n\ninterface ExecutionMetrics {\n  requestId: string;\n  toolId: string;\n  userId: string;\n  startTime: number;\n  endTime?: number;\n  durationMs?: number;\n  phase: \"rate_limit\" | \"auth\" | \"credit_check\" | \"execution\" | \"charging\" | \"complete\" | \"error\";\n  phaseStartTime: number;\n  phaseDurations: Record<string, number>;\n  creditEstimate?: number;\n  creditCharged?: number;\n  errorType?: string;\n  errorCode?: string;\n}\n\nfunction createMetrics(requestId: string, toolId: string, userId: string): ExecutionMetrics {\n  const now = Date.now();\n  return {\n    requestId,\n    toolId,\n    userId,\n    startTime: now,\n    phase: \"rate_limit\",\n    phaseStartTime: now,\n    phaseDurations: {},\n  };\n}\n\nfunction recordPhase(metrics: ExecutionMetrics, phase: ExecutionMetrics[\"phase\"]): void {\n  const now = Date.now();\n  const duration = now - metrics.phaseStartTime;\n  metrics.phaseDurations[metrics.phase] = duration;\n  metrics.phase = phase;\n  metrics.phaseStartTime = now;\n}\n\nfunction finalizeMetrics(metrics: ExecutionMetrics): void {\n  metrics.endTime = Date.now();\n  metrics.durationMs = metrics.endTime - metrics.startTime;\n  recordPhase(metrics, metrics.phase); // Record final phase\n}\n\nfunction logExecutionMetrics(metrics: ExecutionMetrics, success: boolean): void {\n  const logCtx = {\n    requestId: metrics.requestId,\n    route: `/api/tools/${metrics.toolId}`,\n  };\n\n  const logPayload = {\n    toolId: metrics.toolId,\n    userId: metrics.userId,\n    durationMs: metrics.durationMs,\n    phaseDurations: metrics.phaseDurations,\n    creditEstimate: metrics.creditEstimate,\n    creditCharged: metrics.creditCharged,\n    success,\n    errorType: metrics.errorType,\n    errorCode: metrics.errorCode,\n  };\n\n  if (success) {\n    logger.info(\"tool_execution_completed\", logCtx, logPayload);\n  } else {\n    logger.error(\"tool_execution_failed\", logCtx, logPayload);\n  }\n}\n\n/**\n * Execute with timeout\n */\nasync function withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  errorMessage: string\n): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error(`${errorMessage} (timeout: ${timeoutMs}ms)`)), timeoutMs)\n    ),\n  ]);\n}\n\n/**\n * Retry logic for transient failures\n */\nasync function withRetry<T>(\n  fn: () => Promise<T>,\n  maxRetries: number,\n  retryDelayMs: number = 100\n): Promise<T> {\n  let lastError: Error | null = null;\n  \n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      \n      // Don't retry on non-transient errors\n      const errorMessage = lastError.message.toLowerCase();\n      if (\n        errorMessage.includes(\"invalid\") ||\n        errorMessage.includes(\"not found\") ||\n        errorMessage.includes(\"unauthorized\") ||\n        errorMessage.includes(\"forbidden\") ||\n        errorMessage.includes(\"insufficient\") ||\n        errorMessage.includes(\"limit exceeded\")\n      ) {\n        throw lastError;\n      }\n      \n      // Last attempt, throw the error\n      if (attempt === maxRetries) {\n        throw lastError;\n      }\n      \n      // Wait before retry\n      await new Promise((resolve) => setTimeout(resolve, retryDelayMs * (attempt + 1)));\n    }\n  }\n  \n  throw lastError || new Error(\"Retry failed\");\n}\n\n/**\n * Create a tool execution route handler\n * \n * This helper encapsulates the common pattern:\n * 1. Rate limiting\n * 2. Tool validation\n * 3. Auth gating\n * 4. Credit estimation\n * 5. Balance & limit checks\n * 6. Tool execution\n * 7. Credit charging\n * 8. Response formatting\n */\nexport function createToolExecutionHandler(options: ToolExecutionOptions) {\n  return async function handler(req: NextRequest) {\n    const {\n      toolId,\n      executeTool,\n      rateLimitKey,\n      rateLimitWindow,\n      timeoutMs = 30_000, // 30s default\n      enableRetry = false,\n      maxRetries = 1,\n    } = options;\n    \n    const requestId = crypto.randomUUID();\n    const startTime = Date.now();\n    let metrics: ExecutionMetrics | null = null;\n    let userId: string | null = null;\n\n    // Rate limiting\n    const rateLimitResult = rateLimit(req, {\n      keyPrefix: rateLimitKey || `tool-${toolId}`,\n      limit: 10,\n      windowMs: rateLimitWindow || 60_000,\n    });\n    if (rateLimitResult) {\n      logger.warn(\"rate_limit_exceeded\", { requestId, route: `/api/tools/${toolId}` }, {\n        toolId,\n        ip: req.headers.get(\"x-forwarded-for\") || \"unknown\",\n      });\n      return rateLimitResult;\n    }\n\n    try {\n      // Check if tool exists\n      const tool = getToolDefinition(toolId);\n      if (!tool) {\n        logger.error(\"tool_not_found\", { requestId, route: `/api/tools/${toolId}` }, { toolId });\n        return applySecurityHeaders(NextResponse.json(\n          { error: \"Tool not found\", code: \"TOOL_NOT_FOUND\", requestId },\n          { status: 404 }\n        ));\n      }\n\n      // Client-side only tools don't need server execution\n      if (isClientSideOnly(toolId)) {\n        logger.warn(\"client_side_only_tool\", { requestId, route: `/api/tools/${toolId}` }, { toolId });\n        return applySecurityHeaders(NextResponse.json(\n          {\n            error: \"This tool runs client-side only\",\n            code: \"CLIENT_SIDE_ONLY\",\n            message: \"No server execution needed for this tool\",\n            requestId,\n          },\n          { status: 400 }\n        ));\n      }\n\n      // Check auth requirements\n      const authCheck = await requireAuthForServerTools(toolId);\n      if (authCheck instanceof NextResponse) {\n        logger.warn(\"auth_required\", { requestId, route: `/api/tools/${toolId}` }, { toolId });\n        return authCheck; // Error response\n      }\n\n      userId = authCheck.userId!;\n      metrics = createMetrics(requestId, toolId, userId);\n      \n      const body = await req.json().catch(() => null);\n      \n      // Check cache for read-only operations\n      const cacheKey = generateCacheKey(toolId, body);\n      const cachedResult = getCached(cacheKey);\n      if (cachedResult) {\n        logger.info(\"cache_hit\", { requestId, route: `/api/tools/${toolId}` }, {\n          toolId,\n          userId,\n          cacheKey,\n        });\n        \n        return applySecurityHeaders(NextResponse.json({\n          success: true,\n          runId: crypto.randomUUID(),\n          requestId,\n          result: cachedResult,\n          credits: {\n            estimated: 0,\n            charged: 0,\n            balance: await getCreditBalance(userId),\n          },\n          executionTime: Date.now() - startTime,\n          cached: true,\n        }));\n      }\n      \n      recordPhase(metrics, \"credit_check\");\n      if (!body || typeof body !== \"object\") {\n        if (metrics) {\n          metrics.errorType = \"validation\";\n          metrics.errorCode = \"INVALID_BODY\";\n          finalizeMetrics(metrics);\n          logExecutionMetrics(metrics, false);\n        }\n        logger.warn(\"invalid_request_body\", { requestId, route: `/api/tools/${toolId}` }, { toolId });\n        return applySecurityHeaders(NextResponse.json(\n          { error: \"Invalid request body\", code: \"INVALID_BODY\", requestId },\n          { status: 400 }\n        ));\n      }\n\n      // Estimate credits before execution\n      const estimate = await estimateCredits(toolId, body.requestedLimits);\n      if (!estimate) {\n        if (metrics) {\n          metrics.errorType = \"system\";\n          metrics.errorCode = \"ESTIMATE_FAILED\";\n          finalizeMetrics(metrics);\n          logExecutionMetrics(metrics, false);\n        }\n        logger.error(\"credit_estimate_failed\", { requestId, route: `/api/tools/${toolId}` }, { toolId, userId });\n        return applySecurityHeaders(NextResponse.json(\n          { error: \"Failed to estimate credits\", code: \"ESTIMATE_FAILED\", requestId },\n          { status: 500 }\n        ));\n      }\n\n      if (metrics) {\n        metrics.creditEstimate = estimate.typical;\n      }\n\n      // Audit log: estimate requested\n      logCreditEvent({\n        type: \"credit_estimate_requested\",\n        userId,\n        toolId,\n        credits: estimate.typical,\n        metadata: { min: estimate.min, max: estimate.max, explanation: estimate.explanation },\n      });\n\n      // Check if user has sufficient credits\n      const creditCheck = await hasSufficientCredits(userId, estimate.max);\n      if (!creditCheck.sufficient) {\n        // Audit log: insufficient credits\n        logCreditEvent({\n          type: \"insufficient_credits\",\n          userId,\n          toolId,\n          credits: estimate.max,\n          balance: creditCheck.balance,\n          metadata: { shortfall: creditCheck.shortfall },\n        });\n\n        return applySecurityHeaders(NextResponse.json(\n          {\n            error: \"Insufficient credits\",\n            code: \"INSUFFICIENT_CREDITS\",\n            balance: creditCheck.balance,\n            required: estimate.max,\n            shortfall: creditCheck.shortfall,\n            action: \"Purchase credits or upgrade your plan\",\n            purchaseUrl: \"/account/credits\",\n          },\n          { status: 402 }\n        ));\n      }\n\n      // Validate spend limits\n      const limits = await getUserSpendLimits(userId);\n      const spendCheck = await validateSpendLimits(userId, estimate.max, limits);\n      if (!spendCheck.allowed) {\n        // Audit log: spend limit exceeded\n        logCreditEvent({\n          type: \"spend_limit_exceeded\",\n          userId,\n          toolId,\n          credits: estimate.max,\n          metadata: { reason: spendCheck.reason, limits },\n        });\n\n        return applySecurityHeaders(NextResponse.json(\n          {\n            error: \"Spend limit exceeded\",\n            code: \"SPEND_LIMIT_EXCEEDED\",\n            reason: spendCheck.reason,\n            action: spendCheck.action,\n          },\n          { status: 429 }\n        ));\n      }\n\n      // Audit log: tool execution allowed\n      logCreditEvent({\n        type: \"tool_execution_allowed\",\n        userId,\n        toolId,\n        credits: estimate.typical,\n        metadata: { estimatedMax: estimate.max },\n      });\n\n      // Execute tool with timeout and optional retry\n      recordPhase(metrics!, \"execution\");\n      let platformError = false;\n      let actualUsage = { cpuMs: 0, memMb: 0, durationMs: 0 };\n      let result: unknown = null;\n\n      // userId is guaranteed to be non-null at this point due to auth check\n      if (!userId) {\n        throw new Error(\"User ID is required but was not found\");\n      }\n\n      try {\n        // Use circuit breaker for tool execution\n        const circuitBreaker = getCircuitBreaker(`tool:${toolId}`, {\n          failureThreshold: 5,\n          timeoutMs: 60000, // 1 minute before attempting half-open\n        });\n\n        const executionFn = () => circuitBreaker.execute(() =>\n          withTimeout(\n            executeTool(userId!, body),\n            timeoutMs,\n            `Tool execution exceeded timeout`\n          )\n        );\n\n        let executionResult;\n        try {\n          executionResult = enableRetry\n            ? await withRetry(executionFn, maxRetries)\n            : await executionFn();\n        } catch (circuitError: any) {\n          // Handle circuit breaker errors\n          if (circuitError.name === \"CircuitBreakerOpenError\") {\n            if (metrics) {\n              metrics.errorType = \"system\";\n              metrics.errorCode = \"CIRCUIT_BREAKER_OPEN\";\n              finalizeMetrics(metrics);\n              logExecutionMetrics(metrics, false);\n            }\n            logger.warn(\"circuit_breaker_open\", { requestId, route: `/api/tools/${toolId}` }, {\n              toolId,\n              userId,\n            });\n            return applySecurityHeaders(NextResponse.json(\n              {\n                error: \"Service temporarily unavailable\",\n                code: \"CIRCUIT_BREAKER_OPEN\",\n                message: circuitError.message,\n                requestId,\n                retryAfter: Math.ceil(circuitBreaker.getRetryAfter() / 1000),\n              },\n              {\n                status: 503,\n                headers: {\n                  \"Retry-After\": String(Math.ceil(circuitBreaker.getRetryAfter() / 1000)),\n                },\n              }\n            ));\n          }\n          throw circuitError;\n        }\n\n        result = executionResult.result;\n        actualUsage = executionResult.actualUsage;\n        platformError = executionResult.platformError || false;\n      } catch (execError) {\n        platformError = true; // Platform error = refund\n        \n        const errorMessage = execError instanceof Error ? execError.message : \"Unknown error\";\n        const isTimeout = errorMessage.includes(\"timeout\");\n        \n        if (metrics) {\n          metrics.errorType = isTimeout ? \"timeout\" : \"execution\";\n          metrics.errorCode = isTimeout ? \"EXECUTION_TIMEOUT\" : \"EXECUTION_FAILED\";\n          finalizeMetrics(metrics);\n          \n          // Record failed metric\n          recordToolMetric({\n            toolId,\n            userId,\n            requestId,\n            success: false,\n            durationMs: metrics.durationMs || Date.now() - startTime,\n            phaseDurations: metrics.phaseDurations,\n            creditEstimate: estimate.typical,\n            creditCharged: 0,\n            errorType: metrics.errorType,\n            errorCode: metrics.errorCode,\n            timeout: isTimeout,\n          });\n        }\n        \n        // Audit log: tool execution failed\n        logCreditEvent({\n          type: \"tool_execution_failed\",\n          userId,\n          toolId,\n          metadata: {\n            error: errorMessage,\n            timeout: isTimeout,\n            requestId,\n          },\n        });\n        \n        logger.error(\"tool_execution_error\", { requestId, route: `/api/tools/${toolId}` }, {\n          toolId,\n          userId,\n          error: errorMessage,\n          isTimeout,\n        });\n        \n        throw execError;\n      }\n\n      // Calculate authoritative charge\n      recordPhase(metrics!, \"charging\");\n      const chargeResult = computeAuthoritativeCharge(toolId, actualUsage, platformError);\n      const runId = crypto.randomUUID();\n\n      if (metrics) {\n        metrics.creditCharged = chargeResult.charge;\n      }\n\n      // Charge or refund credits\n      if (chargeResult.refunded) {\n        if (metrics) {\n          metrics.errorType = \"platform\";\n          metrics.errorCode = \"PLATFORM_ERROR\";\n          finalizeMetrics(metrics);\n          logExecutionMetrics(metrics, false);\n        }\n        logger.error(\"platform_error_refund\", { requestId, route: `/api/tools/${toolId}` }, {\n          toolId,\n          userId,\n          reason: chargeResult.reason,\n        });\n        return applySecurityHeaders(NextResponse.json(\n          {\n            error: \"Platform error\",\n            code: \"PLATFORM_ERROR\",\n            message: chargeResult.reason,\n            refunded: true,\n            requestId,\n          },\n          { status: 500 }\n        ));\n      }\n\n      if (chargeResult.charge > 0) {\n        try {\n          await consumeCredits(userId, chargeResult.charge, toolId, runId, {\n            estimated: estimate.typical,\n            actual: chargeResult.charge,\n            usage: actualUsage,\n            requestId,\n          });\n        } catch (creditError) {\n          // If credit consumption fails, this is a platform error - refund\n          if (metrics) {\n            metrics.errorType = \"system\";\n            metrics.errorCode = \"CREDIT_PROCESSING_ERROR\";\n            finalizeMetrics(metrics);\n            logExecutionMetrics(metrics, false);\n          }\n          logCreditEvent({\n            type: \"tool_execution_failed\",\n            userId,\n            toolId,\n            runId,\n            metadata: {\n              error: \"Credit processing failed\",\n              requestId,\n            },\n          });\n          logger.error(\"credit_processing_failed\", { requestId, route: `/api/tools/${toolId}` }, {\n            toolId,\n            userId,\n            runId,\n            error: creditError instanceof Error ? creditError.message : \"Unknown error\",\n          });\n          return applySecurityHeaders(NextResponse.json(\n            {\n              error: \"Credit processing failed\",\n              code: \"CREDIT_PROCESSING_ERROR\",\n              message: \"Your credits were not charged. Please try again.\",\n              requestId,\n            },\n            { status: 500 }\n          ));\n        }\n      }\n\n      // Get updated balance\n      const balance = await getCreditBalance(userId);\n\n      // Audit log: tool execution completed\n      logCreditEvent({\n        type: \"tool_execution_completed\",\n        userId,\n        toolId,\n        runId,\n        credits: chargeResult.charge,\n        balance,\n        metadata: {\n          usage: actualUsage,\n          estimated: estimate.typical,\n          requestId,\n          durationMs: Date.now() - startTime,\n        },\n      });\n\n      // Finalize metrics and log\n      recordPhase(metrics!, \"complete\");\n      finalizeMetrics(metrics!);\n      logExecutionMetrics(metrics!, true);\n\n      // Record performance metric\n      recordToolMetric({\n        toolId,\n        userId,\n        requestId,\n        success: true,\n        durationMs: metrics!.durationMs!,\n        phaseDurations: metrics!.phaseDurations,\n        creditEstimate: estimate.typical,\n        creditCharged: chargeResult.charge,\n      });\n\n      // Cache result if appropriate (for read-only tools)\n      if (shouldCache(toolId, result)) {\n        setCached(cacheKey, result, 5 * 60 * 1000); // 5 minute TTL\n        logger.debug(\"cache_set\", { requestId, route: `/api/tools/${toolId}` }, {\n          toolId,\n          cacheKey,\n        });\n      }\n\n      // Return result with security headers\n      return applySecurityHeaders(NextResponse.json({\n        success: true,\n        runId,\n        requestId,\n        result,\n        credits: {\n          estimated: estimate.typical,\n          charged: chargeResult.charge,\n          balance,\n        },\n        executionTime: Date.now() - startTime,\n        metrics: {\n          phaseDurations: metrics!.phaseDurations,\n          totalDuration: metrics!.durationMs,\n        },\n      }));\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n      const errorCode = error instanceof Error && (error as any).code ? (error as any).code : \"INTERNAL_ERROR\";\n      \n      if (metrics) {\n        metrics.errorType = \"unhandled\";\n        metrics.errorCode = errorCode;\n        finalizeMetrics(metrics);\n        logExecutionMetrics(metrics, false);\n      }\n      \n      logger.error(\"tool_execution_unhandled_error\", { requestId, route: `/api/tools/${toolId}` }, {\n        toolId,\n        userId: userId || \"unknown\",\n        error: errorMessage,\n        errorCode,\n      });\n      \n      return applySecurityHeaders(NextResponse.json(\n        {\n          error: \"Internal server error\",\n          code: errorCode,\n          message: errorMessage,\n          requestId,\n        },\n        { status: error instanceof Error && (error as any).status ? (error as any).status : 500 }\n      ));\n    }\n  };\n}\n","/**\n * Security Headers Middleware\n * \n * Provides comprehensive security headers for API responses\n * to protect against common web vulnerabilities.\n */\n\nimport { NextResponse } from \"next/server\";\n\nexport interface SecurityHeadersOptions {\n  /**\n   * Content Security Policy\n   * Controls which resources can be loaded\n   */\n  csp?: string;\n  \n  /**\n   * Frame options\n   * Prevents clickjacking attacks\n   */\n  frameOptions?: \"DENY\" | \"SAMEORIGIN\";\n  \n  /**\n   * X-Content-Type-Options\n   * Prevents MIME type sniffing\n   */\n  contentTypeNosniff?: boolean;\n  \n  /**\n   * Referrer Policy\n   * Controls referrer information\n   */\n  referrerPolicy?: string;\n  \n  /**\n   * Permissions Policy (formerly Feature Policy)\n   * Controls browser features\n   */\n  permissionsPolicy?: string;\n  \n  /**\n   * Strict Transport Security\n   * Forces HTTPS connections\n   */\n  hsts?: {\n    maxAge: number;\n    includeSubDomains?: boolean;\n    preload?: boolean;\n  };\n}\n\nconst DEFAULT_OPTIONS: SecurityHeadersOptions = {\n  csp: \"default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https:;\",\n  frameOptions: \"DENY\",\n  contentTypeNosniff: true,\n  referrerPolicy: \"strict-origin-when-cross-origin\",\n  permissionsPolicy: \"geolocation=(), microphone=(), camera=()\",\n  hsts: {\n    maxAge: 31536000, // 1 year\n    includeSubDomains: true,\n    preload: false,\n  },\n};\n\n/**\n * Apply security headers to a response\n */\nexport function applySecurityHeaders(\n  response: NextResponse,\n  options: Partial<SecurityHeadersOptions> = {}\n): NextResponse {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  // Content Security Policy\n  if (opts.csp) {\n    response.headers.set(\"Content-Security-Policy\", opts.csp);\n  }\n\n  // X-Frame-Options\n  if (opts.frameOptions) {\n    response.headers.set(\"X-Frame-Options\", opts.frameOptions);\n  }\n\n  // X-Content-Type-Options\n  if (opts.contentTypeNosniff) {\n    response.headers.set(\"X-Content-Type-Options\", \"nosniff\");\n  }\n\n  // Referrer-Policy\n  if (opts.referrerPolicy) {\n    response.headers.set(\"Referrer-Policy\", opts.referrerPolicy);\n  }\n\n  // Permissions-Policy\n  if (opts.permissionsPolicy) {\n    response.headers.set(\"Permissions-Policy\", opts.permissionsPolicy);\n  }\n\n  // Strict-Transport-Security\n  if (opts.hsts) {\n    let hstsValue = `max-age=${opts.hsts.maxAge}`;\n    if (opts.hsts.includeSubDomains) {\n      hstsValue += \"; includeSubDomains\";\n    }\n    if (opts.hsts.preload) {\n      hstsValue += \"; preload\";\n    }\n    response.headers.set(\"Strict-Transport-Security\", hstsValue);\n  }\n\n  // Additional security headers\n  response.headers.set(\"X-XSS-Protection\", \"1; mode=block\");\n  response.headers.set(\"X-DNS-Prefetch-Control\", \"off\");\n  response.headers.set(\"X-Download-Options\", \"noopen\");\n  response.headers.set(\"X-Permitted-Cross-Domain-Policies\", \"none\");\n\n  return response;\n}\n\n/**\n * Create a middleware function that applies security headers\n */\nexport function withSecurityHeaders(\n  handler: (req: Request) => Promise<NextResponse>,\n  options?: Partial<SecurityHeadersOptions>\n) {\n  return async (req: Request): Promise<NextResponse> => {\n    const response = await handler(req);\n    return applySecurityHeaders(response, options);\n  };\n}\n","/**\n * Circuit Breaker Pattern Implementation\n * \n * Provides fault tolerance for external dependencies and expensive operations\n * by preventing cascading failures and allowing services to recover.\n */\n\ninterface CircuitState {\n  state: \"closed\" | \"open\" | \"half-open\";\n  failures: number;\n  successes: number;\n  lastFailureTime: number | null;\n  nextAttemptTime: number | null;\n}\n\ninterface CircuitBreakerOptions {\n  failureThreshold: number; // Number of failures before opening\n  successThreshold: number; // Number of successes in half-open to close\n  timeoutMs: number; // Time to wait before attempting half-open\n  resetTimeoutMs: number; // Time to wait before resetting failure count\n}\n\nconst DEFAULT_OPTIONS: CircuitBreakerOptions = {\n  failureThreshold: 5,\n  successThreshold: 2,\n  timeoutMs: 60000, // 1 minute\n  resetTimeoutMs: 300000, // 5 minutes\n};\n\n// In-memory circuit breaker state (for production, consider Redis)\nconst circuits = new Map<string, CircuitState>();\n\n/**\n * Circuit Breaker class\n */\nexport class CircuitBreaker {\n  private key: string;\n  private options: CircuitBreakerOptions;\n  private state: CircuitState;\n\n  constructor(key: string, options: Partial<CircuitBreakerOptions> = {}) {\n    this.key = key;\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n    \n    // Get or create state\n    const existing = circuits.get(key);\n    this.state = existing || {\n      state: \"closed\",\n      failures: 0,\n      successes: 0,\n      lastFailureTime: null,\n      nextAttemptTime: null,\n    };\n    \n    if (!existing) {\n      circuits.set(key, this.state);\n    }\n  }\n\n  /**\n   * Execute a function with circuit breaker protection\n   */\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    this.updateState();\n\n    if (this.state.state === \"open\") {\n      throw new CircuitBreakerOpenError(\n        `Circuit breaker is open for ${this.key}. Retry after ${this.getRetryAfter()}ms`\n      );\n    }\n\n    try {\n      const result = await fn();\n      this.recordSuccess();\n      return result;\n    } catch (error) {\n      this.recordFailure();\n      throw error;\n    }\n  }\n\n  /**\n   * Check if circuit is open (non-blocking)\n   */\n  isOpen(): boolean {\n    this.updateState();\n    return this.state.state === \"open\";\n  }\n\n  /**\n   * Get retry-after time in milliseconds\n   */\n  getRetryAfter(): number {\n    if (this.state.state !== \"open\" || !this.state.nextAttemptTime) {\n      return 0;\n    }\n    return Math.max(0, this.state.nextAttemptTime - Date.now());\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): \"closed\" | \"open\" | \"half-open\" {\n    this.updateState();\n    return this.state.state;\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats() {\n    this.updateState();\n    return {\n      state: this.state.state,\n      failures: this.state.failures,\n      successes: this.state.successes,\n      lastFailureTime: this.state.lastFailureTime,\n      nextAttemptTime: this.state.nextAttemptTime,\n    };\n  }\n\n  /**\n   * Reset circuit breaker\n   */\n  reset(): void {\n    this.state = {\n      state: \"closed\",\n      failures: 0,\n      successes: 0,\n      lastFailureTime: null,\n      nextAttemptTime: null,\n    };\n    circuits.set(this.key, this.state);\n  }\n\n  private updateState(): void {\n    const now = Date.now();\n\n    // Reset failure count if enough time has passed\n    if (\n      this.state.lastFailureTime &&\n      now - this.state.lastFailureTime > this.options.resetTimeoutMs\n    ) {\n      this.state.failures = 0;\n      this.state.lastFailureTime = null;\n    }\n\n    // Transition from open to half-open\n    if (\n      this.state.state === \"open\" &&\n      this.state.nextAttemptTime &&\n      now >= this.state.nextAttemptTime\n    ) {\n      this.state.state = \"half-open\";\n      this.state.successes = 0;\n      this.state.nextAttemptTime = null;\n    }\n  }\n\n  private recordSuccess(): void {\n    if (this.state.state === \"half-open\") {\n      this.state.successes++;\n      if (this.state.successes >= this.options.successThreshold) {\n        // Close the circuit\n        this.state.state = \"closed\";\n        this.state.failures = 0;\n        this.state.successes = 0;\n      }\n    } else if (this.state.state === \"closed\") {\n      // Reset failure count on success\n      this.state.failures = Math.max(0, this.state.failures - 1);\n    }\n  }\n\n  private recordFailure(): void {\n    this.state.failures++;\n    this.state.lastFailureTime = Date.now();\n\n    if (this.state.state === \"half-open\") {\n      // Open immediately on failure in half-open\n      this.state.state = \"open\";\n      this.state.nextAttemptTime = Date.now() + this.options.timeoutMs;\n      this.state.successes = 0;\n    } else if (this.state.state === \"closed\") {\n      if (this.state.failures >= this.options.failureThreshold) {\n        // Open the circuit\n        this.state.state = \"open\";\n        this.state.nextAttemptTime = Date.now() + this.options.timeoutMs;\n      }\n    }\n  }\n}\n\n/**\n * Circuit breaker error\n */\nexport class CircuitBreakerOpenError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"CircuitBreakerOpenError\";\n  }\n}\n\n/**\n * Get or create a circuit breaker instance\n */\nexport function getCircuitBreaker(\n  key: string,\n  options?: Partial<CircuitBreakerOptions>\n): CircuitBreaker {\n  return new CircuitBreaker(key, options);\n}\n\n/**\n * Get all circuit breaker statistics\n */\nexport function getAllCircuitStats(): Record<string, ReturnType<CircuitBreaker[\"getStats\"]>> {\n  const stats: Record<string, ReturnType<CircuitBreaker[\"getStats\"]>> = {};\n  circuits.forEach((_, key) => {\n    const breaker = new CircuitBreaker(key);\n    stats[key] = breaker.getStats();\n  });\n  return stats;\n}\n\n/**\n * Reset all circuit breakers\n */\nexport function resetAllCircuits(): void {\n  circuits.clear();\n}\n"],"names":[],"mappings":"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"}}]
}