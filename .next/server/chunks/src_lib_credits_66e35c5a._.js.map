{
  "version": 3,
  "sources": [],
  "debugId": "54c52485-a07f-b18e-ab62-19b3c08e91fa",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../src/lib/credits/store.ts","../../../src/lib/credits/enforceCreditGate.ts"],"sourcesContent":["import { prisma } from \"@/lib/db/prisma\";\n\nconst DEFAULT_CREDIT_EXPIRY_DAYS = 365 * 2; // 24 months (recommended default)\nconst CREDIT_EXPIRY_DAYS = (() => {\n  const raw = process.env.CREDITS_EXPIRY_DAYS;\n  const n = raw ? Number(raw) : NaN;\n  return Number.isFinite(n) && n > 0 ? Math.floor(n) : DEFAULT_CREDIT_EXPIRY_DAYS;\n})();\n\nfunction addDays(date: Date, days: number) {\n  const d = new Date(date);\n  d.setDate(d.getDate() + days);\n  return d;\n}\n\nexport async function getOrCreateCredits(userId: string) {\n  const existing = await prisma.credits.findUnique({ where: { userId } });\n  if (existing) return existing;\n  return await prisma.credits.create({ data: { userId, balance: 0, expiresAt: null } });\n}\n\nexport async function getCreditsAggregate() {\n  const totalUsersWithCredits = await prisma.credits.count();\n  const sum = await prisma.credits.aggregate({ _sum: { balance: true } });\n  return {\n    totalUsersWithCredits,\n    totalCredits: sum._sum.balance ?? 0,\n  };\n}\n\nexport async function enforceCreditExpiry(userId: string) {\n  const credits = await prisma.credits.findUnique({ where: { userId } });\n  if (!credits) return null;\n  if (!credits.expiresAt) return credits;\n  const now = new Date();\n  if (credits.expiresAt.getTime() > now.getTime()) return credits;\n  // Expired: reset to zero but keep record.\n  return await prisma.credits.update({ where: { userId }, data: { balance: 0 } });\n}\n\nexport async function createCreditUsageEvent(input: {\n  userId: string;\n  toolId: string;\n  consumed: number;\n  units: number;\n  freeUnits: number;\n  paidUnits: number;\n  runId?: string | null;\n  baseFree?: boolean;\n  estimatedCredits?: number;\n  actualCredits?: number;\n  meteringUnit?: string;\n  durationMs?: number;\n  inputBytes?: number;\n  outputBytes?: number;\n  freeTierAppliedMs?: number;\n  paidMs?: number;\n}) {\n  return prisma.creditUsageEvent.create({\n    data: {\n      userId: input.userId,\n      toolId: input.toolId,\n      consumed: input.consumed,\n      units: input.units,\n      freeUnits: input.freeUnits,\n      paidUnits: input.paidUnits,\n      runId: input.runId || null,\n      baseFree: Boolean(input.baseFree),\n      estimatedCredits: Math.max(0, Math.round(Number(input.estimatedCredits) || 0)),\n      actualCredits: Math.max(0, Math.round(Number(input.actualCredits) || 0)),\n      meteringUnit: input.meteringUnit || \"ms\",\n      durationMs: Math.max(0, Math.round(Number(input.durationMs) || 0)),\n      inputBytes: Math.max(0, Math.round(Number(input.inputBytes) || 0)),\n      outputBytes: Math.max(0, Math.round(Number(input.outputBytes) || 0)),\n      freeTierAppliedMs: Math.max(0, Math.round(Number(input.freeTierAppliedMs) || 0)),\n      paidMs: Math.max(0, Math.round(Number(input.paidMs) || 0)),\n    },\n  });\n}\n\nexport async function listCreditUsage(userId: string, limit = 50) {\n  return prisma.creditUsageEvent.findMany({\n    where: { userId },\n    orderBy: { occurredAt: \"desc\" },\n    take: Math.max(1, Math.min(200, limit)),\n  });\n}\n\nexport function computeNewExpiry(from = new Date()) {\n  return addDays(from, CREDIT_EXPIRY_DAYS);\n}\n\nexport async function createCreditLot(input: {\n  userId: string;\n  credits: number;\n  source: string;\n  stripeEventId?: string | null;\n  stripePriceId?: string | null;\n  stripeCheckoutSessionId?: string | null;\n  stripePaymentIntentId?: string | null;\n  expiresAt?: Date | null;\n}) {\n  const credits = Math.max(0, Math.round(Number(input.credits) || 0));\n  return prisma.creditLot.create({\n    data: {\n      userId: input.userId,\n      credits,\n      amountCredits: credits,\n      remainingCredits: credits,\n      source: input.source,\n      stripeEventId: input.stripeEventId || null,\n      stripePriceId: input.stripePriceId || null,\n      stripeCheckoutSessionId: input.stripeCheckoutSessionId || null,\n      stripePaymentIntentId: input.stripePaymentIntentId || null,\n      expiresAt: input.expiresAt || null,\n    },\n  });\n}\n\nexport async function grantCredits(input: {\n  userId: string;\n  credits: number;\n  source: string;\n  stripeEventId?: string | null;\n  stripePriceId?: string | null;\n  stripeCheckoutSessionId?: string | null;\n  stripePaymentIntentId?: string | null;\n}) {\n  const creditsToAdd = Math.max(0, Math.round(Number(input.credits) || 0));\n  if (!creditsToAdd) return { ok: false as const, balance: null as number | null };\n\n  const expiresAt = computeNewExpiry(new Date());\n\n  const result = await prisma.$transaction(async (tx) => {\n    const current = await tx.credits.findUnique({ where: { userId: input.userId } });\n    const currentBalance = current?.balance ?? 0;\n    const nextBalance = currentBalance + creditsToAdd;\n\n    const updated = await tx.credits.upsert({\n      where: { userId: input.userId },\n      update: {\n        balance: nextBalance,\n        // Keep the furthest expiry (simple model; lots are for audit trail).\n        expiresAt: current?.expiresAt && current.expiresAt > expiresAt ? current.expiresAt : expiresAt,\n      },\n      create: {\n        userId: input.userId,\n        balance: nextBalance,\n        expiresAt,\n      },\n    });\n\n    await tx.creditLot.create({\n      data: {\n        userId: input.userId,\n        credits: creditsToAdd,\n        amountCredits: creditsToAdd,\n        remainingCredits: creditsToAdd,\n        source: input.source,\n        stripeEventId: input.stripeEventId || null,\n        stripePriceId: input.stripePriceId || null,\n        stripeCheckoutSessionId: input.stripeCheckoutSessionId || null,\n        stripePaymentIntentId: input.stripePaymentIntentId || null,\n        expiresAt,\n      },\n    });\n\n    return { ok: true as const, balance: updated.balance };\n  });\n\n  return result;\n}\n\n\n","import { NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth/options\";\nimport { prisma } from \"@/lib/db/prisma\";\nimport { enforceCreditExpiry } from \"@/lib/credits/store\";\n\nexport type CreditGateResult =\n  | {\n      ok: true;\n      userId: string;\n      balance: number;\n      remainingAfter: number;\n    }\n  | {\n      ok: false;\n      status: number;\n      message: string;\n      requiredCredits?: number;\n      currentBalance?: number;\n    };\n\n/**\n * Enforces credit gate for operations requiring server-side computation.\n * \n * This utility:\n * - Validates user is authenticated\n * - Checks current credit balance\n * - Validates sufficient credits (with safety buffer)\n * - Returns standardized error responses\n * \n * @param estimatedCredits - Estimated credit cost for the operation\n * @param safetyBuffer - Multiplier for safety buffer (default 1.25 = 25% buffer)\n * @returns CreditGateResult indicating if operation can proceed\n */\nexport async function enforceCreditGate(\n  estimatedCredits: number,\n  safetyBuffer = 1.25\n): Promise<CreditGateResult> {\n  // Get authenticated user\n  const session = await getServerSession(authOptions);\n  if (!session?.user?.id) {\n    return {\n      ok: false,\n      status: 401,\n      message: \"Authentication required. Please sign in to use this feature.\",\n    };\n  }\n\n  const userId = session.user.id;\n\n  // If no credits required, allow operation\n  if (estimatedCredits <= 0) {\n    return {\n      ok: true,\n      userId,\n      balance: 0,\n      remainingAfter: 0,\n    };\n  }\n\n  // Enforce credit expiry\n  await enforceCreditExpiry(userId);\n\n  // Get current balance\n  const creditsRow = await prisma.credits.findUnique({ where: { userId } });\n  const currentBalance = creditsRow?.balance ?? 0;\n\n  // Check for expired credits\n  if (creditsRow?.expiresAt && creditsRow.expiresAt.getTime() <= Date.now()) {\n    return {\n      ok: false,\n      status: 402,\n      message: \"Your credits have expired. Please purchase more credits to continue.\",\n      requiredCredits: estimatedCredits,\n      currentBalance: 0,\n    };\n  }\n\n  // Calculate required credits with safety buffer\n  const requiredCredits = Math.ceil(estimatedCredits * safetyBuffer);\n\n  // Check if user has sufficient credits\n  if (currentBalance < requiredCredits) {\n    return {\n      ok: false,\n      status: 402,\n      message: `Insufficient credits. This operation requires approximately ${estimatedCredits} credits (${requiredCredits} with safety buffer), but you only have ${currentBalance} credits available.`,\n      requiredCredits,\n      currentBalance,\n    };\n  }\n\n  return {\n    ok: true,\n    userId,\n    balance: currentBalance,\n    remainingAfter: currentBalance - requiredCredits, // Note: actual deduction happens separately\n  };\n}\n\n/**\n * Creates a standardized NextResponse for credit gate failures\n */\nexport function creditGateErrorResponse(result: Extract<CreditGateResult, { ok: false }>): NextResponse {\n  return NextResponse.json(\n    {\n      code: result.status === 401 ? \"UNAUTHORIZED\" : \"INSUFFICIENT_CREDITS\",\n      message: result.message,\n      requiredCredits: result.requiredCredits,\n      currentBalance: result.currentBalance,\n    },\n    { status: result.status }\n  );\n}\n\n"],"names":[],"mappings":"4CAIQ,IAJR,IAAA,EAAA,EAAA,CAAA,CAAA,QAGA,IAAM,EAGG,OAAO,QAAQ,CADhB,AACiB,EADb,CAFe,CAAC,CACd,QAAQ,GAAG,CAAC,mBAAmB,EAC3B,OAAO,GAAO,MACD,EAAI,EAAI,KAAK,KAAK,CAAC,GAJf,EAIoB,EAShD,EAbkC,GAAG,UAatB,EAAmB,CAAc,EACrD,IAAM,EAAW,MAAM,EAAA,KAdqD,CAc/C,CAAC,OAAO,CAAC,UAAU,CAAC,CAAE,MAAO,QAAE,CAAO,CAAE,UACrE,AAAI,GACG,MAAM,CADC,CACD,MADQ,AACF,CAAC,OAAO,CAAC,MAAM,CAAC,CAAE,KAAM,QAAE,EAAQ,QAAS,EAAG,UAAW,IAAK,CAAE,EACrF,CAEO,eAAe,IAGpB,MAAO,CACL,sBAH4B,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,KAAK,GAItD,aAAc,CAHJ,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,CAAE,KAAM,CAAE,QAAS,EAAK,CAAE,EAAA,EAGjD,IAAI,CAAC,OAAO,EAAI,CACpC,CACF,CAEO,eAAe,EAAoB,CAAc,EACtD,IAAM,EAAU,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAE,MAAO,QAAE,CAAO,CAAE,GACpE,GAAI,CAAC,EAAS,OAAO,KACrB,GAAI,CAAC,EAAQ,SAAS,CAAE,OAAO,EAC/B,IAAM,EAAM,IAAI,YAChB,AAAI,EAAQ,SAAS,CAAC,OAAO,GAAK,EAAI,OAAO,GAAW,CAAP,CAE1C,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAE,MAAO,CAAE,QAAO,EAAG,KAAM,CAAE,QAAS,CAAE,CAAE,EAC/E,CAEO,eAAe,EAAuB,CAiB5C,EACC,OAAO,EAAA,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,CACpC,KAAM,CACJ,OAAQ,EAAM,MAAM,CACpB,OAAQ,EAAM,MAAM,CACpB,SAAU,EAAM,QAAQ,CACxB,MAAO,EAAM,KAAK,CAClB,UAAW,EAAM,SAAS,CAC1B,UAAW,EAAM,SAAS,CAC1B,MAAO,EAAM,KAAK,EAAI,KACtB,SAAU,EAAQ,EAAM,QAAQ,CAChC,iBAAkB,KAAK,GAAG,CAAC,EAAG,KAAK,KAAK,CAAC,OAAO,EAAM,gBAAgB,GAAK,IAC3E,cAAe,KAAK,GAAG,CAAC,EAAG,KAAK,KAAK,CAAC,OAAO,EAAM,aAAa,GAAK,IACrE,aAAc,EAAM,YAAY,EAAI,KACpC,WAAY,KAAK,GAAG,CAAC,EAAG,KAAK,KAAK,CAAC,OAAO,EAAM,UAAU,GAAK,IAC/D,WAAY,KAAK,GAAG,CAAC,EAAG,KAAK,KAAK,CAAC,OAAO,EAAM,UAAU,GAAK,IAC/D,YAAa,KAAK,GAAG,CAAC,EAAG,KAAK,KAAK,CAAC,OAAO,EAAM,WAAW,GAAK,IACjE,kBAAmB,KAAK,GAAG,CAAC,EAAG,KAAK,KAAK,CAAC,OAAO,EAAM,iBAAiB,GAAK,IAC7E,OAAQ,KAAK,GAAG,CAAC,EAAG,KAAK,KAAK,CAAC,OAAO,EAAM,MAAM,GAAK,GACzD,CACF,EACF,CAEO,eAAe,EAAgB,CAAc,CAAE,EAAQ,EAAE,EAC9D,OAAO,EAAA,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CACtC,MAAO,QAAE,CAAO,EAChB,QAAS,CAAE,WAAY,MAAO,EAC9B,KAAM,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,IAAK,GAClC,EACF,CAEO,SAAS,EAAiB,EAAO,IAAI,IAAM,QAChD,MA9EA,CADM,AA+EC,EA/EG,IAAI,KAAK,AA+EJ,IA9Eb,OAAO,CAAC,EAAE,OAAO,GA8EE,EA9EG,CACjB,CA8ET,CAEO,eAAe,EAAgB,CASrC,EACC,IAAM,EAAU,KAAK,GAAG,CAAC,EAAG,KAAK,KAAK,CAAC,OAAO,EAAM,OAAO,GAAK,IAChE,OAAO,EAAA,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,CAC7B,KAAM,CACJ,OAAQ,EAAM,MAAM,SACpB,EACA,cAAe,EACf,iBAAkB,EAClB,OAAQ,EAAM,MAAM,CACpB,cAAe,EAAM,aAAa,EAAI,KACtC,cAAe,EAAM,aAAa,EAAI,KACtC,wBAAyB,EAAM,uBAAuB,EAAI,KAC1D,sBAAuB,EAAM,qBAAqB,EAAI,KACtD,UAAW,EAAM,SAAS,EAAI,IAChC,CACF,EACF,CAEO,eAAe,EAAa,CAQlC,EACC,IAAM,EAAe,KAAK,GAAG,CAAC,EAAG,KAAK,KAAK,CAAC,OAAO,EAAM,OAAO,GAAK,IACrE,GAAI,CAAC,EAAc,MAAO,CAAE,IAAI,EAAgB,QAAS,IAAsB,EAE/E,IAAM,EAAY,EAAiB,IAAI,MAuCvC,OArCe,AAqCR,MArCc,EAAA,MAAM,CAAC,YAAY,CAAC,MAAO,IAC9C,IAAM,EAAU,MAAM,EAAG,OAAO,CAAC,UAAU,CAAC,CAAE,MAAO,CAAE,OAAQ,EAAM,MAAM,AAAC,CAAE,GAExE,EAAc,AADG,IAAS,UAAW,EACN,EAE/B,EAAU,MAAM,EAAG,OAAO,CAAC,MAAM,CAAC,CACtC,MAAO,CAAE,OAAQ,EAAM,MAAM,AAAC,EAC9B,OAAQ,CACN,QAAS,EAET,UAAW,GAAS,WAAa,EAAQ,SAAS,CAAG,EAAY,EAAQ,SAAS,CAAG,CACvF,EACA,OAAQ,CACN,OAAQ,EAAM,MAAM,CACpB,QAAS,YACT,CACF,CACF,GAiBA,OAfA,MAAM,EAAG,SAAS,CAAC,MAAM,CAAC,CACxB,KAAM,CACJ,OAAQ,EAAM,MAAM,CACpB,QAAS,EACT,cAAe,EACf,iBAAkB,EAClB,OAAQ,EAAM,MAAM,CACpB,cAAe,EAAM,aAAa,EAAI,KACtC,cAAe,EAAM,aAAa,EAAI,KACtC,wBAAyB,EAAM,uBAAuB,EAAI,KAC1D,sBAAuB,EAAM,qBAAqB,EAAI,eACtD,CACF,CACF,GAEO,CAAE,IAAI,EAAe,QAAS,EAAQ,OAAO,AAAC,CACvD,EAGF,iPC3KA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QA8BO,eAAe,EACpB,CAAwB,CACxB,EAAe,IAAI,EAGnB,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,EAAA,WAAW,EAClD,GAAI,CAAC,GAAS,MAAM,GAClB,CADsB,KACf,CACL,IAAI,EACJ,OAAQ,IACR,QAAS,8DACX,EAGF,IAAM,EAAS,EAAQ,IAAI,CAAC,EAAE,CAG9B,GAAI,GAAoB,EACtB,CADyB,KAClB,CACL,IAAI,SACJ,EACA,QAAS,EACT,eAAgB,CAClB,CAIF,OAAM,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,GAG1B,IAAM,EAAa,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAE,MAAO,QAAE,CAAO,CAAE,GACjE,EAAiB,GAAY,SAAW,EAG9C,GAAI,GAAY,WAAa,EAAW,SAAS,CAAC,OAAO,IAAM,KAAK,GAAG,GACrE,CADyE,KAClE,CACL,IAAI,EACJ,OAAQ,IACR,QAAS,uEACT,gBAAiB,EACjB,eAAgB,CAClB,EAIF,IAAM,EAAkB,KAAK,IAAI,CAAC,EAAmB,UAGrD,AAAI,EAAiB,EACZ,CACL,IAAI,EACJ,OAAQ,CAH0B,GAIlC,QAAS,CAAC,4DAA4D,EAAE,EAAiB,UAAU,EAAE,EAAgB,wCAAwC,EAAE,EAAe,mBAAmB,CAAC,iBAClM,iBACA,CACF,EAGK,CACL,IAAI,EACJ,SACA,QAAS,EACT,eAAgB,EAAiB,CACnC,CACF,CAKO,SAAS,EAAwB,CAAgD,EACtF,OAAO,EAAA,YAAY,CAAC,IAAI,CACtB,CACE,KAAwB,MAAlB,EAAO,MAAM,CAAW,eAAiB,uBAC/C,QAAS,EAAO,OAAO,CACvB,gBAAiB,EAAO,eAAe,CACvC,eAAgB,EAAO,cAAc,AACvC,EACA,CAAE,OAAQ,EAAO,MAAM,AAAC,EAE5B"}}]
}