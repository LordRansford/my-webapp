{
  "version": 3,
  "sources": [],
  "debugId": "d44d2238-b3f8-ee4e-c2a8-0d086315f474",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../src/lib/auth/options.ts","../../../src/lib/auth/store.ts","../../../src/lib/storage/jsonFile.ts","../../../src/lib/auth/adapter.ts","../../../src/lib/billing/access.ts","../../../src/lib/billing/plans.ts","../../../src/lib/billing/store.ts","../../../src/lib/testingMode.ts","../../../src/lib/db/prisma.ts","../../../src/services/progressService.ts","../../../src/lib/admin/rbac.ts"],"sourcesContent":["import GoogleProvider from \"next-auth/providers/google\";\nimport EmailProvider from \"next-auth/providers/email\";\nimport type { NextAuthOptions } from \"next-auth\";\nimport { BetterSqlite3Adapter } from \"@/lib/auth/adapter\";\nimport { upsertUser, getUserById } from \"@/lib/auth/store\";\nimport { getUserPlan } from \"@/lib/billing/access\";\nimport { upsertUserIdentity } from \"@/services/progressService\";\nimport { prisma } from \"@/lib/db/prisma\";\nimport { isAdminRole } from \"@/lib/admin/rbac\";\nimport { logWarn } from \"@/lib/telemetry/log\";\n\nexport const authOptions: NextAuthOptions = {\n  adapter: BetterSqlite3Adapter(),\n  // Phase 5: stateless JWT sessions (no server session table required).\n  // Tokens remain in httpOnly cookies; client JS never reads raw tokens.\n  session: { strategy: \"jwt\", maxAge: 60 * 60 * 24 * 14 },\n  // Security: set NEXTAUTH_SECRET in env for consistent token/cookie encryption.\n  // Keep secrets server-side only. NextAuth cookies are httpOnly by default and CSRF protection is enabled by default.\n  secret: process.env.NEXTAUTH_SECRET,\n  providers: (() => {\n    const providers: any[] = [];\n\n    // Keep login optional: the site remains usable without auth, but users can sign in to persist progress across devices.\n    const googleId = process.env.GOOGLE_CLIENT_ID || \"\";\n    const googleSecret = process.env.GOOGLE_CLIENT_SECRET || \"\";\n    if (googleId && googleSecret) {\n      providers.push(\n        GoogleProvider({\n          clientId: googleId,\n          clientSecret: googleSecret,\n        })\n      );\n    } else if (process.env.NODE_ENV !== \"production\" && (googleId || googleSecret)) {\n      logWarn(\"auth.provider_misconfigured\", { provider: \"google\" });\n    }\n\n    // Email magic link (passwordless). Only enable when fully configured.\n    const emailServer = process.env.EMAIL_SERVER || \"\";\n    const emailFrom = process.env.EMAIL_FROM || \"\";\n    if (emailServer && emailFrom) {\n      providers.push(\n        EmailProvider({\n          server: emailServer,\n          from: emailFrom,\n          // Magic link expiry <= 15 minutes.\n          maxAge: 15 * 60,\n        })\n      );\n    } else if (process.env.NODE_ENV !== \"production\" && (emailServer || emailFrom)) {\n      logWarn(\"auth.provider_misconfigured\", { provider: \"email\" });\n    }\n\n    return providers;\n  })(),\n  pages: {\n    signIn: \"/signin\",\n    verifyRequest: \"/signin?check=1\",\n    error: \"/signin?error=auth\",\n  },\n  events: {\n    async signIn({ user, account }) {\n      // Identity model (passwordless by design):\n      // - User = email + provider id (providerAccountId)\n      // - Email is the primary identifier for humans; internal id is stable UUID\n      //\n      // Store minimal identity metadata. Never store magic link tokens.\n      try {\n        const existing = user?.id ? getUserById(user.id) : null;\n        const plan = user?.id ? await getUserPlan(user.id) : \"free\";\n        if (existing && user?.id) {\n          upsertUser({\n            ...existing,\n            // Tier is derived from server-side plan records/entitlements.\n            tier: plan === \"pro\" ? \"professional\" : plan === \"supporter\" ? \"supporter\" : \"registered\",\n            lastLoginAt: new Date().toISOString(),\n          });\n        }\n        // Mirror identity into the Prisma-backed progress store so progress persistence can scale.\n        if (user?.id && user?.email && account?.provider && account?.providerAccountId) {\n          await upsertUserIdentity({\n            userId: user.id,\n            email: user.email,\n            provider: account.provider,\n            providerAccountId: String(account.providerAccountId),\n          });\n        }\n      } catch {\n        // Avoid blocking sign-in on metadata write.\n      }\n    },\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      // Embed admin role in JWT so middleware can enforce /admin without DB access.\n      // Fail closed: unknown values are ignored.\n      try {\n        const userId = (user as any)?.id || (token as any)?.sub;\n        if (userId) {\n          const rec = await (prisma as any).userIdentity.findUnique({ where: { id: String(userId) }, select: { adminRole: true } });\n          const role = rec?.adminRole;\n          (token as any).adminRole = isAdminRole(role) ? role : null;\n        }\n      } catch {\n        (token as any).adminRole = null;\n      }\n      return token;\n    },\n    async session({ session, token, user }) {\n      if (session.user) {\n        session.user.id = (user as any)?.id || String((token as any)?.sub || \"\");\n        // Surface admin role to server components; do not rely on this on the client for security.\n        (session.user as any).adminRole = (token as any)?.adminRole || null;\n      }\n      return session;\n    },\n  },\n  // Privacy: do not log personal data beyond email. Keep logs minimal.\n  logger: {\n    error(code) {\n      console.error(\"auth:error\", code);\n    },\n    warn(code) {\n      console.warn(\"auth:warn\", code);\n    },\n    debug() {\n      // intentionally no-op (avoid verbose logs containing auth payloads)\n    },\n  },\n};\n\n\n","import { randomUUID } from \"crypto\";\nimport { readJsonFile, writeJsonFile } from \"@/lib/storage/jsonFile\";\n\nconst AUTH_STORE_PATH = process.env.AUTH_STORE_PATH || \"data/auth.json\";\n\nexport type StoredUser = {\n  id: string;\n  email: string;\n  emailVerified: string | null;\n  name: string | null;\n  image: string | null;\n  provider: string | null;\n  entitlements: string[];\n  entitlementSource: string;\n  createdAt: string;\n  lastLoginAt?: string | null;\n  tier?: \"visitor\" | \"registered\" | \"supporter\" | \"professional\";\n  consent?: {\n    termsAcceptedAt?: string | null;\n    privacyAcceptedAt?: string | null;\n    cpdDataUseAcceptedAt?: string | null;\n  };\n};\n\nexport function addUserEntitlement(params: { userId: string; entitlement: string; source: string }) {\n  const s = load();\n  const idx = s.users.findIndex((u) => u.id === params.userId);\n  if (idx === -1) return null;\n  const user = s.users[idx];\n  const entitlements = Array.isArray(user.entitlements) ? user.entitlements : [\"free\"];\n  const next = Array.from(new Set([...entitlements.filter((e) => e !== \"free\"), params.entitlement]));\n  s.users[idx] = {\n    ...user,\n    entitlements: next.length ? next : [\"free\"],\n    entitlementSource: params.source,\n  };\n  save(s);\n  return s.users[idx];\n}\n\ntype StoredAccount = {\n  id: string;\n  userId: string;\n  type: string;\n  provider: string;\n  providerAccountId: string;\n  refresh_token?: string | null;\n  access_token?: string | null;\n  expires_at?: number | null;\n  token_type?: string | null;\n  scope?: string | null;\n  id_token?: string | null;\n  session_state?: string | null;\n};\n\ntype StoredSession = {\n  id: string;\n  sessionToken: string;\n  userId: string;\n  expires: string;\n};\n\ntype StoredVerificationToken = {\n  identifier: string;\n  token: string;\n  expires: string;\n};\n\ntype AuthStore = {\n  users: StoredUser[];\n  accounts: StoredAccount[];\n  sessions: StoredSession[];\n  verificationTokens: StoredVerificationToken[];\n  cpdState: Record<string, { stateJson: string; updatedAt: string }>;\n};\n\nconst empty: AuthStore = {\n  users: [],\n  accounts: [],\n  sessions: [],\n  verificationTokens: [],\n  cpdState: {},\n};\n\nfunction load(): AuthStore {\n  return readJsonFile<AuthStore>(AUTH_STORE_PATH, empty);\n}\n\nfunction save(store: AuthStore) {\n  writeJsonFile(AUTH_STORE_PATH, store);\n}\n\nexport function createId() {\n  return randomUUID();\n}\n\nexport function getUserById(id: string) {\n  const s = load();\n  return s.users.find((u) => u.id === id) || null;\n}\n\nexport function getUserByEmail(email: string) {\n  const s = load();\n  return s.users.find((u) => u.email.toLowerCase() === email.toLowerCase()) || null;\n}\n\nexport function upsertUser(user: Omit<StoredUser, \"createdAt\"> & { createdAt?: string }) {\n  const s = load();\n  const existingIdx = s.users.findIndex((u) => u.id === user.id);\n  const existing = existingIdx >= 0 ? s.users[existingIdx] : null;\n  const record: StoredUser = {\n    ...user,\n    entitlements: Array.isArray(user.entitlements) && user.entitlements.length ? user.entitlements : [\"free\"],\n    entitlementSource: user.entitlementSource || \"default\",\n    createdAt: user.createdAt || new Date().toISOString(),\n    lastLoginAt: user.lastLoginAt !== undefined ? user.lastLoginAt : existing?.lastLoginAt ?? null,\n    tier: user.tier || existing?.tier || \"registered\",\n    consent: {\n      termsAcceptedAt:\n        user.consent?.termsAcceptedAt !== undefined ? user.consent?.termsAcceptedAt : existing?.consent?.termsAcceptedAt ?? null,\n      privacyAcceptedAt:\n        user.consent?.privacyAcceptedAt !== undefined ? user.consent?.privacyAcceptedAt : existing?.consent?.privacyAcceptedAt ?? null,\n      cpdDataUseAcceptedAt:\n        user.consent?.cpdDataUseAcceptedAt !== undefined ? user.consent?.cpdDataUseAcceptedAt : existing?.consent?.cpdDataUseAcceptedAt ?? null,\n    },\n  };\n  if (existingIdx >= 0) s.users[existingIdx] = record;\n  else s.users.push(record);\n  save(s);\n  return record;\n}\n\nexport function updateUserConsent(params: {\n  userId: string;\n  termsAccepted: boolean;\n  privacyAccepted: boolean;\n  cpdDataUseAccepted: boolean;\n}) {\n  const s = load();\n  const idx = s.users.findIndex((u) => u.id === params.userId);\n  if (idx < 0) return null;\n  const now = new Date().toISOString();\n  const existing = s.users[idx];\n  const consent = existing.consent || {};\n  s.users[idx] = {\n    ...existing,\n    consent: {\n      termsAcceptedAt: params.termsAccepted ? consent.termsAcceptedAt || now : null,\n      privacyAcceptedAt: params.privacyAccepted ? consent.privacyAcceptedAt || now : null,\n      cpdDataUseAcceptedAt: params.cpdDataUseAccepted ? consent.cpdDataUseAcceptedAt || now : null,\n    },\n  };\n  save(s);\n  return s.users[idx];\n}\n\nexport function deleteUser(id: string) {\n  const s = load();\n  s.users = s.users.filter((u) => u.id !== id);\n  s.accounts = s.accounts.filter((a) => a.userId !== id);\n  s.sessions = s.sessions.filter((sess) => sess.userId !== id);\n  delete s.cpdState[id];\n  save(s);\n}\n\nexport function linkAccount(account: Omit<StoredAccount, \"id\">) {\n  const s = load();\n  const record: StoredAccount = { id: createId(), ...account };\n  // Ensure uniqueness by provider/providerAccountId\n  s.accounts = s.accounts.filter(\n    (a) => !(a.provider === record.provider && a.providerAccountId === record.providerAccountId)\n  );\n  s.accounts.push(record);\n  save(s);\n  return record;\n}\n\nexport function unlinkAccount(provider: string, providerAccountId: string) {\n  const s = load();\n  s.accounts = s.accounts.filter((a) => !(a.provider === provider && a.providerAccountId === providerAccountId));\n  save(s);\n}\n\nexport function getUserByAccount(provider: string, providerAccountId: string) {\n  const s = load();\n  const acct = s.accounts.find((a) => a.provider === provider && a.providerAccountId === providerAccountId);\n  if (!acct) return null;\n  return s.users.find((u) => u.id === acct.userId) || null;\n}\n\nexport function createSession(session: Omit<StoredSession, \"id\">) {\n  const s = load();\n  const record: StoredSession = { id: createId(), ...session };\n  s.sessions.push(record);\n  save(s);\n  return record;\n}\n\nexport function getSessionAndUser(sessionToken: string) {\n  const s = load();\n  const sess = s.sessions.find((x) => x.sessionToken === sessionToken);\n  if (!sess) return null;\n  const user = s.users.find((u) => u.id === sess.userId);\n  if (!user) return null;\n  return { session: sess, user };\n}\n\nexport function updateSession(sessionToken: string, patch: Partial<Pick<StoredSession, \"expires\">>) {\n  const s = load();\n  const idx = s.sessions.findIndex((x) => x.sessionToken === sessionToken);\n  if (idx < 0) return null;\n  s.sessions[idx] = { ...s.sessions[idx], ...patch };\n  save(s);\n  return s.sessions[idx];\n}\n\nexport function deleteSession(sessionToken: string) {\n  const s = load();\n  s.sessions = s.sessions.filter((x) => x.sessionToken !== sessionToken);\n  save(s);\n}\n\nexport function createVerificationToken(token: StoredVerificationToken) {\n  const s = load();\n  s.verificationTokens.push(token);\n  save(s);\n  return token;\n}\n\nexport function useVerificationToken(identifier: string, token: string) {\n  const s = load();\n  const idx = s.verificationTokens.findIndex((t) => t.identifier === identifier && t.token === token);\n  if (idx < 0) return null;\n  const record = s.verificationTokens[idx];\n  s.verificationTokens.splice(idx, 1);\n  save(s);\n  return record;\n}\n\nexport function getCpdState(userId: string) {\n  const s = load();\n  return s.cpdState[userId] || null;\n}\n\nexport function setCpdState(userId: string, stateJson: string) {\n  const s = load();\n  s.cpdState[userId] = { stateJson, updatedAt: new Date().toISOString() };\n  save(s);\n  return s.cpdState[userId];\n}\n\n\n","import fs from \"fs\";\nimport path from \"path\";\n\nfunction ensureDir(filePath: string) {\n  const dir = path.dirname(filePath);\n  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n}\n\nexport function readJsonFile<T>(filePath: string, fallback: T): T {\n  try {\n    const abs = path.isAbsolute(filePath) ? filePath : path.join(process.cwd(), filePath);\n    if (!fs.existsSync(abs)) return fallback;\n    const raw = fs.readFileSync(abs, \"utf8\");\n    return JSON.parse(raw) as T;\n  } catch {\n    return fallback;\n  }\n}\n\nexport function writeJsonFile<T>(filePath: string, value: T) {\n  const abs = path.isAbsolute(filePath) ? filePath : path.join(process.cwd(), filePath);\n  ensureDir(abs);\n  const tmp = `${abs}.tmp`;\n  fs.writeFileSync(tmp, JSON.stringify(value, null, 2), \"utf8\");\n  fs.renameSync(tmp, abs);\n}\n\n\n","import type { Adapter } from \"next-auth/adapters\";\nimport {\n  createId,\n  createSession as storeCreateSession,\n  createVerificationToken as storeCreateVerificationToken,\n  deleteSession as storeDeleteSession,\n  deleteUser as storeDeleteUser,\n  getSessionAndUser as storeGetSessionAndUser,\n  getUserByAccount as storeGetUserByAccount,\n  getUserByEmail as storeGetUserByEmail,\n  getUserById as storeGetUserById,\n  linkAccount as storeLinkAccount,\n  unlinkAccount as storeUnlinkAccount,\n  updateSession as storeUpdateSession,\n  upsertUser as storeUpsertUser,\n  useVerificationToken as storeUseVerificationToken,\n} from \"@/lib/auth/store\";\n\n// Minimal NextAuth adapter using better-sqlite3 (no Prisma).\n// Keeps identity server-side and avoids passwords (magic link + OAuth only).\n\nexport function BetterSqlite3Adapter(): Adapter {\n  const nowIso = () => new Date().toISOString();\n\n  return {\n    async createUser(user) {\n      const id = user.id || createId();\n      storeUpsertUser({\n        id,\n        email: user.email,\n        emailVerified: user.emailVerified ? new Date(user.emailVerified).toISOString() : null,\n        name: user.name || null,\n        image: user.image || null,\n        provider: (user as any).provider || null,\n        entitlements: [\"free\"],\n        entitlementSource: \"default\",\n        createdAt: nowIso(),\n        lastLoginAt: nowIso(),\n        tier: \"registered\",\n        consent: { termsAcceptedAt: null, privacyAcceptedAt: null, cpdDataUseAcceptedAt: null },\n      });\n      return { ...user, id };\n    },\n\n    async getUser(id) {\n      const row = storeGetUserById(id);\n      if (!row) return null;\n      return { id: row.id, email: row.email, emailVerified: row.emailVerified ? new Date(row.emailVerified) : null, name: row.name, image: row.image } as any;\n    },\n\n    async getUserByEmail(email) {\n      const row = storeGetUserByEmail(email);\n      if (!row) return null;\n      return { id: row.id, email: row.email, emailVerified: row.emailVerified ? new Date(row.emailVerified) : null, name: row.name, image: row.image } as any;\n    },\n\n    async getUserByAccount({ provider, providerAccountId }) {\n      const row = storeGetUserByAccount(provider, providerAccountId);\n      if (!row) return null;\n      return { id: row.id, email: row.email, emailVerified: row.emailVerified ? new Date(row.emailVerified) : null, name: row.name, image: row.image } as any;\n    },\n\n    async updateUser(user) {\n      const existing = storeGetUserById(user.id);\n      if (!existing) return user as any;\n      const updated = storeUpsertUser({\n        id: user.id,\n        email: (user as any).email ?? existing.email,\n        emailVerified:\n          (user as any).emailVerified !== undefined\n            ? (user as any).emailVerified\n              ? new Date((user as any).emailVerified).toISOString()\n              : null\n            : existing.emailVerified,\n        name: (user as any).name !== undefined ? (user as any).name : existing.name,\n        image: (user as any).image !== undefined ? (user as any).image : existing.image,\n        provider: existing.provider,\n        entitlements: Array.isArray((existing as any).entitlements) && (existing as any).entitlements.length ? (existing as any).entitlements : [\"free\"],\n        entitlementSource: (existing as any).entitlementSource || \"default\",\n        createdAt: existing.createdAt,\n        lastLoginAt: (existing as any).lastLoginAt ?? null,\n        tier: (existing as any).tier || \"registered\",\n        consent: (existing as any).consent || { termsAcceptedAt: null, privacyAcceptedAt: null, cpdDataUseAcceptedAt: null },\n      });\n      return { id: updated.id, email: updated.email, emailVerified: updated.emailVerified ? new Date(updated.emailVerified) : null, name: updated.name, image: updated.image } as any;\n    },\n\n    async deleteUser(userId) {\n      storeDeleteUser(userId);\n    },\n\n    async linkAccount(account) {\n      const rec = storeLinkAccount({\n        userId: account.userId,\n        type: account.type,\n        provider: account.provider,\n        providerAccountId: account.providerAccountId,\n        refresh_token: account.refresh_token || null,\n        access_token: account.access_token || null,\n        expires_at: account.expires_at || null,\n        token_type: account.token_type || null,\n        scope: account.scope || null,\n        id_token: account.id_token || null,\n        session_state: account.session_state || null,\n      });\n      return { ...account, id: rec.id } as any;\n    },\n\n    async unlinkAccount({ provider, providerAccountId }) {\n      storeUnlinkAccount(provider, providerAccountId);\n    },\n\n    async createSession(session) {\n      const rec = storeCreateSession({\n        sessionToken: session.sessionToken,\n        userId: session.userId,\n        expires: session.expires.toISOString(),\n      });\n      return { sessionToken: rec.sessionToken, userId: rec.userId, expires: new Date(rec.expires) } as any;\n    },\n\n    async getSessionAndUser(sessionToken) {\n      const result = storeGetSessionAndUser(sessionToken);\n      if (!result) return null;\n      const { session, user } = result;\n      return {\n        session: { sessionToken: session.sessionToken, userId: session.userId, expires: new Date(session.expires) },\n        user: {\n          id: user.id,\n          email: user.email,\n          emailVerified: user.emailVerified ? new Date(user.emailVerified) : null,\n          name: user.name,\n          image: user.image,\n        },\n      } as any;\n    },\n\n    async updateSession(session) {\n      const updated = storeUpdateSession(session.sessionToken, {\n        expires: session.expires ? session.expires.toISOString() : undefined,\n      });\n      if (!updated) return null;\n      return { sessionToken: updated.sessionToken, userId: updated.userId, expires: new Date(updated.expires) } as any;\n    },\n\n    async deleteSession(sessionToken) {\n      storeDeleteSession(sessionToken);\n    },\n\n    async createVerificationToken(token) {\n      return storeCreateVerificationToken({\n        identifier: token.identifier,\n        token: token.token,\n        expires: token.expires.toISOString(),\n      }) as any;\n    },\n\n    async useVerificationToken({ identifier, token }) {\n      const row = storeUseVerificationToken(identifier, token);\n      if (!row) return null;\n      return { identifier: row.identifier, token: row.token, expires: new Date(row.expires) } as any;\n    },\n  };\n}\n\n\n","import { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth/options\";\nimport { PLANS, type FeatureKey, type PlanKey } from \"@/lib/billing/plans\";\nimport { getUserById } from \"@/lib/auth/store\";\nimport { getUserPlanRecord } from \"@/lib/billing/store\";\nimport { getTestingOverrideDecision, TESTING_MODE_ENABLED } from \"@/lib/testingMode\";\n\nexport type SafePlanSummary = {\n  plan: PlanKey;\n  features: FeatureKey[];\n  limits: (typeof PLANS)[PlanKey][\"limits\"];\n};\n\nexport async function getUserPlan(userId: string): Promise<PlanKey> {\n  // Temporary QA override: treat all users as pro so everything is reachable for testing.\n  if (getTestingOverrideDecision().allowed || TESTING_MODE_ENABLED) return \"pro\";\n\n  const explicit = getUserPlanRecord(userId);\n  if (explicit?.plan) return explicit.plan;\n\n  const user = getUserById(userId);\n  const entitlements = Array.isArray((user as any)?.entitlements) ? ((user as any).entitlements as string[]) : [\"free\"];\n  if (entitlements.includes(\"commercial\")) return \"pro\";\n  if (entitlements.includes(\"supporter\")) return \"supporter\";\n  return \"free\";\n}\n\nexport function hasFeature(plan: PlanKey, feature: FeatureKey) {\n  if (getTestingOverrideDecision().allowed || TESTING_MODE_ENABLED) return true;\n  return PLANS[plan].features.includes(feature);\n}\n\nexport async function getSafePlanSummaryForRequest() {\n  if (getTestingOverrideDecision().allowed || TESTING_MODE_ENABLED) {\n    return { plan: \"pro\", features: PLANS.pro.features, limits: PLANS.pro.limits } satisfies SafePlanSummary;\n  }\n  const session = await getServerSession(authOptions);\n  if (!session?.user?.id) return { plan: \"free\", features: [], limits: PLANS.free.limits } satisfies SafePlanSummary;\n  const plan = await getUserPlan(session.user.id);\n  return { plan, features: PLANS[plan].features, limits: PLANS[plan].limits } satisfies SafePlanSummary;\n}\n\nexport async function assertFeatureOrThrow(feature: FeatureKey) {\n  if (getTestingOverrideDecision().allowed || TESTING_MODE_ENABLED) {\n    const session = await getServerSession(authOptions);\n    return { userId: session?.user?.id || \"testing\", plan: \"pro\" as const };\n  }\n  const session = await getServerSession(authOptions);\n  if (!session?.user?.id) {\n    const err = new Error(\"Authentication required\");\n    (err as any).status = 401;\n    throw err;\n  }\n  const plan = await getUserPlan(session.user.id);\n  if (!hasFeature(plan, feature)) {\n    const err = new Error(\"Upgrade required\");\n    (err as any).status = 403;\n    (err as any).plan = plan;\n    (err as any).feature = feature;\n    throw err;\n  }\n  return { userId: session.user.id, plan };\n}\n\nexport function getRateLimitConfig(plan: PlanKey) {\n  const limits = PLANS[plan].limits;\n  return {\n    monthlyCredits: limits.monthlyCredits,\n    dailyCreditCap: limits.dailyCreditCap,\n    maxUploadBytes: limits.maxUploadBytes,\n    maxExportsPerDay: limits.maxExportsPerDay,\n  };\n}\n\n\n","export type PlanKey = \"free\" | \"supporter\" | \"pro\";\n\nexport type FeatureKey =\n  | \"templates_download\"\n  | \"history_export\"\n  | \"advanced_dashboards\"\n  | \"larger_limits\"\n  | \"reports_export\"\n  | \"cpd_evidence_export\"\n  | \"early_access\"\n  | \"api_access\"\n  | \"webhooks\";\n\nexport type UsageLimits = {\n  maxUploadBytes: number;\n  maxExportsPerDay: number;\n  // Credit-based limits (replaces maxToolRunsPerDay)\n  monthlyCredits: number;\n  dailyCreditCap: number;\n};\n\nexport type Plan = {\n  key: PlanKey;\n  label: string;\n  description: string;\n  features: FeatureKey[];\n  limits: UsageLimits;\n};\n\n// Single source of truth for product ladder.\n// Keep limits as constants so they can be tuned later without chasing usage logic across the codebase.\nexport const PLANS: Record<PlanKey, Plan> = {\n  free: {\n    key: \"free\",\n    label: \"Free\",\n    description: \"Small monthly bundle, hard daily cap, no rollovers. Enough to taste, not enough to farm.\",\n    features: [],\n    limits: {\n      maxUploadBytes: 1_000_000, // 1 MB\n      maxExportsPerDay: 3,\n      monthlyCredits: 300, // 300 credits/month\n      dailyCreditCap: 30, // Max 30 credits/day\n    },\n  },\n  supporter: {\n    key: \"supporter\",\n    label: \"Supporter\",\n    description: \"Aimed at learners and hobbyists. Higher limits and basic cloud save.\",\n    features: [\"advanced_dashboards\", \"larger_limits\"],\n    limits: {\n      maxUploadBytes: 20_000_000, // 20 MB\n      maxExportsPerDay: 25,\n      monthlyCredits: 3_000, // 3,000 credits/month\n      dailyCreditCap: 300, // Max 300 credits/day\n    },\n  },\n  pro: {\n    key: \"pro\",\n    label: \"Professional\",\n    description: \"Aimed at serious builders. API access, webhooks, and higher concurrency.\",\n    features: [\n      \"templates_download\",\n      \"history_export\",\n      \"reports_export\",\n      \"cpd_evidence_export\",\n      \"early_access\",\n      \"advanced_dashboards\",\n      \"larger_limits\",\n      \"api_access\",\n      \"webhooks\",\n    ],\n    limits: {\n      maxUploadBytes: 100_000_000, // 100 MB\n      maxExportsPerDay: 100,\n      monthlyCredits: 12_000, // 12,000 credits/month\n      dailyCreditCap: 2_000, // Max 2,000 credits/day\n    },\n  },\n};\n\n// Credit top-up packs\nexport const CREDIT_PACKS = [\n  { id: \"starter\", label: \"Starter\", price: 10, credits: 500, pricePerCredit: 0.02 },\n  { id: \"standard\", label: \"Standard\", price: 25, credits: 1_400, pricePerCredit: 0.0179 }, // 10% bulk discount\n  { id: \"professional\", label: \"Professional\", price: 50, credits: 3_000, pricePerCredit: 0.0167 }, // 17% bulk discount\n] as const;\n\n// Public credit price (per credit)\nexport const CREDIT_PRICE = 0.02; // £0.02 per credit\n\nexport function planRank(plan: PlanKey) {\n  if (plan === \"pro\") return 3;\n  if (plan === \"supporter\") return 2;\n  return 1;\n}\n\n\n","import { readJsonFile, writeJsonFile } from \"@/lib/storage/jsonFile\";\n\nexport type UserPlanRecord = {\n  userId: string;\n  plan: \"free\" | \"supporter\" | \"pro\";\n  source: \"default\" | \"donation\" | \"manual\" | \"future\";\n  updatedAt: string;\n};\n\nexport type ToolRunRecord = {\n  id: string;\n  userId?: string | null;\n  anonymousUserId?: string | null;\n  toolId: string;\n  timestamp: string;\n  metadata?: Record<string, unknown>;\n};\n\nexport type TemplateDownloadRecord = {\n  id: string;\n  userId?: string | null;\n  anonymousUserId?: string | null;\n  templateId: string;\n  licenseChoice: \"internal_use\" | \"commercial_use\";\n  signaturePolicyApplied: \"kept\" | \"removed\";\n  timestamp: string;\n  metadata?: Record<string, unknown>;\n};\n\ntype BillingStore = {\n  userPlans: UserPlanRecord[];\n  toolRuns: ToolRunRecord[];\n  templateDownloads: TemplateDownloadRecord[];\n  donations: Array<{\n    id: string;\n    stripeEventId: string;\n    stripeSessionId?: string | null;\n    stripePaymentIntentId?: string | null;\n    amount: number;\n    currency: string;\n    status: \"paid\" | \"failed\";\n    userId?: string | null;\n    createdAt: string;\n  }>;\n};\n\nconst STORE_PATH = process.env.BILLING_STORE_PATH || \"data/billing-store.json\";\nconst empty: BillingStore = { userPlans: [], toolRuns: [], templateDownloads: [], donations: [] };\n\nfunction load() {\n  return readJsonFile<BillingStore>(STORE_PATH, empty);\n}\n\nfunction save(store: BillingStore) {\n  writeJsonFile(STORE_PATH, store);\n}\n\nexport function upsertUserPlan(record: UserPlanRecord) {\n  const s = load();\n  s.userPlans = s.userPlans.filter((p) => p.userId !== record.userId);\n  s.userPlans.push(record);\n  save(s);\n  return record;\n}\n\nexport function getUserPlanRecord(userId: string) {\n  const s = load();\n  return s.userPlans.find((p) => p.userId === userId) || null;\n}\n\nexport function addToolRun(record: ToolRunRecord) {\n  const s = load();\n  s.toolRuns.push({\n    ...record,\n    userId: record.userId || null,\n    anonymousUserId: record.anonymousUserId || null,\n  });\n  save(s);\n  return record;\n}\n\nexport function listToolRuns(filters: { userId?: string | null; anonymousUserId?: string | null } = {}, limit = 50) {\n  const s = load();\n  return [...s.toolRuns]\n    .filter((r) => (filters.userId ? r.userId === filters.userId : true))\n    .filter((r) => (filters.anonymousUserId ? r.anonymousUserId === filters.anonymousUserId : true))\n    .sort((a, b) => (b.timestamp || \"\").localeCompare(a.timestamp || \"\"))\n    .slice(0, limit);\n}\n\nexport function countToolRunsSince(filters: { userId?: string | null; anonymousUserId?: string | null }, sinceIso: string) {\n  const s = load();\n  return s.toolRuns.filter((r) => (filters.userId ? r.userId === filters.userId : true))\n    .filter((r) => (filters.anonymousUserId ? r.anonymousUserId === filters.anonymousUserId : true))\n    .filter((r) => (r.timestamp || \"\") >= sinceIso).length;\n}\n\nexport function addTemplateDownload(record: TemplateDownloadRecord) {\n  const s = load();\n  s.templateDownloads.push({\n    ...record,\n    userId: record.userId || null,\n    anonymousUserId: record.anonymousUserId || null,\n  });\n  save(s);\n  return record;\n}\n\nexport function listTemplateDownloads(filters: { userId?: string | null; anonymousUserId?: string | null } = {}, limit = 50) {\n  const s = load();\n  return [...s.templateDownloads]\n    .filter((r) => (filters.userId ? r.userId === filters.userId : true))\n    .filter((r) => (filters.anonymousUserId ? r.anonymousUserId === filters.anonymousUserId : true))\n    .sort((a, b) => (b.timestamp || \"\").localeCompare(a.timestamp || \"\"))\n    .slice(0, limit);\n}\n\nexport function addDonation(record: BillingStore[\"donations\"][number]) {\n  const s = load();\n  const exists = s.donations.some((d) => d.stripeEventId === record.stripeEventId);\n  if (!exists) {\n    s.donations.push({\n      ...record,\n      userId: record.userId || null,\n      stripeSessionId: record.stripeSessionId || null,\n      stripePaymentIntentId: record.stripePaymentIntentId || null,\n    });\n    save(s);\n  }\n  return record;\n}\n\nexport function deleteUserBillingData(userId: string) {\n  const s = load();\n  s.userPlans = s.userPlans.filter((p) => p.userId !== userId);\n  s.toolRuns = s.toolRuns.filter((r) => r.userId !== userId);\n  s.templateDownloads = s.templateDownloads.filter((r) => r.userId !== userId);\n  s.donations = s.donations.filter((d) => d.userId !== userId);\n  save(s);\n}\n\n\n","/**\n * Temporary testing override.\n *\n * When enabled, access checks should treat everything as \"allowed\" so the site can be QA tested\n * on preview/prod environments without deleting or weakening the underlying access model.\n *\n * Turn off by removing the env var or setting it to \"false\".\n */\nexport const TESTING_MODE_ENABLED =\n  process.env.NEXT_PUBLIC_TESTING_MODE === \"true\";\n\nexport type TestingOverrideDecision =\n  | { allowed: true; reason: \"testing-mode\" }\n  | { allowed: false; reason: \"disabled\" };\n\n/**\n * Single source of truth for the temporary QA/testing override.\n * Do not fake roles or delete access logic — just return early when enabled.\n */\nexport function getTestingOverrideDecision(): TestingOverrideDecision {\n  if (process.env.NEXT_PUBLIC_TESTING_MODE === \"true\") {\n    return { allowed: true, reason: \"testing-mode\" };\n  }\n  return { allowed: false, reason: \"disabled\" };\n}\n\n\n\n","import { PrismaClient } from \"@prisma/client\";\n\n// Default DB for local dev when env is missing.\n// This keeps local dev lightweight and avoids \"silent\" runtime failures.\nif (!process.env.DATABASE_URL) {\n  process.env.DATABASE_URL = \"file:./data/dev.db\";\n}\n\ndeclare global {\n  var __prisma: PrismaClient | undefined;\n}\n\nexport const prisma: PrismaClient =\n  global.__prisma ||\n  new PrismaClient({\n    log: [\"error\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") {\n  global.__prisma = prisma;\n}\n\n\n","import { prisma } from \"@/lib/db/prisma\";\n\n// Progress persistence rules:\n// - Anonymous users: local-only (handled in client hook; server endpoints require auth)\n// - Signed-in users: server is source of truth for cross-device persistence\n\nexport async function upsertUserIdentity(params: {\n  userId: string;\n  email: string;\n  provider: string;\n  providerAccountId: string;\n}) {\n  const email = params.email.trim().toLowerCase();\n  if (!email) return null;\n  return prisma.userIdentity.upsert({\n    where: { id: params.userId },\n    create: {\n      id: params.userId,\n      email,\n      provider: params.provider,\n      providerAccountId: params.providerAccountId,\n      lastLoginAt: new Date(),\n    },\n    update: {\n      provider: params.provider,\n      providerAccountId: params.providerAccountId,\n      lastLoginAt: new Date(),\n    },\n  });\n}\n\nexport async function getCpdStateForUser(userId: string) {\n  const row = await prisma.cpdState.findUnique({ where: { userId } });\n  return row ? { stateJson: row.stateJson, updatedAt: row.updatedAt.toISOString() } : null;\n}\n\nexport async function setCpdStateForUser(params: { userId: string; stateJson: string }) {\n  const saved = await prisma.cpdState.upsert({\n    where: { userId: params.userId },\n    create: { userId: params.userId, stateJson: params.stateJson },\n    update: { stateJson: params.stateJson },\n  });\n\n  // Maintain per-section progress rows as a foundation for future CPD evidence/export.\n  // This is derived data: the canonical state is the CPD JSON.\n  try {\n    const state = JSON.parse(params.stateJson);\n    const sections = Array.isArray(state?.sections) ? state.sections : [];\n\n    const writes = sections\n      .filter((s: any) => s && typeof s === \"object\")\n      .filter((s: any) => s.sectionId && s.sectionId !== \"overall\")\n      .map((s: any) => ({\n        courseId: String(s.trackId || \"\").trim(),\n        levelId: String(s.levelId || \"\").trim(),\n        sectionId: String(s.sectionId || \"\").trim(),\n        completed: Boolean(s.completed),\n        minutes: Math.max(0, Number(s.minutes) || 0),\n      }))\n      .filter((s: any) => s.courseId && s.levelId && s.sectionId);\n\n    // Upsert each progress row (idempotent per unique key).\n    await Promise.all(\n      writes.map((w: any) =>\n        prisma.progress.upsert({\n          where: {\n            userId_courseId_levelId_sectionId: {\n              userId: params.userId,\n              courseId: w.courseId,\n              levelId: w.levelId,\n              sectionId: w.sectionId,\n            },\n          },\n          create: { userId: params.userId, ...w },\n          update: { completed: w.completed, minutes: w.minutes },\n        }),\n      ),\n    );\n  } catch {\n    // Do not fail persistence if derived progress rows cannot be updated.\n  }\n\n  return { updatedAt: saved.updatedAt.toISOString() };\n}\n\nexport async function getAdminProgressStats() {\n  const totalUsers = await prisma.userIdentity.count();\n  const totalProgressRecords = await prisma.progress.count();\n  const since = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n  const activeUsers = await prisma.userIdentity.count({ where: { lastLoginAt: { gte: since } } });\n  return { totalUsers, activeUsersLast7Days: activeUsers, totalProgressRecords };\n}\n\n\n","export const ADMIN_ROLES = [\"OWNER\", \"ADMIN\", \"SUPPORT\", \"READ_ONLY\"] as const;\nexport type AdminRole = (typeof ADMIN_ROLES)[number];\n\nexport function isAdminRole(value: unknown): value is AdminRole {\n  return typeof value === \"string\" && (ADMIN_ROLES as readonly string[]).includes(value);\n}\n\nexport const ADMIN_PERMISSIONS = [\n  \"VIEW_USERS\",\n  \"MANAGE_USERS\",\n  \"VIEW_SUPPORT\",\n  \"MANAGE_SUPPORT\",\n  \"VIEW_BILLING\",\n  \"MANAGE_BILLING\",\n  \"VIEW_SYSTEM\",\n  \"MANAGE_SYSTEM\",\n] as const;\n\nexport type AdminPermission = (typeof ADMIN_PERMISSIONS)[number];\n\ntype RolePermissions = Record<AdminRole, readonly AdminPermission[]>;\n\nexport const ROLE_PERMISSIONS: RolePermissions = {\n  OWNER: ADMIN_PERMISSIONS,\n  ADMIN: [\"VIEW_USERS\", \"MANAGE_USERS\", \"VIEW_SUPPORT\", \"MANAGE_SUPPORT\", \"VIEW_BILLING\", \"VIEW_SYSTEM\", \"MANAGE_SYSTEM\"],\n  SUPPORT: [\"VIEW_USERS\", \"VIEW_SUPPORT\", \"MANAGE_SUPPORT\", \"VIEW_SYSTEM\"],\n  READ_ONLY: [\"VIEW_USERS\", \"VIEW_SUPPORT\", \"VIEW_BILLING\", \"VIEW_SYSTEM\"],\n} as const;\n\nfunction parseEmailList(raw: string | undefined) {\n  return (raw || \"\")\n    .split(\",\")\n    .map((s) => s.trim().toLowerCase())\n    .filter(Boolean);\n}\n\nexport function getAdminRole(user?: { email?: string | null } | null): AdminRole | null {\n  const explicitRole = (user as any)?.adminRole;\n  if (isAdminRole(explicitRole)) return explicitRole;\n\n  const email = (user?.email || \"\").trim().toLowerCase();\n  if (!email) return null;\n\n  // Environment-based role mapping (extensible, no client exposure).\n  // Comma-separated lists:\n  // - ADMIN_OWNER_EMAILS\n  // - ADMIN_ADMIN_EMAILS\n  // - ADMIN_SUPPORT_EMAILS\n  // - ADMIN_READ_ONLY_EMAILS\n  const owners = parseEmailList(process.env.ADMIN_OWNER_EMAILS);\n  const admins = parseEmailList(process.env.ADMIN_ADMIN_EMAILS);\n  const support = parseEmailList(process.env.ADMIN_SUPPORT_EMAILS);\n  const readOnly = parseEmailList(process.env.ADMIN_READ_ONLY_EMAILS);\n\n  if (owners.includes(email)) return \"OWNER\";\n  if (admins.includes(email)) return \"ADMIN\";\n  if (support.includes(email)) return \"SUPPORT\";\n  if (readOnly.includes(email)) return \"READ_ONLY\";\n\n  // Backward-compatible escape hatch for early deployments.\n  const legacyOwner = (process.env.ADMIN_EMAIL || \"sageransity@icloud.com\").trim().toLowerCase();\n  if (email === legacyOwner) return \"OWNER\";\n\n  return null;\n}\n\nexport function hasPermission(role: AdminRole, permission: AdminPermission) {\n  const perms = ROLE_PERMISSIONS[role] || [];\n  return perms.includes(permission);\n}\n\nexport class AdminPermissionError extends Error {\n  status = 403 as const;\n  code = \"ADMIN_FORBIDDEN\" as const;\n  constructor(message = \"Access denied\") {\n    super(message);\n  }\n}\n\n/**\n * Server-side RBAC gate.\n * Fail closed: if role is missing or permission is not granted, throw.\n *\n * Step-up auth placeholder:\n * - In future, enforce recent authentication or additional verification here (MFA).\n * - For now, this is intentionally a stub to avoid refactors later.\n */\nexport function requireAdminPermission(\n  user: { id?: string | null; email?: string | null } | null | undefined,\n  permission: AdminPermission\n) {\n  const role = getAdminRole(user);\n  if (!role) throw new AdminPermissionError(\"Access denied\");\n  if (!hasPermission(role, permission)) throw new AdminPermissionError(\"Access denied\");\n\n  // Step-up auth placeholder:\n  // if (permission === \"MANAGE_BILLING\") { enforceStepUp(user) }\n\n  return { role };\n}\n\n\n"],"names":[],"mappings":"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"}}]
}