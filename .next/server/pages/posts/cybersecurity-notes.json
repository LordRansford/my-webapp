{"pageProps":{"post":{"slug":"cybersecurity-notes","title":"Cybersecurity notes","date":"2025-02-01T00:00:00.000Z","tags":["cybersecurity","cryptography","hashing"],"excerpt":"A beginner-friendly walkthrough of confidentiality, keys, and hashing with simple exercises.","readingStats":{"text":"7 min read","minutes":6.655,"time":399300,"words":1331},"mdx":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h2: \"h2\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  }, {RsaPlayground, ToolCard} = _components;\n  if (!RsaPlayground) _missingMdxReference(\"RsaPlayground\", true);\n  if (!ToolCard) _missingMdxReference(\"ToolCard\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Security protects three things. Confidentiality. Integrity. Availability. Ask yourself three questions. What must stay secret? What must stay accurate? What must stay online? Those answers guide every control you'll ever build.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I've seen systems break because people forgot one of these. A system that keeps secrets but loses data integrity is useless. A system that's accurate but goes offline when you need it is also useless. You need all three. That's not optional. That's how security works.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"symmetric-encryption\",\n      children: _jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#symmetric-encryption\",\n        children: \"Symmetric encryption\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One shared key locks and unlocks data. That's it. Same key to encrypt, same key to decrypt.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Symmetric encryption is fast. AES is proven. It's what we use when speed matters. But here's the problem. How do you share that key safely? If you send it over email, anyone who intercepts the email has your key. If you store it in a file, anyone who gets the file has your key. The key is the weakest link.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Think of it like a locker code. If someone gets the code, they can open the locker. The lock itself might be perfect, but if the code leaks, privacy is gone.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The math behind symmetric encryption is straightforward. You take your message, mix it with the key using XOR or substitution, and out comes ciphertext. The mixing is reversible if you have the key. Without the key, it looks random.\"\n    }), \"\\n\", _jsx(ToolCard, {\n      title: \"RSA Playground\",\n      description: \"Generate RSA keys and see the math in action. Pick small primes to understand the process, then scale up to see why large primes matter.\",\n      children: _jsx(RsaPlayground, {})\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"asymmetric-encryption\",\n      children: _jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#asymmetric-encryption\",\n        children: \"Asymmetric encryption\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Two keys. A public key to lock. A private key to unlock. Share the public key with everyone. Never share the private key with anyone.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This solves the key exchange problem. You don't need to share a secret beforehand. Anyone can encrypt a message with your public key. Only you can decrypt it with your private key.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RSA is the classic example. Here's how it works mathematically.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Pick two large prime numbers, p and q. Multiply them to get n. That's your modulus. The modulus n equals p times q.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Calculate Euler's totient function, φ(n). For two primes, this is simple. Euler's totient φ(n) equals (p minus 1) times (q minus 1).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Pick a public exponent e. It must be coprime with φ(n), meaning their greatest common divisor is 1. Usually we use 65537. It's fast and safe.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Find the private exponent d. This is the modular inverse of e modulo φ(n). In other words, find d such that.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The product of e and d must equal 1 modulo φ(n).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Your public key is (n, e). Your private key is (n, d). To encrypt a message m, compute.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Ciphertext c equals m to the power of e, modulo n.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To decrypt, compute.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Message m equals c to the power of d, modulo n.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The security comes from the fact that factoring n back into p and q is computationally hard. If someone could factor n, they could calculate φ(n) and find your private key. But for large primes, factoring takes longer than the universe has existed. That's the math that keeps you safe.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Why does this work? Modular arithmetic. When you compute m^e mod n, you're working in a finite set. The result wraps around. This creates a one-way function. Easy to compute forward, hard to reverse without the private key.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The beauty is that the math is public. Everyone knows how RSA works. The security isn't in hiding the algorithm. The security is in the difficulty of factoring large numbers. That's the difference between security through obscurity and security through mathematics.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"hashing-in-practice\",\n      children: _jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#hashing-in-practice\",\n        children: \"Hashing in practice\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A hash turns any input into a fixed-length fingerprint. Change one bit in the input, and the hash changes completely. That's called the avalanche effect.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Hashes are one-way functions. You can't reverse a hash to get the original input. At least, you shouldn't be able to. If you can, the hash function is broken.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here's the math. A hash function H takes an input x of any length and produces an output H(x) of fixed length.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The hash function H applied to input x produces hash h.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Where h is a fixed-length string, usually 256 bits for SHA-256. The function has three properties.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First, it's deterministic. Same input always produces same output. Hash \\\"hello\\\" twice, you get the same result both times.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Second, it's fast to compute. Hashing should be quick. If it's slow, you can't use it for integrity checks or password verification.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Third, it's hard to find collisions. A collision is when two different inputs produce the same hash. If collisions are easy to find, the hash is broken.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The avalanche effect means small changes create large differences. Hash \\\"hello\\\" and hash \\\"Hello\\\" (capital H). The outputs are completely different. This is by design. It makes the hash sensitive to any change.\"\n    }), \"\\n\", _jsx(ToolCard, {\n      title: \"Try the tools\",\n      description: \"Visit the tools page to explore RSA key generation, entropy and hashing, and certificate viewing. See the math in action.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For password storage, you don't store the password. You store the hash of the password plus a salt. A salt is random data added to make each hash unique. Even if two users have the same password, their hashes are different because their salts are different.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When someone logs in, you hash their input password with the stored salt and compare it to the stored hash. If they match, the password is correct. You never store the actual password. If your database leaks, attackers get hashes, not passwords. They'd have to reverse the hash to get the password, which should be computationally infeasible.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"certificates-and-trust\",\n      children: _jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#certificates-and-trust\",\n        children: \"Certificates and trust\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Certificates solve the identity problem. How do you know a public key actually belongs to who you think it belongs to?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A certificate is a signed statement. It says \\\"this public key belongs to this identity.\\\" The signature comes from a certificate authority, someone you trust. If you trust the authority, you trust the certificate.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The math is the same RSA or ECDSA signing. The certificate authority has a private key. They sign the certificate with that key. You verify the signature with their public key. If the signature verifies, the certificate is authentic.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The trust chain is recursive. You trust the root certificate authority. They sign intermediate certificates. Those intermediates sign end-entity certificates. As long as you can verify the chain back to a root you trust, you trust the end certificate.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This breaks if any link in the chain is compromised. If an intermediate CA's private key leaks, attackers can issue fake certificates. That's why key management matters. That's why revocation lists exist. That's why certificate pinning is a thing.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"what-actually-matters\",\n      children: _jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#what-actually-matters\",\n        children: \"What actually matters\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cryptography is math applied to security problems. The math is public. The security comes from computational hardness, not secrecy.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Symmetric encryption is fast but requires key exchange. Asymmetric encryption solves key exchange but is slower. Use symmetric for bulk data, asymmetric for key exchange. That's how TLS works. That's how most systems work.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Hashing provides integrity, not confidentiality. A hash tells you if data changed. It doesn't hide the data. If you need both, encrypt then hash, or use authenticated encryption.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Certificates solve identity, not encryption. They tell you who owns a public key. They don't encrypt anything. Encryption and identity are separate problems that happen to use the same mathematical tools.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The fundamentals are simple. The implementation is where things break. Weak random number generation. Poor key management. Skipped validation. These are the real problems. The math is solid. The execution is what fails.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Understanding these fundamentals helps you evaluate security systems, ask better questions, and make better decisions about when and how to use cryptography. You don't need to become a cryptographer. You just need to understand enough to think clearly about security, ask the right questions, and make informed decisions.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That's the goal. Clear thinking. Better questions. Informed decisions. The math is just the tool.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"Cybersecurity notes","date":"2025-02-01","tags":["cybersecurity","cryptography","hashing"],"excerpt":"A beginner-friendly walkthrough of confidentiality, keys, and hashing with simple exercises."}}}},"__N_SSG":true}