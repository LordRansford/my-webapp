;!function(){try { var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&((e._debugIds|| (e._debugIds={}))[n]="32d3dae6-4078-14b4-7303-edd6dec38687")}catch(e){}}();
(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,704411,237005,496378,177990,592061,223806,248534,111613,527081,320281,744877,27923,546340,35412,240210,566389,994152,121930,861392,310897,661758,720606,254577,804493,329654,312757,63340,792452,494096,612930,879228,536331,167131,680837,449404,119509,240774,990256,860623,919862,760811,246559,548863,419886,461215,26194,33457,370811,410616,568503,638688,998029,953734,889306,85824,e=>{"use strict";let t,r,a;class n{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class s{refCount(e){return i("refCount")}incRef(e){return i("incRef")}timerAvailable(){return!0}time(e){return i("time")}read(e){return i("read")}readSync(e){return i("readSync")}readToGPU(e,t){return i("readToGPU")}numDataIds(){return i("numDataIds")}disposeData(e,t){return i("disposeData")}write(e,t,r){return i("write")}move(e,t,r,a,n){return i("move")}createTensorFromGPUData(e,t,r){return i("createTensorFromGPUData")}memory(){return i("memory")}floatPrecision(){return i("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return i("dispose")}}function i(e){throw Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function o(e){let t=e.length,r=0;for(;t>0;)r=Math.random()*t|0,d(e,--t,r)}function l(e,t){if(e.length!==t.length)throw Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let r=e.length,a=0;for(;r>0;)a=Math.random()*r|0,d(e,--r,a),d(t,r,a)}function u(e,t,r){return Math.max(e,Math.min(t,r))}function p(e){return e%2==0?e:e+1}function d(e,t,r){let a=e[t];e[t]=e[r],e[r]=a}function c(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r];return t}function h(e,t){let r=Math.random();return t*r+(1-r)*e}function m(e,t){let r=0;for(let a=0;a<e.length;a++){let n=Number(e[a])-Number(t[a]);r+=n*n}return r}function f(e,t){if(!e)throw Error("string"==typeof t?t:t())}function g(e,t,r=""){f(N(e,t),()=>r+` Shapes ${e} and ${t} must match`)}function y(e){f(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function b(e){if(0===e.length)return 1;let t=e[0];for(let r=1;r<e.length;r++)t*=e[r];return t}function T(e){return 0===e.length}function v(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(null!==e[r]&&null!==t[r]&&e[r]!==t[r])return!1;return!0}function N(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}function x(e){return e%1==0}function S(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;{if(e===-1/0)return -1;let t=Math.exp(2*e);return(t-1)/(t+1)}}function E(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function w(e){let t=new Uint32Array(e);for(let r=0;r<e;++r)t[r]=r;return o(t),t}function k(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function I(e,t=e=>0,r,a){return new Promise((n,s)=>{let i=0,o=()=>{if(e())return void n();let l=t(++i);null!=r&&i>=r?s():null!=a?a(o,l):setTimeout(o,l)};o()})}function A(e,t){let r=1,a=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)r*=e[t];else if(-1===e[t]){if(-1!==a)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${t}`);a=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===a){if(t>0&&t!==r)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===r)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%r!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${r}`);let n=e.slice();return n[a]=t/r,n}function P(e,t){let r=t.length;return f((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-r&&e<r),()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${e}`),f(e.every(e=>x(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?r+e:e)}function M(e,t){let r=[],a=[],n=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||n?null:P(t,e).sort(),i=0;for(let t=0;t<e.length;++t){if(null!=s){if(s[i]===t&&1!==e[t])throw Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==s[i]||s[i]>t)&&1===e[t]&&(r.push(e[t]),a.push(t)),s[i]<=t&&i++}1!==e[t]&&(r.push(e[t]),a.push(t))}return{newShape:r,keptDims:a}}function _(e,t){return V(e,t)}function V(e,t){let r=null;if(null==e||"float32"===e)r=new Float32Array(t);else if("int32"===e)r=new Int32Array(t);else if("bool"===e)r=new Uint8Array(t);else if("string"===e)r=Array(t);else throw Error(`Unknown data type ${e}`);return r}function D(e,t){for(let r=0;r<e.length;r++){let a=e[r];if(isNaN(a)||!isFinite(a))throw Error(`A tensor of type ${t} being uploaded contains ${a}.`)}}function $(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function O(e,t){return"complex64"!==t&&("float32"!==t||"complex64"===e)&&("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)}function R(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw Error(`Unknown dtype ${e}`)}function F(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}function C(e){return"string"==typeof e||e instanceof String}function B(e){return"boolean"==typeof e}function L(e){return"number"==typeof e}function G(e){if(Array.isArray(e))return G(e[0]);if(e instanceof Float32Array);else if(e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return"int32";else if(L(e));else if(C(e))return"string";else if(B(e))return"bool";return"float32"}function z(e){return!!(e&&e.constructor&&e.call&&e.apply)}function U(e,t){for(let r=t;r<e;++r)if(e%r==0)return r;return e}function q(e){let t=e.length;if(t<2)return[];let r=Array(t-1);r[t-2]=e[t-1];for(let a=t-3;a>=0;--a)r[a]=r[a+1]*e[a+1];return r}function W(e,t,r=!1){if(0===e.length)return t[0];let a=e.reduce((e,t)=>e*t)*(r?2:1);if(0===a)return[];if(a!==t.length)throw Error(`[${e}] does not match the input size ${t.length}${r?" for a complex tensor":""}.`);return function e(t,r,a,n=!1){let s=[];if(1===r.length){let e=r[0]*(n?2:1);for(let r=0;r<e;r++)s[r]=a[t+r]}else{let i=r[0],o=r.slice(1),l=o.reduce((e,t)=>e*t)*(n?2:1);for(let r=0;r<i;r++)s[r]=e(t+r*l,o,a,n)}return s}(0,e,t,r)}function K(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw Error(`Unknown dtype ${t}`)}function H(e,t){let r=j(e,t);for(let e=0;e<r.length;e++)r[e]=1;return r}function j(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw Error(`Unknown data type ${t}`)}function J(e,t){let r=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return W(e,new Float32Array(r));if("int32"===t)return W(e,new Int32Array(r));if("bool"===t)return W(e,new Uint8Array(r));throw Error(`Unknown data type ${t}`)}function Z(e){e.forEach(t=>{f(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function X(e,t,r){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let t=0;t<e.length-1;++t)a+=r[t]*e[t];return a}function Q(e,t,r){if(0===t)return[];if(1===t)return[e];let a=Array(t);for(let t=0;t<a.length-1;++t)a[t]=Math.floor(e/r[t]),e-=a[t]*r[t];return a[a.length-1]=e,a}function Y(e){return e&&e.then&&"function"==typeof e.then}e.s(["DataStorage",()=>n,"KernelBackend",()=>s],237005),e.s(["arraysEqual",()=>N,"arraysEqualWithNull",()=>v,"assert",()=>f,"assertNonNegativeIntegerDimensions",()=>Z,"assertNonNull",()=>y,"assertShapesMatch",()=>g,"bytesFromStringArray",()=>F,"bytesPerElement",()=>R,"checkConversionForErrors",()=>D,"clamp",()=>u,"computeStrides",()=>q,"convertBackendValuesAndArrayBuffer",()=>K,"createShuffledIndices",()=>w,"distSquared",()=>m,"getArrayFromDType",()=>V,"getTypedArrayFromDType",()=>_,"hasEncodingLoss",()=>O,"indexToLoc",()=>Q,"inferDtype",()=>G,"inferFromImplicitShape",()=>A,"isBoolean",()=>B,"isFunction",()=>z,"isInt",()=>x,"isNumber",()=>L,"isPromise",()=>Y,"isScalarShape",()=>T,"isString",()=>C,"isValidDtype",()=>$,"locToIndex",()=>X,"makeOnesTypedArray",()=>H,"makeZerosNestedTypedArray",()=>J,"makeZerosTypedArray",()=>j,"nearestDivisor",()=>U,"nearestLargerEven",()=>p,"parseAxisParam",()=>P,"randUniform",()=>h,"repeatedTry",()=>I,"rightPad",()=>k,"shuffle",()=>o,"shuffleCombo",()=>l,"sizeFromShape",()=>b,"sizeToSquarishShape",()=>E,"squeezeShape",()=>M,"sum",()=>c,"swap",()=>d,"tanh",()=>S,"toNestedArray",()=>W],496378);let ee="tfjsflags";class et{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=er,this.populateURLFlags()}setPlatform(e,t){null==this.platform||en.getBool("IS_TEST")||en.getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},null!=this.urlFlags[e]){let t=this.urlFlags[e];en.getBool("IS_TEST")||en.getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Y(t))throw Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);ee in e&&e[ee].split(",").forEach(e=>{var t;let r,[a,n]=e.split(":");this.urlFlags[a]="true"===(r=(t=n).toLowerCase())||"false"===r?"true"===r:`${+r}`===r?+r:t})}}function er(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>{var a,n,s;return a=t,n=r[0],s=r[1],a[decodeURIComponent(n)]=decodeURIComponent(s||""),r.join("=")}),t}function ea(){return en}let en=null;function es(e){en=e}function ei(){if(null==t){let r;t=r="undefined"!=typeof window?window:e.g}return t}function eo(e,t){let r,a=(null==(r=ei())._tfGlobals&&(r._tfGlobals=new Map),r._tfGlobals);if(a.has(e))return a.get(e);{let r=t();return a.set(e,r),a.get(e)}}e.s(["ENV",()=>en,"Environment",()=>et,"env",()=>ea,"setEnvironmentGlobal",()=>es],177990);let el="Cast",eu="Complex",ep="ComplexAbs",ed="RealDiv",ec="Fill",eh="FloorDiv",em="Identity",ef="Maximum",eg="Multiply",ey="Sqrt",eb="ZerosLike";function eT(...e){en.getBool("IS_TEST")||en.getBool("PROD")||console.warn(...e)}function ev(...e){en.getBool("IS_TEST")||en.getBool("PROD")||console.log(...e)}e.s(["Abs",0,"Abs","Acos",0,"Acos","Acosh",0,"Acosh","Add",0,"Add","AddN",0,"AddN","All",0,"All","Any",0,"Any","ArgMax",0,"ArgMax","ArgMin",0,"ArgMin","Asin",0,"Asin","Asinh",0,"Asinh","Atan",0,"Atan","Atan2",0,"Atan2","Atanh",0,"Atanh","AvgPool",0,"AvgPool","AvgPool3D",0,"AvgPool3D","AvgPool3DGrad",0,"AvgPool3DGrad","AvgPoolGrad",0,"AvgPoolGrad","BatchMatMul",0,"BatchMatMul","BatchToSpaceND",0,"BatchToSpaceND","Bincount",0,"Bincount","BitwiseAnd",0,"BitwiseAnd","BroadcastArgs",0,"BroadcastArgs","BroadcastTo",0,"BroadcastTo","Cast",0,el,"Ceil",0,"Ceil","ClipByValue",0,"ClipByValue","Complex",0,eu,"ComplexAbs",0,ep,"Concat",0,"Concat","Conv2D",0,"Conv2D","Conv2DBackpropFilter",0,"Conv2DBackpropFilter","Conv2DBackpropInput",0,"Conv2DBackpropInput","Conv3D",0,"Conv3D","Conv3DBackpropFilterV2",0,"Conv3DBackpropFilterV2","Conv3DBackpropInputV2",0,"Conv3DBackpropInputV2","Cos",0,"Cos","Cosh",0,"Cosh","CropAndResize",0,"CropAndResize","Cumprod",0,"Cumprod","Cumsum",0,"Cumsum","DenseBincount",0,"DenseBincount","DepthToSpace",0,"DepthToSpace","DepthwiseConv2dNative",0,"DepthwiseConv2dNative","DepthwiseConv2dNativeBackpropFilter",0,"DepthwiseConv2dNativeBackpropFilter","DepthwiseConv2dNativeBackpropInput",0,"DepthwiseConv2dNativeBackpropInput","Diag",0,"Diag","Dilation2D",0,"Dilation2D","Dilation2DBackpropFilter",0,"Dilation2DBackpropFilter","Dilation2DBackpropInput",0,"Dilation2DBackpropInput","Draw",0,"Draw","Einsum",0,"Einsum","Elu",0,"Elu","EluGrad",0,"EluGrad","Equal",0,"Equal","Erf",0,"Erf","Exp",0,"Exp","ExpandDims",0,"ExpandDims","Expm1",0,"Expm1","FFT",0,"FFT","Fill",0,ec,"FlipLeftRight",0,"FlipLeftRight","Floor",0,"Floor","FloorDiv",0,eh,"FromPixels",0,"FromPixels","FusedBatchNorm",0,"FusedBatchNorm","FusedConv2D",0,"FusedConv2D","FusedDepthwiseConv2D",0,"FusedDepthwiseConv2D","GatherNd",0,"GatherNd","GatherV2",0,"GatherV2","Greater",0,"Greater","GreaterEqual",0,"GreaterEqual","IFFT",0,"IFFT","Identity",0,em,"Imag",0,"Imag","IsFinite",0,"IsFinite","IsInf",0,"IsInf","IsNan",0,"IsNan","LRN",0,"LRN","LRNGrad",0,"LRNGrad","LeakyRelu",0,"LeakyRelu","Less",0,"Less","LessEqual",0,"LessEqual","LinSpace",0,"LinSpace","Log",0,"Log","Log1p",0,"Log1p","LogSoftmax",0,"LogSoftmax","LogicalAnd",0,"LogicalAnd","LogicalNot",0,"LogicalNot","LogicalOr",0,"LogicalOr","LogicalXor",0,"LogicalXor","LowerBound",0,"LowerBound","MatrixBandPart",0,"MatrixBandPart","Max",0,"Max","MaxPool",0,"MaxPool","MaxPool3D",0,"MaxPool3D","MaxPool3DGrad",0,"MaxPool3DGrad","MaxPoolGrad",0,"MaxPoolGrad","MaxPoolWithArgmax",0,"MaxPoolWithArgmax","Maximum",0,ef,"Mean",0,"Mean","Min",0,"Min","Minimum",0,"Minimum","MirrorPad",0,"MirrorPad","Mod",0,"Mod","Multinomial",0,"Multinomial","Multiply",0,eg,"Neg",0,"Neg","NonMaxSuppressionV3",0,"NonMaxSuppressionV3","NonMaxSuppressionV4",0,"NonMaxSuppressionV4","NonMaxSuppressionV5",0,"NonMaxSuppressionV5","NotEqual",0,"NotEqual","OneHot",0,"OneHot","OnesLike",0,"OnesLike","Pack",0,"Pack","PadV2",0,"PadV2","Pool",0,"Pool","Pow",0,"Pow","Prelu",0,"Prelu","Prod",0,"Prod","RaggedGather",0,"RaggedGather","RaggedRange",0,"RaggedRange","RaggedTensorToTensor",0,"RaggedTensorToTensor","Range",0,"Range","Real",0,"Real","RealDiv",0,ed,"Reciprocal",0,"Reciprocal","Relu",0,"Relu","Relu6",0,"Relu6","Reshape",0,"Reshape","ResizeBilinear",0,"ResizeBilinear","ResizeBilinearGrad",0,"ResizeBilinearGrad","ResizeNearestNeighbor",0,"ResizeNearestNeighbor","ResizeNearestNeighborGrad",0,"ResizeNearestNeighborGrad","Reverse",0,"Reverse","RotateWithOffset",0,"RotateWithOffset","Round",0,"Round","Rsqrt",0,"Rsqrt","ScatterNd",0,"ScatterNd","SearchSorted",0,"SearchSorted","Select",0,"Select","Selu",0,"Selu","Sigmoid",0,"Sigmoid","Sign",0,"Sign","Sin",0,"Sin","Sinh",0,"Sinh","Slice",0,"Slice","Softmax",0,"Softmax","Softplus",0,"Softplus","SpaceToBatchND",0,"SpaceToBatchND","SparseFillEmptyRows",0,"SparseFillEmptyRows","SparseReshape",0,"SparseReshape","SparseSegmentMean",0,"SparseSegmentMean","SparseSegmentSum",0,"SparseSegmentSum","SparseToDense",0,"SparseToDense","SplitV",0,"SplitV","Sqrt",0,ey,"Square",0,"Square","SquaredDifference",0,"SquaredDifference","StaticRegexReplace",0,"StaticRegexReplace","Step",0,"Step","StridedSlice",0,"StridedSlice","StringNGrams",0,"StringNGrams","StringSplit",0,"StringSplit","StringToHashBucketFast",0,"StringToHashBucketFast","Sub",0,"Sub","Sum",0,"Sum","Tan",0,"Tan","Tanh",0,"Tanh","TensorScatterUpdate",0,"TensorScatterUpdate","Tile",0,"Tile","TopK",0,"TopK","Transform",0,"Transform","Transpose",0,"Transpose","Unique",0,"Unique","Unpack",0,"Unpack","UnsortedSegmentSum",0,"UnsortedSegmentSum","UpperBound",0,"UpperBound","ZerosLike",0,eb,"_FusedMatMul",0,"_FusedMatMul"],592061),e.s(["log",()=>ev,"warn",()=>eT],223806);let eN=eo("kernelRegistry",()=>new Map),ex=eo("gradRegistry",()=>new Map);function eS(e,t){let r=e_(e,t);return eN.get(r)}function eE(e){return ex.get(e)}function ew(e){let t=eN.entries(),r=[];for(;;){let{done:a,value:n}=t.next();if(a)break;let[s,i]=n,[o]=s.split("_");o===e&&r.push(i)}return r}function ek(e){let{kernelName:t,backendName:r}=e,a=e_(t,r);eN.has(a)&&eT(`The kernel '${t}' for backend '${r}' is already registered`),eN.set(a,e)}function eI(e){let{kernelName:t}=e;ex.has(t)&&en.getBool("DEBUG")&&eT(`Overriding the gradient for '${t}'`),ex.set(t,e)}function eA(e,t){let r=e_(e,t);if(!eN.has(r))throw Error(`The kernel '${e}' for backend '${t}' is not registered`);eN.delete(r)}function eP(e){if(!ex.has(e))throw Error(`The gradient '${e}' for backend is not registered`);ex.delete(e)}function eM(e,t){ew(e).forEach(e=>{ek(Object.assign({},e,{backendName:t}))})}function e_(e,t){return`${t}_${e}`}function eV(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function eD(e,t){return"string"===t?eF(e):e$([e],t)}function e$(e,t){var r;if("string"===t)throw Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=eL(e)),en.getBool("DEBUG")&&D(e,t),(r=e)instanceof Float32Array&&"float32"===t||r instanceof Int32Array&&"int32"===t||r instanceof Uint8Array&&"bool"===t)return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let r=0;r<t.length;++r)0!==Math.round(e[r])&&(t[r]=1);return t}throw Error(`Unknown data type ${t}`)}function eO(){return en.platform.now()}function eR(e,t){return en.platform.fetch(e,t)}function eF(e,t="utf-8"){return t=t||"utf-8",en.platform.encode(e,t)}function eC(e,t="utf-8"){return t=t||"utf-8",en.platform.decode(e,t)}function eB(e){return null!=en.platform.isTypedArray?en.platform.isTypedArray(e):eV(e)}function eL(e,t=[],r=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||Y(e)||null==e||eB(e)&&r)t.push(e);else if(Array.isArray(e)||eB(e))for(let a=0;a<e.length;++a)eL(e[a],t,r);else{let a=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(a=Math.max(a,Number(t)));for(let n=0;n<=a;n++)eL(e[n],t,r)}return t}e.s(["copyRegisteredKernels",()=>eM,"getGradient",()=>eE,"getKernel",()=>eS,"getKernelsForBackend",()=>ew,"registerGradient",()=>eI,"registerKernel",()=>ek,"unregisterGradient",()=>eP,"unregisterKernel",()=>eA],248534),e.s(["createScalarValue",()=>eD,"decodeString",()=>eC,"encodeString",()=>eF,"fetch",()=>eR,"flatten",()=>eL,"isTypedArray",()=>eB,"now",()=>eO,"toTypedArray",()=>e$],111613);class eG{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new ez)}profileKernel(e,t,r){let a,n,s=()=>{a=r()},i=eO();if(this.backendTimer.timerAvailable())n=this.backendTimer.time(s);else{for(let e of(s(),a))e.dataSync();n=Promise.resolve({kernelMs:eO()-i})}if(en.getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<a.length;t++){let r=a[t];r.data().then(t=>{!function(e,t,r){if("float32"===t)for(let t=0;t<e.length;t++){let a=e[t];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${r}'`),!0}}(t,r.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:n.then(e=>e.kernelMs),extraInfo:n.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:r,timeMs:a,inputs:n,extraInfo:s}=e;r.forEach(e=>{Promise.all([e.data(),a,s]).then(r=>{this.logger.logKernelProfile(t,e,r[0],r[1],n,r[2])})})}}class ez{logKernelProfile(e,t,r,a,n,s){let i="number"==typeof a?k(`${a}ms`,9):a.error,o=k(e,25),l=t.rank,u=t.size,p=k(t.shape.toString(),14),d="";for(let e in n){let r=n[e];if(null!=r){let a=r.shape||t.shape,n=a.length;d+=`${e}: ${n}D ${n>0?a:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${p}	%c${u}	%c${d}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function eU(e,t,r){return k(Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:C(e)?`'${e}'`:"bool"===r?eq(e):parseFloat(e.toFixed(7)).toString(),t)}function eq(e){return 0===e?"false":"true"}function eW(e){let t=[];for(let r=0;r<e.length;r+=2)t.push([e[r],e[r+1]]);return t}class eK{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=b(e),null!=r){const e=r.length;f(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||V(t,this.size),this.strides=q(e)}set(e,...t){0===t.length&&(t=[0]),f(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let r=this.locToIndex(t);this.values[r]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t])throw Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=this.strides[t]*e[t];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return eH().makeTensor(this.values,this.shape,this.dtype)}}let eH=null,ej=null;function eJ(e){eH=e}function eZ(e){ej=e}function eX(e){}class eQ{constructor(e,t,r,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=b(e),this.strides=q(e),this.dataId=r,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return ej.buffer(this.shape,this.dtype,e)}bufferSync(){return ej.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return W(this.shape,e,"complex64"===this.dtype)}arraySync(){return W(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=eH().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map(e=>eC(e))}catch(e){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),eH().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=eH().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>eC(e))}catch(e){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await eH().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),eH().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw Error("Tensor is disposed.")}print(e=!1){return ej.print(this,e)}clone(){return this.throwIfDisposed(),ej.clone(this)}toString(e=!1){var t,r,a;let n,s,i,o,l;return t=this.dataSync(),r=this.shape,a=this.dtype,n=q(r),s=function(e,t,r,a){let n=b(t),s=a[a.length-1],i=Array(s).fill(0),o=t.length,l="complex64"===r?eW(e):e;if(o>1)for(let e=0;e<n/s;e++){let t=e*s;for(let e=0;e<s;e++)i[e]=Math.max(i[e],eU(l[t+e],0,r).length)}return i}(t,r,a,n),i=r.length,o=function e(t,r,a,n,s,i=!0){let o="complex64"===a?2:1,l=r[0],u=r.length;if(0===u)return"complex64"===a?[eU(eW(t)[0],0,a)]:"bool"===a?[eq(t[0])]:[t[0].toString()];if(1===u){if(l>20){let e=Array.from(t.slice(0,3*o)),r=Array.from(t.slice((l-3)*o,l*o));return"complex64"===a&&(e=eW(e),r=eW(r)),["["+e.map((e,t)=>eU(e,s[t],a)).join(", ")+", ..., "+r.map((e,t)=>eU(e,s[l-3+t],a)).join(", ")+"]"]}return["["+("complex64"===a?eW(t):Array.from(t)).map((e,t)=>eU(e,s[t],a)).join(", ")+"]"]}let p=r.slice(1),d=n.slice(1),c=n[0]*o,h=[];if(l>20){for(let r=0;r<3;r++){let n=r*c,i=n+c;h.push(...e(t.slice(n,i),p,a,d,s,!1))}h.push("...");for(let r=l-3;r<l;r++){let n=r*c,i=n+c;h.push(...e(t.slice(n,i),p,a,d,s,r===l-1))}}else for(let r=0;r<l;r++){let n=r*c,i=n+c;h.push(...e(t.slice(n,i),p,a,d,s,r===l-1))}let m=2===u?",":"";h[0]="["+(l>0?h[0]+m:"");for(let e=1;e<h.length-1;e++)h[e]=" "+h[e]+m;let f=",\n";for(let e=2;e<u;e++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(i?"":f),h}(t,r,a,n,s),l=["Tensor"],e&&(l.push(`  dtype: ${a}`),l.push(`  rank: ${i}`),l.push(`  shape: [${r}]`),l.push("  values:")),l.push(o.map(e=>"    "+e).join("\n")),l.join("\n")}cast(e){return this.throwIfDisposed(),ej.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),eH().makeVariable(this,e,t,r)}}function eY(){return eo("Tensor",()=>eQ)}Object.defineProperty(eQ,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),eY();class e0 extends eQ{constructor(e,t,r,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!N(e.shape,this.shape))throw Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);eH().disposeTensor(this),this.dataId=e.dataId,eH().incRef(this,null)}dispose(){eH().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(e0,Symbol.hasInstance,{value:e=>e instanceof eQ&&null!=e.assign&&e.assign instanceof Function}),e.s(["Tensor",()=>eQ,"TensorBuffer",()=>eK,"Variable",()=>e0,"getGlobalTensorClass",()=>eY,"setDeprecationWarningFn",()=>eX,"setOpHandler",()=>eZ,"setTensorTracker",()=>eJ],527081),(ti=td||(td={})).R0="R0",ti.R1="R1",ti.R2="R2",ti.R3="R3",ti.R4="R4",ti.R5="R5",ti.R6="R6",(to=tc||(tc={})).float32="float32",to.int32="int32",to.bool="int32",to.complex64="complex64",(tl=th||(th={})).float32="float32",tl.int32="int32",tl.bool="bool",tl.complex64="complex64",(tu=tm||(tm={})).float32="float32",tu.int32="float32",tu.bool="float32",tu.complex64="complex64",(tp=tf||(tf={})).float32="complex64",tp.int32="complex64",tp.bool="complex64",tp.complex64="complex64";let e1={float32:tm,int32:tc,bool:th,complex64:tf};function e2(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw Error(`Can not upcast ${e} with ${t}`)}return e1[e][t]}function e3(e){return e2(e,"int32")}function e6(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function e4(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function e5(e,t){if(e.dtype===t.dtype)return[e,t];let r=e2(e.dtype,t.dtype);return[e.cast(r),t.cast(r)]}function e9(e,t){f(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function e7(e,t){return t.some(t=>t.id===e.id)}function e8(e){let t=[];return function e(t,r,a){var n;if(null!=t){if(t instanceof eQ)return void r.push(t);if(Array.isArray(n=t)||"object"==typeof n)for(let n in t){let s=t[n];a.has(s)||(a.add(s),e(s,r,a))}}}(e,t,new Set),t}function te(e){return null!=e.kernelName}e.s(["Rank",()=>td,"isWebGLData",()=>e6,"isWebGPUData",()=>e4,"sumOutType",()=>e3,"upcastType",()=>e2],320281),e.s(["assertTypesMatch",()=>e9,"getTensorsInContainer",()=>e8,"isTensorInList",()=>e7,"makeTypesMatch",()=>e5],744877);class tt{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}}class tr{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new tt}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let r=e[t];if(await this.initializeBackend(r).success)return void await this.setBackend(r)}throw Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(!(e in this.registryFactory))return null;else{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(eT(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(null==this.registryFactory[e])throw Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new eG(this.backendInstance),!0}setupRegisteredKernels(){ew(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){ew(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw Error(`Cannot initialize backend ${e}, no registration found.`);try{let r=t.factory();if(!r||r instanceof s||"function"!=typeof r.then)return this.registry[e]=r,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,a=r.then(r=>!(t<this.pendingBackendInitId)&&(this.registry[e]=r,this.pendingBackendInit=null,!0)).catch(r=>!(t<this.pendingBackendInitId)&&(this.pendingBackendInit=null,eT(`Initialization of backend ${e} failed`),eT(r.stack||r.message),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(t){return eT(`Initialization of backend ${e} failed`),eT(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let r=e[t],{success:a,asyncInit:n}=this.initializeBackend(r);if(n||a)return{name:r,asyncInit:n}}throw Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let r=this.state.tensorInfo.get(t),a=r.backend,n=this.readSync(t),s=a.refCount(t);a.disposeData(t,!0),r.backend=e,e.move(t,n,r.shape,r.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r,a=null;if(null==t){if("function"!=typeof e)throw Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun(()=>this.startScope(a),()=>this.endScope(r),()=>((r=t())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,r){e();try{let e=r();return t(),e}catch(e){throw t(),e}}nextTensorId(){return tr.nextTensorId++}nextVariableId(){return tr.nextVariableId++}clone(e){let t=tn.runKernel(em,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>tn.runKernel(el,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,r){if(null==this.backendName&&this.backend,null==eS(e,this.backendName))throw Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){let a=this.backend.numDataIds(),n=0;r.forEach(e=>{n+="complex64"===e.dtype?3:1});let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=a-t-n-s;if(i>0)throw Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,r,a,n,s=[],i=this.isTapeOn(),o=this.state.numBytes,l=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let u=te(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(te(e)){let{kernelName:t,inputs:n,attrs:o}=e;null==this.backendName&&this.backend;let l=eS(t,this.backendName);f(null!=l,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),r=()=>{let e=this.backend.numDataIds(),r=Array.isArray(a=l.kernelFunc({inputs:n,attrs:o,backend:this.backend}))?a:[a];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,r);let u=r.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(i){let e=this.getTensorsForGradient(t,n,u);s=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,n=e=>{i&&(s=e.map(e=>this.keep(this.clone(e))))};r=()=>{let e=this.backend.numDataIds(),r=Array.isArray(a=this.tidy(()=>t(this.backend,n)))?a:[a];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,r),r}}let{inputs:p,attrs:d}=e,c=te(e)?null:e.backwardsFunc;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(n=this.profiler.profileKernel(u,p,()=>r()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(n),t=n.outputs):t=r()}),i&&this.addTapeNode(u,p,t,c,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-l,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(e=>null!=p[e]?p[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:n.timeMs,extraInfo:n.extraInfo}),Array.isArray(a)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,r){let a=eE(e);if(null!=a){let e,n=a.inputsToSave||[],s=a.outputsToSave||[];a.saveAllInputs?(f(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),e=Object.keys(t).map(e=>t[e])):e=n.map(e=>t[e]);let i=r.filter((e,t)=>s[t]);return e.concat(i)}return[]}makeTensor(e,t,r,a){if(null==e)throw Error("Values passed to engine.makeTensor() are null");r=r||"float32",a=a||this.backend;let n=e;"string"===r&&C(e[0])&&(n=e.map(e=>eF(e)));let s=a.write(n,t,r),i=new eQ(t,r,s,this.nextTensorId());if(this.trackTensor(i,a),"string"===r){let e=this.state.tensorInfo.get(s),t=F(n);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,r,a){let n={dataId:e,shape:t,dtype:r=r||"float32"};return this.makeTensorFromTensorInfo(n,a)}makeTensorFromTensorInfo(e,t){let{dataId:r,shape:a,dtype:n}=e,s=new eQ(a,n,r,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,r,a){r=r||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));let n=new e0(e,t,r,this.nextTensorId());if(null!=this.state.registeredVariables[n.name])throw Error(`Variable with name ${n.name} was already registered`);return this.state.registeredVariables[n.name]=n,this.incRef(n,this.backend),n}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let r=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(r=e.size*R(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof e0||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*R(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,r=this.state.numTensors;for(let a of(this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r,this.state.activeProfile.kernels))a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,r,a,n,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:n},o=eE(e);null!=o&&(a=o.gradFunc),null!=a&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){let e=r[t],a=j(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e}),a(e.length>1?e:e[0],n,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=e8(e),r=new Set(t.map(e=>e.id));for(let e=0;e<this.state.activeScope.track.length;e++){let t=this.state.activeScope.track[e];t.kept||r.has(t.id)||t.dispose()}let a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==a.id||this.track(e)})}gradients(e,t,r,a=!1){if(f(t.length>0,()=>"gradients() received an empty list of xs."),null!=r&&"float32"!==r.dtype)throw Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let n=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));f(n instanceof eQ,()=>"The result y returned by f() must be a tensor.");let s=function(e,t,r){let a={},n={};for(let e=0;e<t.length;e++)a[t[e].id]=!0;for(let r=0;r<e.length;r++){let s=e[r],i=s.inputs;for(let e in i){let r=i[e],o=!1;for(let e=0;e<t.length;e++)if(a[r.id]){s.outputs.forEach(e=>a[e.id]=!0),o=!0,n[s.id]=!0;break}if(o)break}}let s={};s[r.id]=!0;let i={};for(let t=e.length-1;t>=0;t--){let r=e[t],a=r.inputs;for(let e=0;e<r.outputs.length;e++)if(s[r.outputs[e].id]){for(let e in a)s[a[e].id]=!0,i[r.id]=!0;break}}let o=[];for(let t=0;t<e.length;t++){let r=e[t];if(n[r.id]&&i[r.id]){let e={};for(let t in r.inputs){let n=r.inputs[t];a[n.id]&&(e[t]=n)}let t=Object.assign({},r);t.inputs=e,t.outputs=r.outputs,o.push(t)}}return o}(this.state.activeTape,t,n);if(!a&&0===s.length&&t.length>0)throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{var e;let a,i={};i[n.id]=null==r?(a=H(b(e=n.shape),"float32"),tn.makeTensor(a,e,"float32")):r,function(e,t,r,a){for(let n=t.length-1;n>=0;n--){let s=t[n],i=[];if(s.outputs.forEach(t=>{let r=e[t.id];null!=r?i.push(r):i.push(null)}),null==s.gradient)throw Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let n=r(()=>o[t]());if("float32"!==n.dtype)throw Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${n.dtype}'`);let i=s.inputs[t];if(!N(n.shape,i.shape))throw Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${n.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=n;else{let t=e[i.id];e[i.id]=a(t,n),t.dispose()}}}}(i,s,e=>this.tidy(e),ts);let o=t.map(e=>i[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(let t of e.saved)t.dispose()}),this.state.activeTape=null),{value:n,grads:o}})}customGrad(e){return f(z(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let r;f(t.every(e=>e instanceof eQ),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let a={};return t.forEach((e,t)=>{a[t]=e}),this.runKernelFunc({forwardFunc:(a,n)=>(f((r=e(...t,n)).value instanceof eQ,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),f(z(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(e,a)=>{let n=r.gradFunc(e,a),s=Array.isArray(n)?n:[n];f(s.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),f(s.every(e=>e instanceof eQ),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let i={};return s.forEach((e,t)=>{i[t]=()=>e}),i},inputs:a})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=eO(),r=await this.backend.time(e);return r.wallMs=eO()-t,r}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){for(let e in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new tt,this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function ta(){let e=ei();if(null==e._tfengine){let t=new et(e);e._tfengine=new tr(t)}return en=e._tfengine.ENV,eH=()=>e._tfengine,e._tfengine}tr.nextTensorId=0,tr.nextVariableId=0;let tn=ta();function ts(e,t){return tn.runKernel("Add",{a:e,b:t})}e.s(["ENGINE",0,tn,"getOrMakeEngine",()=>ta],27923);var ti,to,tl,tu,tp,td,tc,th,tm,tf,tg=e.i(350461);function ty(e){r=e}function tb(e){if(void 0!==r)return r;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function tT(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}e.s(["isBrowser",()=>tT,"isMobile",()=>tb,"mockIsMobile",()=>ty],546340);let tv=en;tv.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),tv.registerFlag("IS_BROWSER",()=>tT()),tv.registerFlag("IS_NODE",()=>void 0!==tg.default&&void 0!==tg.default.versions&&void 0!==tg.default.versions.node),tv.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),tv.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),tv.registerFlag("PROD",()=>!1),tv.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>tv.getBool("DEBUG")),tv.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),tv.registerFlag("IS_TEST",()=>!1),tv.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>tv.getBool("DEBUG")),tv.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),tv.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),tv.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1),e.s([],35412);var tN=e.i(221168);function tx(e,t){let r=e;if(eB(e))return"string"===t?[]:[e.length];if(e6(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(e4(e))return[e.buffer.size/(null==t?4:R(t))];if(!Array.isArray(e))return[];let a=[];for(;Array.isArray(r)||eB(r)&&"string"!==t;)a.push(r.length),r=r[0];return Array.isArray(e)&&en.getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function e(t,r,a){if(a=a||[],!Array.isArray(t)&&!eB(t))return void f(0===r.length,()=>`Element arr[${a.join("][")}] is a primitive, but should be an array/TypedArray of ${r[0]} elements`);f(r.length>0,()=>`Element arr[${a.join("][")}] should be a primitive, but is an array of ${t.length} elements`),f(t.length===r[0],()=>`Element arr[${a.join("][")}] should have ${r[0]} elements, but has ${t.length} elements`);let n=r.slice(1);for(let r=0;r<t.length;++r)e(t[r],n,a.concat(r))}(e,a,[]),a}function tS(e,t,r,a){if("string_or_numeric"!==e){if(null==e)throw Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw Error(`Argument '${r}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`)}}function tE(e,t,r,a="numeric"){if(e instanceof eY())return tS(a,e.dtype,t,r),e;let n=G(e);if("string"!==n&&["bool","int32","float32"].indexOf(a)>=0&&(n=a),tS(a,n,t,r),null==e||!eB(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let a=null==e?"null":e.constructor.name;throw Error(`Argument '${t}' passed to '${r}' must be a Tensor or TensorLike, but got '${a}'`)}let s=tx(e,n);eB(e)||Array.isArray(e)||(e=[e]);let i="string"!==n?e$(e,n):eL(e,[],!0);return tn.makeTensor(i,s,n)}function tw(e,t,r,a="numeric"){if(!Array.isArray(e))throw Error(`Argument ${t} passed to ${r} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,n)=>tE(e,`${t}[${n}]`,r,a))}e.s(["convertToTensor",()=>tE,"convertToTensorArray",()=>tw,"inferShape",()=>tx],240210);let tk="__op";function tI(e){let t=Object.keys(e);if(1!==t.length)throw Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let r=t[0],a=e[r];r.endsWith("_")&&(r=r.substring(0,r.length-1));let n=(...e)=>{tn.startScope(r);try{let t=a(...e);return Y(t)&&console.error("Cannot return a Promise inside of tidy."),tn.endScope(t),t}catch(e){throw tn.endScope(null),e}};return Object.defineProperty(n,"name",{value:r+=tk,configurable:!0}),n}e.s(["OP_SCOPE_SUFFIX",0,tk,"op",()=>tI],566389);let tA=tI({complex_:function(e,t){let r=tE(e,"real","complex"),a=tE(t,"imag","complex");return g(r.shape,a.shape,`real and imag shapes, ${r.shape} and ${a.shape}, must match in call to tf.complex().`),tn.runKernel(eu,{real:r,imag:a})}});function tP(e,t,r,a){if(null==a)a=G(e);else if("complex64"===a)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(e4(e)||e6(e)){if("float32"!==a&&"int32"!==a)throw Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${a}.`);return tn.backend.createTensorFromGPUData(e,t||r,a)}if(!eB(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Z(t);let e=b(t),a=b(r);f(e===a,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${a}`);for(let e=0;e<r.length;++e){let a=r[e],n=e!==r.length-1||a!==b(t.slice(e));f(r[e]===t[e]||!n,()=>`Error creating a new Tensor. Inferred shape (${r}) does not match the provided shape (${t}). `)}}return eB(e)||Array.isArray(e)||(e=[e]),t=t||r,e="string"!==a?e$(e,a):eL(e,[],!0),tn.makeTensor(e,t,a)}function tM(e,t,r){let a=tx(e,r);return tP(e,t,a,r)}e.s(["complex",0,tA],994152),e.s(["makeTensor",()=>tP],121930),e.s(["tensor",()=>tM],861392);let t_={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};e.s(["DTYPE_VALUE_SIZE_MAP",0,t_],310897);class tV{static join(e){return new tV(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map(e=>eB(e)?e.buffer:e)).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const a=e[r];r!==e.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const n=t+a.byteLength;this.shards.push({buffer:a,start:t,end:n}),t=n}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length||(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e))return new ArrayBuffer(0);let r=this.findShardForByte(e);if(-1===r)throw Error(`Could not find start shard for byte ${e}`);let a=new ArrayBuffer(t-e),n=new Uint8Array(a),s=0;for(let a=r;a<this.shards.length;a++){let r=this.shards[a],i=e+s-r.start,o=s,l=Math.min(t,r.end)-r.start,u=new Uint8Array(r.buffer,i,l-i);if(n.set(u,o),s+=u.length,t<r.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return -1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:+(e>=t.end)}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let r=function(e,t){let r=0,a=e.length;for(;r<=a;){let n=Math.floor((a-r)/2)+r,s=t(e[n]);if(0===s)return n;s<0?a=n:r=n+1}return -1}(this.shards,t);return -1===r?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function tD(){en.set("PROD",!0)}function t$(){en.set("DEBUG",!0)}function tO(){en.set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function tR(e){en.getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function tF(){tn.disposeVariables()}function tC(){return tn}function tB(){return tn.memory()}function tL(e){return tn.profile(e)}function tG(e,t){return tn.tidy(e,t)}function tz(e){e8(e).forEach(e=>e.dispose())}function tU(e){return tn.keep(e)}function tq(e){return tn.time(e)}function tW(e){return tn.setBackend(e)}function tK(){return tn.ready()}function tH(){return tn.backendName}function tj(e){tn.removeBackend(e)}function tJ(e){return tn.findBackend(e)}function tZ(e){return tn.findBackendFactory(e)}function tX(e,t,r=1){return tn.registerBackend(e,t,r)}function tQ(){return tn.backend}function tY(e,t){en.setPlatform(e,t)}async function t0(e,t){let r=[],a=[],n=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let s=0;s<n.length;++s){let i=n[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);let l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise(async e=>{let t=await o.bytes(),r=new Uint8Array(t.reduce((e,t)=>e+t.length,0)+4*t.length),a=0;for(let e=0;e<t.length;e++){let n=t[e],s=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(s,a),a+=4,r.set(n,a),a+=n.length}e(r)});a.push(e)}else a.push(o.data());null!=t&&(l.group=t),r.push(l)}return{data:function(e){if(null===e)throw Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,r=[];e.forEach(e=>{if(t+=e.byteLength,r.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});let a=new Uint8Array(t),n=0;return r.forEach(e=>{a.set(new Uint8Array(e.buffer),n),n+=e.byteLength}),a.buffer}(await Promise.all(a)),specs:r}}function t1(e,t){let r=new tV(e),a={},n=0;for(let e of t){let t=function(e,t){let r,a=b(e.shape);if("quantization"in e)r=t_[e.quantization.dtype];else if("string"===e.dtype){let e=0;for(let r=0;r<a;r++)e+=4+new Uint32Array(t(e,e+4))[0];return e}else r=t_[e.dtype];return a*r}(e,(e,t)=>r.slice(n+e,n+t));a[e.name]=t3(e,r.slice(n,n+t)),n+=t}return a}async function t2(e,t){let r,a=b(e.shape);if("quantization"in e)r=t_[e.quantization.dtype];else if("string"===e.dtype){let e=0;for(let r=0;r<a;r++)e+=4+new Uint32Array(await t(e,e+4))[0];return e}else r=t_[e.dtype];return a*r}function t3(e,t){let r,a=e.name,n=e.dtype,s=e.shape,i=b(s),o=0;if("quantization"in e){let s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s&&"scale"in s))throw Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else if("float16"===s.dtype){if("float32"!==n)throw Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${n}.`)}else throw Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let l=t_[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===n)if("uint8"===s.dtype||"uint16"===s.dtype){r=new Float32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];r[e]=t*s.scale+s.min}}else if("float16"===s.dtype){let e,t,a;r=(e=function(){let e=e=>{let t=e<<13,r=0;for(;(8388608&t)==0;)r-=8388608,t<<=1;return(t&=-8388609)|(r+=0x38800000)},t=new Uint32Array(2048);t[0]=0;for(let r=1;r<1024;r++)t[r]=e(r);for(let e=1024;e<2048;e++)t[e]=0x38000000+(e-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=0x47800000,e[32]=0x80000000,e[63]=0xc7800000;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=0x80000000+(t-32<<23);return e}(),a=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}(),r=>{let n=new ArrayBuffer(4*r.length),s=new Uint32Array(n);for(let n=0;n<r.length;n++){let i=r[n],o=e[a[i>>10]+(1023&i)]+t[i>>10];s[n]=o}return new Float32Array(n)})(u)}else throw Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);else if("int32"===n){if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);r=new Int32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];r[e]=Math.round(t*s.scale+s.min)}}else throw Error(`Unsupported dtype in weight '${a}': ${n}`);o+=i*l}else if("string"===n){let a=b(e.shape);r=[];for(let e=0;e<a;e++){let e=new Uint32Array(t.slice(o,o+4))[0];o+=4;let a=new Uint8Array(t.slice(o,o+e));r.push(a),o+=e}}else{let e=t_[n];if("float32"===n)r=new Float32Array(t);else if("int32"===n)r=new Int32Array(t);else if("bool"===n)r=new Uint8Array(t);else if("complex64"===n){r=new Float32Array(t);let e=new Float32Array(r.length/2),a=new Float32Array(r.length/2);for(let t=0;t<e.length;t++)e[t]=r[2*t],a[t]=r[2*t+1];let n=tM(e,s,"float32"),i=tM(a,s,"float32"),o=tA(n,i);return n.dispose(),i.dispose(),o}else throw Error(`Unsupported dtype in weight '${a}': ${n}`);o+=i*e}return tM(r,s,n)}async function t6(e,t,r){let a=new Uint8Array(t);for(;a.byteLength<r;){let{done:t,value:n}=await e.read();if(t&&null==n){let e=r-a.byteLength;throw Error(`Reader is done but ${e} bytes are still expected`)}let s=new Uint8Array(a.length+n.byteLength);s.set(a,0),s.set(new Uint8Array(n),a.length),a=s}return a.buffer}async function t4(e,t){let r={},a=e.getReader(),n=new ArrayBuffer(0);for(let e of t){let t=await t2(e,async(e,t)=>(n=await t6(a,n,t)).slice(e,t)),s=(n=await t6(a,n,t)).slice(0,t);n=n.slice(t);let i=t3(e,s);if(r[e.name]=i,"webgpu"===tH()){let e=tQ();"uploadToGPU"in e&&b(i.shape)>=en.get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return r}e.s(["CompositeArrayBuffer",()=>tV],661758),eX(tR),e.s(["backend",()=>tQ,"deprecationWarn",()=>tR,"disableDeprecationWarnings",()=>tO,"dispose",()=>tz,"disposeVariables",()=>tF,"enableDebugMode",()=>t$,"enableProdMode",()=>tD,"engine",()=>tC,"findBackend",()=>tJ,"findBackendFactory",()=>tZ,"getBackend",()=>tH,"keep",()=>tU,"memory",()=>tB,"profile",()=>tL,"ready",()=>tK,"registerBackend",()=>tX,"removeBackend",()=>tj,"setBackend",()=>tW,"setPlatform",()=>tY,"tidy",()=>tG,"time",()=>tq],720606);let t5=void 0!==tN.Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function t9(e){return t5?tN.Buffer.byteLength(e,"utf8"):new Blob([e]).size}function t7(e){if(t5)return tN.Buffer.from(e).toString("base64");let t=new Uint8Array(e),r="";for(let e=0,a=t.length;e<a;e++)r+=String.fromCharCode(t[e]);return btoa(r)}function t8(e){if(t5){let t=tN.Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;++e)r.set([t.charCodeAt(e)],e);return r.buffer}function re(e){return tV.join(e)}function rt(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function rr(e,t){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),r}function ra(e,t,r){let a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw Error("modelJSON has weightsManifest but weightSpecs is null");if(!r)throw Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=r}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(a.initializerSignature=e.initializerSignature),a}async function rn(e,t){let r,a;return null!=e.weightsManifest&&([r,a]=await t(e.weightsManifest)),ra(e,r,a)}function rs(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:t9(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:t9(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new tV(e.weightData).byteLength}}function ri(e){let t=[];for(let r of e)t.push(...r.weights);return t}e.s(["arrayBufferToBase64String",()=>t7,"base64StringToArrayBuffer",()=>t8,"basename",()=>rt,"concatenateArrayBuffers",()=>re,"decodeWeights",()=>t1,"decodeWeightsStream",()=>t4,"encodeWeights",()=>t0,"getModelArtifactsForJSON",()=>rn,"getModelArtifactsForJSONSync",()=>ra,"getModelArtifactsInfoForJSON",()=>rs,"getModelJSONForModelArtifacts",()=>rr,"getWeightSpecs",()=>ri],254577);class ro{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==ro.instance&&(ro.instance=new ro),ro.instance}static registerSaveRouter(e){ro.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ro.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ro.getHandlers(e,"save")}static getLoadHandlers(e,t){return ro.getHandlers(e,"load",t)}static getHandlers(e,t,r){let a=[];return("load"===t?ro.getInstance().loadRouters:ro.getInstance().saveRouters).forEach(t=>{let n=t(e,r);null!==n&&a.push(n)}),a}}e.s(["IORouterRegistry",()=>ro,"getLoadHandlers",0,(e,t)=>ro.getLoadHandlers(e,t),"getSaveHandlers",0,e=>ro.getSaveHandlers(e),"registerLoadRouter",0,e=>ro.registerLoadRouter(e),"registerSaveRouter",0,e=>ro.registerSaveRouter(e)],804493);let rl="tensorflowjs",ru="models_store",rp="model_info_store";function rd(){if(!en.getBool("IS_BROWSER"))throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw Error("The current browser does not appear to support IndexedDB.");return t}function rc(e){let t=e.result;t.createObjectStore(ru,{keyPath:"modelPath"}),t.createObjectStore(rp,{keyPath:"modelPath"})}class rh{constructor(e){if(this.indexedDB=rd(),null==e||!e)throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,r)=>{let a=this.indexedDB.open(rl,1);a.onupgradeneeded=()=>rc(a),a.onsuccess=()=>{let n=a.result;if(null==t){let t=n.transaction(ru,"readonly"),a=t.objectStore(ru).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return n.close(),r(Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(a.result.modelArtifacts)},a.onerror=e=>(n.close(),r(a.error)),t.oncomplete=()=>n.close()}else{let a,s;t.weightData=tV.join(t.weightData);let i=rs(t),o=n.transaction(rp,"readwrite"),l=o.objectStore(rp);try{a=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(e){return r(e)}a.onsuccess=()=>{let a,u=(s=n.transaction(ru,"readwrite")).objectStore(ru);try{a=u.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(e){return r(e)}a.onsuccess=()=>e({modelArtifactsInfo:i}),a.onerror=e=>{let t=(l=o.objectStore(rp)).delete(this.modelPath);t.onsuccess=()=>(n.close(),r(a.error)),t.onerror=e=>(n.close(),r(a.error))}},a.onerror=e=>(n.close(),r(a.error)),o.oncomplete=()=>{null==s?n.close():s.oncomplete=()=>n.close()}}},a.onerror=e=>r(a.error)})}}rh.URL_SCHEME="indexeddb://";let rm=e=>{var t;return en.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(rh.URL_SCHEME)?(t=e.slice(rh.URL_SCHEME.length),new rh(t)):null};ro.registerSaveRouter(rm),ro.registerLoadRouter(rm);class rf{constructor(){this.indexedDB=rd()}async listModels(){return new Promise((e,t)=>{let r=this.indexedDB.open(rl,1);r.onupgradeneeded=()=>rc(r),r.onsuccess=()=>{let a=r.result,n=a.transaction(rp,"readonly"),s=n.objectStore(rp).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(a.close(),t(s.error)),n.oncomplete=()=>a.close()},r.onerror=e=>t(r.error)})}async removeModel(e){var t;return e=(t=e).startsWith(rh.URL_SCHEME)?t.slice(rh.URL_SCHEME.length):t,new Promise((t,r)=>{let a=this.indexedDB.open(rl,1);a.onupgradeneeded=()=>rc(a),a.onsuccess=()=>{let n,s=a.result,i=s.transaction(rp,"readwrite"),o=i.objectStore(rp),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return s.close(),r(Error(`Cannot find model with path '${e}' in IndexedDB.`));{let a=o.delete(e),i=()=>{let a=(n=s.transaction(ru,"readwrite")).objectStore(ru).delete(e);a.onsuccess=()=>t(l.result.modelArtifactsInfo),a.onerror=e=>r(l.error)};a.onsuccess=i,a.onerror=e=>(i(),s.close(),r(l.error))}},l.onerror=e=>(s.close(),r(l.error)),i.oncomplete=()=>{null==n?s.close():n.oncomplete=()=>s.close()}},a.onerror=e=>r(a.error)})}}e.s(["BrowserIndexedDB",()=>rh,"BrowserIndexedDBManager",()=>rf],329654);let rg="tensorflowjs_models",ry="info";function rb(e){return{info:[rg,e,ry].join("/"),topology:[rg,e,"model_topology"].join("/"),weightSpecs:[rg,e,"weight_specs"].join("/"),weightData:[rg,e,"weight_data"].join("/"),modelMetadata:[rg,e,"model_metadata"].join("/")}}function rT(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}class rv{constructor(e){if(!en.getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=rb(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=rs(e),n=tV.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,t7(n));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:a}}catch(e){throw rT(this.keys),Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(null==r)throw Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;let a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=a;let n=this.LS.getItem(this.keys.modelMetadata);if(null!=n){let e=JSON.parse(n);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=t8(s),t}}rv.URL_SCHEME="localstorage://";let rN=e=>{var t;return en.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(rv.URL_SCHEME)?(t=e.slice(rv.URL_SCHEME.length),new rv(t)):null};ro.registerSaveRouter(rN),ro.registerLoadRouter(rN);class rx{constructor(){f(en.getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),f("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=rg+"/",r="/"+ry;for(let a=0;a<this.LS.length;++a){let n=this.LS.key(a);n.startsWith(t)&&n.endsWith(r)&&(e[function(e){let t=e.split("/");if(t.length<3)throw Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join("/")}(n)]=JSON.parse(this.LS.getItem(n)))}return e}async removeModel(e){var t;let r=rb(e=(t=e).startsWith(rv.URL_SCHEME)?t.slice(rv.URL_SCHEME.length):t);if(null==this.LS.getItem(r.info))throw Error(`Cannot find model at path '${e}'`);let a=JSON.parse(this.LS.getItem(r.info));return rT(r),a}}e.s(["BrowserLocalStorage",()=>rv,"BrowserLocalStorageManager",()=>rx],312757);class rS{constructor(){this.managers={}}static getInstance(){return null==rS.instance&&(rS.instance=new rS),rS.instance}static registerManager(e,t){f(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),f(e.length>0,()=>"scheme must not be an empty string.");let r=rS.getInstance();f(null==r.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){let t=rS.getInstance().managers[e];if(null==t)throw Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(rS.getInstance().managers)}}function rE(e){if(-1===e.indexOf("://"))throw Error(`The url string provided does not contain a scheme. Supported schemes are: ${rS.getSchemes().join(",")}`);return{scheme:e.split("://")[0],path:e.split("://")[1]}}async function rw(e,t,r=!1){f(e!==t,()=>`Old path and new path are the same: '${e}'`);let a=ro.getLoadHandlers(e);f(a.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),f(a.length<2,()=>`Copying failed because more than one (${a.length}) load handlers for source URL ${e}.`);let n=a[0],s=ro.getSaveHandlers(t);f(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),f(s.length<2,()=>`Copying failed because more than one (${a.length}) save handlers for destination URL ${t}.`);let i=s[0],o=rE(e).scheme,l=rE(e).path,u=o===rE(e).scheme,p=await n.load();r&&u&&await rS.getManager(o).removeModel(l);let d=await i.save(p);return r&&!u&&await rS.getManager(o).removeModel(l),d.modelArtifactsInfo}async function rk(){let e=rS.getSchemes(),t={};for(let r of e){let e=await rS.getManager(r).listModels();for(let a in e)t[r+"://"+a]=e[a]}return t}async function rI(e){let t=rE(e);return rS.getManager(t.scheme).removeModel(t.path)}async function rA(e,t){return rw(e,t,!1)}async function rP(e,t){return rw(e,t,!0)}if(e.s(["ModelStoreManagerRegistry",()=>rS,"copyModel",()=>rA,"listModels",()=>rk,"moveModel",()=>rP,"removeModel",()=>rI],63340),en.get("IS_BROWSER")){en.setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&en.getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(e,t)}isTypedArray(e){return eV(e)}});try{rS.registerManager(rv.URL_SCHEME,new rx)}catch(e){}try{rS.registerManager(rh.URL_SCHEME,new rf)}catch(e){}}function rM(e,t="float32",r){return t=t||"float32",Z(e),new eK(e,t,r)}en.get("IS_NODE")&&!en.get("IS_BROWSER")&&en.setPlatform("node",new class{constructor(){this.util={},this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=en.global.fetch?en.global.fetch(e,t):(null==a&&(a={}),a(e,t))}now(){let e=tg.default.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}),e.s(["buffer",()=>rM],792452);let r_=tI({cast_:function(e,t){let r=tE(e,"x","cast");if(!$(t))throw Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==r.dtype||"string"!==t&&"string"===r.dtype)throw Error("Only strings can be casted to strings");return tn.runKernel(el,{x:r},{dtype:t})}});e.s(["cast",0,r_],494096);let rV=tI({clone_:function(e){let t=tE(e,"x","clone","string_or_numeric");return tn.runKernel(em,{x:t})}});function rD(e,t=!1){console.log(e.toString(t))}e.s(["clone",0,rV],612930),e.s(["print",()=>rD],879228),ta(),ej={buffer:rM,cast:r_,clone:rV,print:rD};let r$=tI({add_:function(e,t){let r=tE(e,"a","add"),a=tE(t,"b","add");[r,a]=e5(r,a);let n={a:r,b:a};return tn.runKernel("Add",n)}});e.s(["add",0,r$],536331);let rO=tI({floorDiv_:function(e,t){let r=tE(e,"a","floorDiv"),a=tE(t,"b","floorDiv");[r,a]=e5(r,a);let n={a:r,b:a};return tn.runKernel(eh,n)}});e.s(["floorDiv",0,rO],167131);let rR=tI({div_:function(e,t){let r=tE(e,"a","div"),a=tE(t,"b","div");if([r,a]=e5(r,a),"int32"===r.dtype&&"int32"===a.dtype)return rO(r,a);let n={a:r,b:a};return tn.runKernel(ed,n,{})}});e.s(["div",0,rR],680837);let rF=tI({mul_:function(e,t){let r=tE(e,"a","mul"),a=tE(t,"b","mul");[r,a]=e5(r,a);let n={a:r,b:a};return tn.runKernel(eg,n)}});e.s(["mul",0,rF],449404);let rC=tI({sqrt_:function(e){let t=tE(e,"x","sqrt","float32");return tn.runKernel(ey,{x:t})}});e.s(["sqrt",0,rC],119509);let rB=tI({square_:function(e){let t=tE(e,"x","square");return tn.runKernel("Square",{x:t},{})}});e.s(["square",0,rB],240774);let rL=tI({zerosLike_:function(e){let t=tE(e,"x","zerosLike");return tn.runKernel(eb,{x:t})}});function rG(e){return f(z(e),()=>"The f passed in grad(f) must be a function"),(t,r)=>{let a=tE(t,"x","tf.grad","string_or_numeric"),n=null!=r?tE(r,"dy","tf.grad"):null;return tn.tidy(()=>{let{value:t,grads:r}=tn.gradients(()=>e(a),[a],n);return null!=n&&g(t.shape,n.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),rH(r),r[0]})}}function rz(e){return f(z(e),()=>"The f passed in grads(f) must be a function"),(t,r)=>{f(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let a=tw(t,"args","tf.grads","string_or_numeric"),n=null!=r?tE(r,"dy","tf.grads"):null;return tn.tidy(()=>{let{value:t,grads:r}=tn.gradients(()=>e(...a),a,n);return null!=n&&g(t.shape,n.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),rH(r),r})}}function rU(e){return f(z(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,r)=>{f(t instanceof eQ,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),f(null==r||r instanceof eQ,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:a,value:n}=tn.gradients(()=>e(t),[t],r);return rH(a),{grad:a[0],value:n}}}function rq(e){return f(z(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,r)=>{f(Array.isArray(t)&&t.every(e=>e instanceof eQ),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),f(null==r||r instanceof eQ,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let a=tn.gradients(()=>e(...t),t,r);return null!=r&&g(a.value.shape,r.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),rH(a.grads),a}}function rW(e,t){f(z(e),()=>"The f passed in variableGrads(f) must be a function"),f(null==t||Array.isArray(t)&&t.every(e=>e instanceof e0),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let r=null!=t;if(!r)for(let e in t=[],tn.registeredVariables)t.push(tn.registeredVariables[e]);let a=r?t.filter(e=>!e.trainable):null,n=t.length;f((t=t.filter(e=>e.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${n} variables is trainable.`);let{value:s,grads:i}=tn.gradients(e,t,null,!0);f(i.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),f(0===s.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);let o={};return t.forEach((e,t)=>{null!=i[t]&&(o[e.name]=i[t])}),null!=a&&a.forEach(e=>o[e.name]=null),{value:s,grads:o}}function rK(e){return tn.customGrad(e)}function rH(e){if(e.filter(e=>null==e).length>0)throw Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function rj(e,t){if((eB(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&eB(e)&&!(e instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return tP(e,[],[],t)}e.s(["zerosLike",0,rL],990256),e.s(["customGrad",()=>rK,"grad",()=>rG,"grads",()=>rz,"valueAndGrad",()=>rU,"valueAndGrads",()=>rq,"variableGrads",()=>rW],860623),e.s(["scalar",()=>rj],919862);let rJ=new Map,rZ=new Map;class rX{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class rQ{constructor(){this.classNameMap={}}static getMap(){return null==rQ.instance&&(rQ.instance=new rQ),rQ.instance}static register(e){rQ.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function rY(e,t,r){f(null!=e.className,()=>"Class being registered does not have the static className property defined."),f("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),f(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===t&&(t="Custom"),void 0===r&&(r=e.className);let a=t+">"+r;return rQ.register(e),rJ.set(a,e),rZ.set(e,a),e}function r0(e){return rZ.has(e)?rZ.get(e):e.className}e.s(["Serializable",()=>rX,"SerializationMap",()=>rQ,"getRegisteredName",()=>r0,"registerClass",()=>rY],760811);class r1 extends rX{minimize(e,t=!1,r){let{value:a,grads:n}=this.computeGradients(e,r);if(null!=r){let e=r.map(e=>({name:e.name,tensor:n[e.name]}));this.applyGradients(e)}else this.applyGradients(n);return(tz(n),t)?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return rW(e,t)}dispose(){null!=this.iterations_&&tz(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:rj(this.iterations_,"int32")}}async getWeights(){throw Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(r1,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients}),e.s(["Optimizer",()=>r1],246559);class r2 extends r1{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=tn.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,r)=>{let a=tn.registeredVariables[t];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${t}/accum_grad`,variable:tG(()=>rL(a).variable(!1))}),null==this.accumulatedUpdates[r]&&(this.accumulatedUpdates[r]={originalName:`${t}/accum_var`,variable:tG(()=>rL(a).variable(!1))});let n=Array.isArray(e)?e[r].tensor:e[t];if(null==n)return;let s=this.accumulatedGrads[r].variable,i=this.accumulatedUpdates[r].variable;tG(()=>{let e=r$(rF(s,this.rho),rF(rB(n),1-this.rho)),t=rF(rR(rC(r$(i,this.epsilon)),rC(r$(s,this.epsilon))),n),r=r$(rF(i,this.rho),rF(rB(t),1-this.rho));s.assign(e),i.assign(r);let o=r$(rF(t,-this.learningRate),a);a.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(tz(this.accumulatedGrads.map(e=>e.variable)),tz(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function r3(e,t,r){Z(e),r=r||G(t);let a={shape:e,value:t,dtype:r};return tn.runKernel(ec,{},a)}e.s(["AdadeltaOptimizer",()=>r2],548863),e.s(["fill",()=>r3],419886);class r6 extends r1{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,r)=>{let a=tn.registeredVariables[t];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${t}/accumulator`,variable:tG(()=>r3(a.shape,this.initialAccumulatorValue).variable(!1))});let n=Array.isArray(e)?e[r].tensor:e[t];if(null==n)return;let s=this.accumulatedGrads[r].variable;tG(()=>{let e=r$(s,rB(n));s.assign(e);let t=r$(rF(rR(n,rC(r$(e,tn.backend.epsilon()))),-this.learningRate),a);a.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&tz(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}e.s(["AdagradOptimizer",()=>r6],461215);let r4=tI({pow_:function(e,t){let r=tE(e,"base","pow"),a=tE(t,"exp","pow");[r,a]=e5(r,a);let n={a:r,b:a};return tn.runKernel("Pow",n)}});e.s(["pow",0,r4],26194);let r5=tI({sub_:function(e,t){let r=tE(e,"a","sub"),a=tE(t,"b","sub");[r,a]=e5(r,a);let n={a:r,b:a};return tn.runKernel("Sub",n)}});e.s(["sub",0,r5],33457);class r9 extends r1{static get className(){return"Adam"}constructor(e,t,r,a=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],tG(()=>{this.accBeta1=rj(t).variable(),this.accBeta2=rj(r).variable()}),null==a&&(this.epsilon=tn.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);tG(()=>{let r=r5(1,this.accBeta1),a=r5(1,this.accBeta2);t.forEach((t,n)=>{let s=tn.registeredVariables[t];null==this.accumulatedFirstMoment[n]&&(this.accumulatedFirstMoment[n]={originalName:`${t}/m`,variable:tG(()=>rL(s).variable(!1))}),null==this.accumulatedSecondMoment[n]&&(this.accumulatedSecondMoment[n]={originalName:`${t}/v`,variable:tG(()=>rL(s).variable(!1))});let i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;let o=this.accumulatedFirstMoment[n].variable,l=this.accumulatedSecondMoment[n].variable,u=r$(rF(o,this.beta1),rF(i,1-this.beta1)),p=r$(rF(l,this.beta2),rF(rB(i),1-this.beta2)),d=rR(u,r),c=rR(p,a);o.assign(u),l.assign(p);let h=r$(rF(rR(d,r$(rC(c),this.epsilon)),-this.learningRate),s);s.assign(h)}),this.accBeta1.assign(rF(this.accBeta1,this.beta1)),this.accBeta2.assign(rF(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&tz(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&tz(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),tG(()=>{this.accBeta1.assign(r4(this.beta1,this.iterations_+1)),this.accBeta2.assign(r4(this.beta2,this.iterations_+1))});let t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}e.s(["AdamOptimizer",()=>r9],370811);let r7=tI({abs_:function(e){let t=tE(e,"x","abs");return"complex64"===t.dtype?tn.runKernel(ep,{x:t}):tn.runKernel("Abs",{x:t})}});function r8(e,t){let r=e.length,a=[];for(let n=0;n<r;n++){let s=r-1-n,i=e[s]||1;(t[t.length-1-n]||1)>1&&1===i&&a.unshift(s)}return a}function ae(e,t){let r=[];for(let a=0;a<t.length;a++){let n=e[e.length-a-1],s=t.length-a-1,i=t[s];(null==n||1===n&&i>1)&&r.unshift(s)}return r}function at(e,t){let r=Math.max(e.length,t.length),a=Array(r);for(let n=0;n<r;n++){let s=e[e.length-n-1];null==s&&(s=1);let i=t[t.length-n-1];if(null==i&&(i=1),1===s)a[r-n-1]=i;else if(1===i)a[r-n-1]=s;else if(s!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);else a[r-n-1]=s}return a}e.s(["abs",0,r7],410616),e.s(["assertAndGetBroadcastShape",()=>at,"getBroadcastDims",()=>r8,"getReductionAxes",()=>ae],568503);let ar=tI({maximum_:function(e,t){let r=tE(e,"a","maximum"),a=tE(t,"b","maximum");[r,a]=e5(r,a),"bool"===r.dtype&&(r=r_(r,"int32"),a=r_(a,"int32")),at(r.shape,a.shape);let n={a:r,b:a};return tn.runKernel(ef,n)}});e.s(["maximum",0,ar],638688);class aa extends r1{static get className(){return"Adamax"}constructor(e,t,r,a=null,n=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=a,this.decay=n,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],tG(()=>{this.iteration=rj(0).variable(),this.accBeta1=rj(t).variable()}),null==a&&(this.epsilon=tn.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);tG(()=>{let r=r5(1,this.accBeta1),a=rR(-this.learningRate,r$(rF(this.iteration,this.decay),1));t.forEach((t,n)=>{let s=tn.registeredVariables[t];null==this.accumulatedFirstMoment[n]&&(this.accumulatedFirstMoment[n]={originalName:`${t}/m`,variable:rL(s).variable(!1)}),null==this.accumulatedWeightedInfNorm[n]&&(this.accumulatedWeightedInfNorm[n]={originalName:`${t}/v`,variable:rL(s).variable(!1)});let i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;let o=this.accumulatedFirstMoment[n].variable,l=this.accumulatedWeightedInfNorm[n].variable,u=r$(rF(o,this.beta1),rF(i,1-this.beta1)),p=ar(rF(l,this.beta2),r7(i));o.assign(u),l.assign(p);let d=r$(rF(rR(a,r),rR(u,r$(p,this.epsilon))),s);s.assign(d)}),this.iteration.assign(r$(this.iteration,1)),this.accBeta1.assign(rF(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&tz(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&tz(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}e.s(["AdamaxOptimizer",()=>aa],998029);class an extends r1{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,r)=>{let a=Array.isArray(e)?e[r].tensor:e[t];if(null==a)return;let n=tn.registeredVariables[t];tG(()=>{let e=r$(rF(this.c,a),n);n.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=tU(rj(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}e.s(["SGDOptimizer",()=>an],953734);class as extends an{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=rj(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,r)=>{let a=tn.registeredVariables[t];null==this.accumulations[r]&&(this.accumulations[r]={originalName:`${t}/momentum`,variable:tG(()=>rL(a).variable(!1))});let n=this.accumulations[r].variable,s=Array.isArray(e)?e[r].tensor:e[t];null!=s&&tG(()=>{let e,t=r$(rF(this.m,n),s);e=this.useNesterov?r$(rF(this.c,r$(s,rF(t,this.m))),a):r$(rF(this.c,t),a),n.assign(t),a.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&tz(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}e.s(["MomentumOptimizer",()=>as],889306);class ai extends r1{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,a=null,n=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=n,null==a&&(this.epsilon=tn.backend.epsilon()),null==e)throw Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,r)=>{let a=tn.registeredVariables[t];null==this.accumulatedMeanSquares[r]&&(this.accumulatedMeanSquares[r]={originalName:`${t}/rms`,variable:tG(()=>rL(a).variable(!1))}),null==this.accumulatedMoments[r]&&(this.accumulatedMoments[r]={originalName:`${t}/momentum`,variable:tG(()=>rL(a).variable(!1))}),null==this.accumulatedMeanGrads[r]&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${t}/mg`,variable:tG(()=>rL(a).variable(!1))});let n=Array.isArray(e)?e[r].tensor:e[t];if(null==n)return;let s=this.accumulatedMeanSquares[r].variable,i=this.accumulatedMoments[r].variable;tG(()=>{let e=r$(rF(s,this.decay),rF(rB(n),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[r].variable,o=r$(rF(t,this.decay),rF(n,1-this.decay)),l=rR(rF(n,this.learningRate),rC(r5(e,r$(rB(o),this.epsilon)))),u=r$(rF(i,this.momentum),l);s.assign(e),t.assign(o),i.assign(u);let p=r5(a,u);a.assign(p)}else{let e=r$(rF(s,this.decay),rF(rB(n),1-this.decay)),t=r$(rF(i,this.momentum),rR(rF(n,this.learningRate),rC(r$(e,this.epsilon))));s.assign(e),i.assign(t);let r=r5(a,t);a.assign(r)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&tz(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&tz(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&tz(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}e.s(["RMSPropOptimizer",()=>ai],85824);for(let e of[r2,r6,r9,aa,as,ai,an])rY(e);e.s([],704411)},311709,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({step_:function(e,n=0){let s=(0,a.convertToTensor)(e,"x","step");return t.ENGINE.runKernel(r.Step,{x:s},{alpha:n})}});e.s(["step",0,n])},408604,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({neg_:function(e){let n=(0,a.convertToTensor)(e,"x","neg");return t.ENGINE.runKernel(r.Neg,{x:n})}});e.s(["neg",0,n])},940570,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({reshape_:function(e,n){let s=(0,a.convertToTensor)(e,"x","reshape","string_or_numeric");return t.ENGINE.runKernel(r.Reshape,{x:s},{shape:n})}});e.s(["reshape",0,n])},101669,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(494096);let s=(0,e.i(566389).op)({sum_:function(e,s=null,i=!1){let o=(0,a.convertToTensor)(e,"x","sum");"bool"===o.dtype&&(o=(0,n.cast)(o,"int32"));let l={x:o};return t.ENGINE.runKernel(r.Sum,l,{axis:s,keepDims:i})}});e.s(["sum",0,s])},870360,e=>{"use strict";var t=e.i(496378);function r(e,t,a,n,i="NHWC",o){let l=[...t,e[3]];return s(e,l,a,o,n,null,null,f(i))}function a(e,t,r,n,i,o,u="channelsLast"){let p,[d,c]=l(t);if("channelsLast"===u)p=[d,c,e[3],e[3]];else if("channelsFirst"===u)p=[d,c,e[1],e[1]];else throw Error(`Unknown dataFormat ${u}`);return s(e,p,r,n,i,o,!1,u)}function n(e,t,r,a,s,o,l="NDHWC"){let p,d,[c,h,m]=u(t);if("NDHWC"===l)d="channelsLast",p=[c,h,m,e[4],e[4]];else if("NCDHW"===l)d="channelsFirst",p=[c,h,m,e[1],e[1]];else throw Error(`Unknown dataFormat ${l}`);return i(e,p,r,a,s,!1,d,o)}function s(e,t,r,a,n,i,u=!1,c="channelsLast"){let h,[m,f,g,y]=[-1,-1,-1,-1];if("channelsLast"===c)[m,f,g,y]=e;else if("channelsFirst"===c)[m,y,f,g]=e;else throw Error(`Unknown dataFormat ${c}`);let[b,T,,v]=t,[N,x]=l(r),[S,E]=l(a),w=p(b,S),k=p(T,E),{padInfo:I,outHeight:A,outWidth:P}=function(e,t,r,a,n,s,i,l,u){let p,c,h;if("number"==typeof e){var m,f;let n,i,u=0===e?"VALID":"NUMBER";p={top:e,bottom:e,left:e,right:e,type:u};let g=(m=[t,r],null==(f=e)&&(f=o(m,s,a)),n=m[0],i=m[1],[d((n-s+2*f)/a+1,l),d((i-s+2*f)/a+1,l)]);c=g[0],h=g[1]}else if("same"===e){let e=Math.max(0,((c=Math.ceil(t/a))-1)*a+s-t),o=Math.max(0,((h=Math.ceil(r/n))-1)*n+i-r),l=Math.floor(e/2),u=Math.floor(o/2);p={top:l,bottom:e-l,left:u,right:o-u,type:"SAME"}}else if("valid"===e)p={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/a),h=Math.ceil((r-i+1)/n);else if("object"==typeof e){let o="channelsLast"===u?e[1][0]:e[2][0],m="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],g="channelsLast"===u?e[2][1]:e[3][1];p={top:o,bottom:m,left:f,right:g,type:0===o&&0===m&&0===f&&0===g?"VALID":"EXPLICIT"},c=d((t-s+o+m)/a+1,l),h=d((r-i+f+g)/n+1,l)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outHeight:c,outWidth:h}}(n,f,g,N,x,w,k,i,c),M=u?v*y:v;return"channelsFirst"===c?h=[m,M,A,P]:"channelsLast"===c&&(h=[m,A,P,M]),{batchSize:m,dataFormat:c,inHeight:f,inWidth:g,inChannels:y,outHeight:A,outWidth:P,outChannels:M,padInfo:I,strideHeight:N,strideWidth:x,filterHeight:b,filterWidth:T,effectiveFilterHeight:w,effectiveFilterWidth:k,dilationHeight:S,dilationWidth:E,inShape:e,outShape:h,filterShape:t}}function i(e,t,r,a,n,s=!1,l="channelsLast",c){let h,[m,f,g,y,b]=[-1,-1,-1,-1,-1];if("channelsLast"===l)[m,f,g,y,b]=e;else if("channelsFirst"===l)[m,b,f,g,y]=e;else throw Error(`Unknown dataFormat ${l}`);let[T,v,N,,x]=t,[S,E,w]=u(r),[k,I,A]=u(a),P=p(T,k),M=p(v,I),_=p(N,A),{padInfo:V,outDepth:D,outHeight:$,outWidth:O}=function(e,t,r,a,n,s,i,l,u,p,c){let h,m,f,g;if("valid"===e&&(e=0),"number"==typeof e){let y=0===e?"VALID":"NUMBER";h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:y};let b=function(e,t,r,a,n,s){null==n&&(n=o(e,t[0],a[0]));let i=[0,0,0,1];for(let r=0;r<3;r++)e[r]+2*n>=t[r]&&(i[r]=d((e[r]-t[r]+2*n)/a[r]+1,s));return i}([t,r,a,1],[l,u,p],0,[n,s,i],e,c);m=b[0],f=b[1],g=b[2]}else if("same"===e){let e=((m=Math.ceil(t/n))-1)*n+l-t,o=((f=Math.ceil(r/s))-1)*s+u-r,d=((g=Math.ceil(a/i))-1)*i+p-a,c=Math.floor(e/2),y=Math.floor(o/2),b=Math.floor(d/2);h={top:y,bottom:o-y,left:b,right:d-b,front:c,back:e-c,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:h,outDepth:m,outHeight:f,outWidth:g}}(n,f,g,y,S,E,w,P,M,_,c),R=s?x*b:x;return"channelsFirst"===l?h=[m,R,D,$,O]:"channelsLast"===l&&(h=[m,D,$,O,R]),{batchSize:m,dataFormat:l,inDepth:f,inHeight:g,inWidth:y,inChannels:b,outDepth:D,outHeight:$,outWidth:O,outChannels:R,padInfo:V,strideDepth:S,strideHeight:E,strideWidth:w,filterDepth:T,filterHeight:v,filterWidth:N,effectiveFilterDepth:P,effectiveFilterHeight:M,effectiveFilterWidth:_,dilationDepth:k,dilationHeight:I,dilationWidth:A,inShape:e,outShape:h,filterShape:t}}function o(e,t,r,a=1){let n=p(t,a);return Math.floor((e[0]*(r-1)-r+n)/2)}function l(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function u(e){return"number"==typeof e?[e,e,e]:e}function p(e,t){return t<=1?e:e+(e-1)*(t-1)}function d(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw Error(`Unknown roundingMode ${t}`)}}function c(e){let[t,r,a]=l(e);return 1===t&&1===r&&1===a}function h(e,t){return c(e)||c(t)}function m(e){return l(e).every(e=>e>0)}function f(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw Error(`Unknown dataFormat ${e}`)}function g(e,r,a){if(null!=a)if("string"==typeof r)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${a} but got pad ${r}.`);else if("number"==typeof r)t.assert(t.isInt(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${a} but got pad ${r}.`);else if("object"==typeof r)r.forEach(r=>{r.forEach(r=>{t.assert(t.isInt(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${a} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${r}`)}e.s(["checkPadOnDimRoundingMode",()=>g,"computeConv2DInfo",()=>s,"computeConv3DInfo",()=>i,"computeDefaultPad",()=>o,"computeDilation2DInfo",()=>r,"computePool2DInfo",()=>a,"computePool3DInfo",()=>n,"convertConv2DDataFormat",()=>f,"eitherStridesOrDilationsAreOne",()=>h,"stridesOrDilationsArePositive",()=>m,"tupleValuesAreOne",()=>c])},656040,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(744877),n=e.i(240210);let s=(0,e.i(566389).op)({matMul_:function(e,s,i=!1,o=!1){let l=(0,n.convertToTensor)(e,"a","matMul"),u=(0,n.convertToTensor)(s,"b","matMul");[l,u]=(0,a.makeTypesMatch)(l,u);let p={a:l,b:u};return t.ENGINE.runKernel(r.BatchMatMul,p,{transposeA:i,transposeB:o})}});e.s(["matMul",0,s])},707019,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({spaceToBatchND_:function(e,s,i){let o=(0,a.convertToTensor)(e,"x","spaceToBatchND");return n.assert(o.rank>=1+s.length,()=>`input rank ${o.rank} should be > than [blockShape] ${s.length}`),n.assert(i.length===s.length,()=>`paddings.shape[0] ${i.length} must be equal to [blockShape] ${s.length}`),n.assert(o.shape.reduce((e,t,r)=>r>0&&r<=s.length?e&&(t+i[r-1][0]+i[r-1][1])%s[r-1]==0:e,!0),()=>`input spatial dimensions ${o.shape.slice(1)} with paddings ${i.toString()} must be divisible by blockShapes ${s.toString()}`),t.ENGINE.runKernel(r.SpaceToBatchND,{x:o},{blockShape:s,paddings:i})}});e.s(["spaceToBatchND",0,s])},318814,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(744877),n=e.i(240210),s=e.i(568503);let i=(0,e.i(566389).op)({greaterEqual_:function(e,i){let o=(0,n.convertToTensor)(e,"a","greaterEqual","string_or_numeric"),l=(0,n.convertToTensor)(i,"b","greaterEqual","string_or_numeric");[o,l]=(0,a.makeTypesMatch)(o,l),(0,s.assertAndGetBroadcastShape)(o.shape,l.shape);let u={a:o,b:l};return t.ENGINE.runKernel(r.GreaterEqual,u)}});e.s(["greaterEqual",0,i])},612700,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(744877),n=e.i(240210),s=e.i(568503);let i=(0,e.i(566389).op)({lessEqual_:function(e,i){let o=(0,n.convertToTensor)(e,"a","lessEqual","string_or_numeric"),l=(0,n.convertToTensor)(i,"b","lessEqual","string_or_numeric");[o,l]=(0,a.makeTypesMatch)(o,l),(0,s.assertAndGetBroadcastShape)(o.shape,l.shape);let u={a:o,b:l};return t.ENGINE.runKernel(r.LessEqual,u)}});e.s(["lessEqual",0,i])},783171,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(568503);let s=(0,e.i(566389).op)({logicalAnd_:function(e,s){let i=(0,a.convertToTensor)(e,"a","logicalAnd","bool"),o=(0,a.convertToTensor)(s,"b","logicalAnd","bool");return(0,n.assertAndGetBroadcastShape)(i.shape,o.shape),t.ENGINE.runKernel(r.LogicalAnd,{a:i,b:o})}});e.s(["logicalAnd",0,s])},379250,566006,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(612930),i=e.i(566389),o=e.i(940570);let l=(0,i.op)({broadcastTo_:function(e,i){let l=(0,a.convertToTensor)(e,"broadcastTo","x"),u=l.shape;if((0,n.assertNonNegativeIntegerDimensions)(i),i.length<l.rank)throw Error(`broadcastTo(): shape.length=${i.length} < input.rank=${l.rank}.`);if(i.length>l.rank){let e=l.shape.slice();for(;e.length<i.length;)e.unshift(1);l=(0,o.reshape)(l,e)}let p=l.shape,d=Array.from(i);for(let e=i.length-1;e>=0;e--)if(p[e]===i[e])d[e]=1;else if(1!==l.shape[e])throw Error(`broadcastTo(): [${u}] cannot be broadcast to [${i}].`);if(0===d.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length)return(0,s.clone)(l);let c={x:l};return t.ENGINE.runKernel(r.Tile,c,{reps:d})}});e.s(["broadcastTo",0,l],566006);var u=e.i(568503);let p=(0,i.op)({where_:function(e,n,s){let i=(0,a.convertToTensor)(n,"a","where"),o=(0,a.convertToTensor)(s,"b","where"),p=(0,a.convertToTensor)(e,"condition","where","bool"),d=(0,u.assertAndGetBroadcastShape)((0,u.assertAndGetBroadcastShape)(p.shape,i.shape),o.shape),c=l(p,d),h=l(i,d),m=l(o,d);return t.ENGINE.runKernel(r.Select,{condition:c,t:h,e:m})}});e.s(["where",0,p],379250)},798670,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({split_:function(e,n,s=0){let i=(0,a.convertToTensor)(e,"x","split");return t.ENGINE.runKernel(r.SplitV,{x:i},{numOrSizeSplits:n,axis:s})}});e.s(["split",0,n])},110369,345161,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(496378),n=e.i(870360),s=e.i(566389),i=e.i(940570);let o=(0,s.op)({conv2DBackpropFilter_:function(e,s,o,l,u,p="NHWC",d){let c=e;3===e.rank&&(c=(0,i.reshape)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let h=s;3===h.rank&&(h=(0,i.reshape)(s,[1,s.shape[0],s.shape[1],s.shape[2]])),a.assert(4===c.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${c.shape}.`),a.assert(4===h.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${h.shape}.`),a.assert(4===o.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${o}.`);let m="NHWC"===p?c.shape[3]:c.shape[1],f="NHWC"===p?h.shape[3]:h.shape[1];a.assert(m===o[2],()=>`Error in conv2dDerFilter: depth of input ${m}) must match input depth in filter (${o[2]}.`),a.assert(f===o[3],()=>`Error in conv2dDerFilter: depth of dy (${f}) must match output depth for filter (${o[3]}).`),n.checkPadOnDimRoundingMode("conv2dDerFilter",u,d);let g={x:c,dy:h};return t.ENGINE.runKernel(r.Conv2DBackpropFilter,g,{strides:l,pad:u,dataFormat:p,dimRoundingMode:d,filterShape:o})}});e.s(["conv2DBackpropFilter",0,o],110369);let l=(0,s.op)({conv2DBackpropInput_:function(e,s,o,l,u,p="NHWC",d){a.assert(e.length===s.rank,()=>`Length of inShape (${e.length}) and rank of dy (${s.rank}) must match`);let c=e,h=s,m=!1;3===s.rank&&(m=!0,h=(0,i.reshape)(s,[1,s.shape[0],s.shape[1],s.shape[2]]),c=[1,e[0],e[1],e[2]]),a.assert(4===c.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${c.length}.`),a.assert(4===h.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${h.rank}`),a.assert(4===o.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${o.rank}`);let f="NHWC"===p?c[3]:c[1],g="NHWC"===p?h.shape[3]:h.shape[1];a.assert(f===o.shape[2],()=>`Error in conv2dDerInput: depth of input (${f}) must match input depth for filter ${o.shape[2]}.`),a.assert(g===o.shape[3],()=>`Error in conv2dDerInput: depth of output (${g}) must match output depth for filter ${o.shape[3]}.`),n.checkPadOnDimRoundingMode("conv2dDerInput",u,d);let y={dy:h,filter:o},b={strides:l,pad:u,dataFormat:p,dimRoundingMode:d,inputShape:c},T=t.ENGINE.runKernel(r.Conv2DBackpropInput,y,b);return m?(0,i.reshape)(T,[T.shape[1],T.shape[2],T.shape[3]]):T}});e.s(["conv2DBackpropInput",0,l],345161)},673749,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(870360),i=e.i(566389),o=e.i(940570);let l=(0,i.op)({conv2d_:function(e,i,l,u,p="NHWC",d=[1,1],c){let h=(0,a.convertToTensor)(e,"x","conv2d","float32"),m=(0,a.convertToTensor)(i,"filter","conv2d","float32"),f=h,g=!1;3===h.rank&&(g=!0,f=(0,o.reshape)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),n.assert(4===f.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${f.rank}.`),n.assert(4===m.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${m.rank}.`),s.checkPadOnDimRoundingMode("conv2d",u,c);let y="NHWC"===p?f.shape[3]:f.shape[1];n.assert(y===m.shape[2],()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${m.shape[2]}.`),n.assert(s.eitherStridesOrDilationsAreOne(l,d),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${l} and dilations '${d}'`),n.assert(s.stridesOrDilationsArePositive(d),()=>"Error in conv2D: Dilated rates should be larger than 0."),n.assert(s.stridesOrDilationsArePositive(l),()=>"Error in conv2D: Strides should be larger than 0.");let b={x:f,filter:m},T=t.ENGINE.runKernel(r.Conv2D,b,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c});return g?(0,o.reshape)(T,[T.shape[1],T.shape[2],T.shape[3]]):T}});e.s(["conv2d",0,l])},107235,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(496378),n=e.i(566389),s=e.i(940570);let i=(0,n.op)({conv3DBackpropInput_:function(e,n,i,o,l){a.assert(e.length===n.rank,()=>`Length of inShape (${e.length}) and rank of dy (${n.rank}) must match`);let u=e,p=n,d=!1;4===n.rank&&(d=!0,p=(0,s.reshape)(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]),u=[1,e[0],e[1],e[2],e[3]]);let c=u[4],h=p.shape[4];a.assert(5===u.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${u.length}.`),a.assert(5===p.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${p.rank}`),a.assert(5===i.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${i.rank}`),a.assert(c===i.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${i.shape[3]}.`),a.assert(h===i.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${i.shape[4]}.`);let m={dy:p,filter:i},f={pad:l,strides:o,inputShape:u},g=t.ENGINE.runKernel(r.Conv3DBackpropInputV2,m,f);return d?(0,s.reshape)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}});e.s(["conv3DBackpropInput",0,i])},85565,367743,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({sin_:function(e){let n=(0,a.convertToTensor)(e,"x","sin","float32");return t.ENGINE.runKernel(r.Sin,{x:n})}});e.s(["sin",0,s],85565);let i=(0,n.op)({sinh_:function(e){let n=(0,a.convertToTensor)(e,"x","sinh");return t.ENGINE.runKernel(r.Sinh,{x:n})}});e.s(["sinh",0,i],367743)},769664,e=>{"use strict";var t=e.i(496378);function r(e,t){for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0}function a(e,t,r){let a=e.length+t.length,n=[],s=0,i=0;for(let o=0;o<a;o++)-1===r.indexOf(o)?n.push(e[s++]):n.push(t[i++]);return n}function n(e,t){let r=[],a=e.length;for(let n=0;n<a;n++)-1===t.indexOf(n)&&r.push(e[n]);return[r,t.map(t=>e[t])]}function s(e,t){return a(e,t.map(e=>1),t)}function i(e,a,n){t.assert(r(a,n),()=>`${e} supports only inner-most axes for now. Got axes ${a} and rank-${n} input.`)}function o(e,t){if(r(e,t))return null;let a=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&a.push(r);return e.forEach(e=>a.push(e)),a}function l(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function u(e,t){let r=[];for(let a=t-e;a<t;++a)r.push(a);return r}e.s(["assertAxesAreInnerMostDims",()=>i,"axesAreInnerMostDims",()=>r,"combineLocations",()=>a,"computeOutAndReduceShapes",()=>n,"expandShapeToKeepDim",()=>s,"getAxesPermutation",()=>o,"getInnerMostAxes",()=>u,"getUndoAxesPermutation",()=>l])},657311,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({cumsum_:function(e,n=0,s=!1,i=!1){let o=(0,a.convertToTensor)(e,"x","cumsum");return t.ENGINE.runKernel(r.Cumsum,{x:o},{axis:n,exclusive:s,reverse:i})}});e.s(["cumsum",0,n])},176598,404099,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({imag_:function(e){let n=(0,a.convertToTensor)(e,"input","imag");return t.ENGINE.runKernel(r.Imag,{input:n})}});e.s(["imag",0,s],176598);let i=(0,n.op)({real_:function(e){let n=(0,a.convertToTensor)(e,"input","real");return t.ENGINE.runKernel(r.Real,{input:n})}});e.s(["real",0,i],404099)},604907,e=>{"use strict";var t=e.i(27923),r=e.i(720606),a=e.i(592061),n=e.i(240210),s=e.i(496378),i=e.i(994152),o=e.i(176598),l=e.i(408604),u=e.i(566389),p=e.i(404099);let d=(0,u.op)({transpose_:function(e,u,d){let c=(0,n.convertToTensor)(e,"x","transpose");if(null==u&&(u=c.shape.map((e,t)=>t).reverse()),s.assert(c.rank===u.length,()=>`Error in transpose: rank of input ${c.rank} must match length of perm ${u}.`),u.forEach(e=>{s.assert(e>=0&&e<c.rank,()=>`All entries in 'perm' must be between 0 and ${c.rank-1} but got ${u}`)}),c.rank<=1)return c.clone();let h={perm:u};return"complex64"===c.dtype?(0,r.tidy)(()=>{let e=(0,p.real)(c),r=(0,o.imag)(c);return e=t.ENGINE.runKernel(a.Transpose,{x:e},h),r=t.ENGINE.runKernel(a.Transpose,{x:r},h),d&&(r=(0,l.neg)(r)),(0,i.complex)(e,r)}):t.ENGINE.runKernel(a.Transpose,{x:c},h)}});e.s(["transpose",0,d])},240053,156329,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(566389),n=e.i(940570);let s=(0,a.op)({depthwiseConv2dNativeBackpropFilter_:function(e,a,s,i,o,l=[1,1],u){let p=e;3===e.rank&&(p=(0,n.reshape)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let d=a;3===d.rank&&(d=(0,n.reshape)(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let c={x:p,dy:d};return t.ENGINE.runKernel(r.DepthwiseConv2dNativeBackpropFilter,c,{strides:i,pad:o,dimRoundingMode:u,dilations:l,filterShape:s})}});e.s(["depthwiseConv2dNativeBackpropFilter",0,s],240053);let i=(0,a.op)({depthwiseConv2dNativeBackpropInput_:function(e,a,s,i,o,l=[1,1],u){let p=a,d=!1;3===a.rank&&(d=!0,p=(0,n.reshape)(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let c={dy:p,filter:s},h=t.ENGINE.runKernel(r.DepthwiseConv2dNativeBackpropInput,c,{strides:i,pad:o,dimRoundingMode:u,dilations:l,inputShape:e});return d?(0,n.reshape)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});e.s(["depthwiseConv2dNativeBackpropInput",0,i],156329)},345175,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({exp_:function(e){let n=(0,a.convertToTensor)(e,"x","exp");return t.ENGINE.runKernel(r.Exp,{x:n})}});e.s(["exp",0,n])},90119,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({rsqrt_:function(e){let n=(0,a.convertToTensor)(e,"x","rsqrt","float32");return t.ENGINE.runKernel(r.Rsqrt,{x:n})}});e.s(["rsqrt",0,n])},551200,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({tile_:function(e,s){let i=(0,a.convertToTensor)(e,"x","tile","string_or_numeric");return n.assert(i.rank===s.length,()=>`Error in transpose: rank of input ${i.rank} must match length of reps ${s}.`),t.ENGINE.runKernel(r.Tile,{x:i},{reps:s})}});e.s(["tile",0,s])},691832,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({stack_:function(e,s=0){let i=(0,a.convertToTensorArray)(e,"tensors","stack","string_or_numeric");return n.assert(i.length>=1,()=>"Pass at least one tensor to tf.stack"),i.length>0&&n.assert(s<=i[0].rank,()=>"Axis must be <= rank of the tensor"),t.ENGINE.runKernel(r.Pack,i,{axis:s})}});e.s(["stack",0,s])},419426,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({unsortedSegmentSum_:function(e,s,i){let o=(0,a.convertToTensor)(e,"x","unsortedSegmentSum"),l=(0,a.convertToTensor)(s,"segmentIds","unsortedSegmentSum","int32");return(0,n.assert)((0,n.isInt)(i),()=>"numSegments must be of dtype int"),t.ENGINE.runKernel(r.UnsortedSegmentSum,{x:o,segmentIds:l},{numSegments:i})}});e.s(["unsortedSegmentSum",0,s])},101123,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(744877),n=e.i(240210),s=e.i(568503);let i=(0,e.i(566389).op)({greater_:function(e,i){let o=(0,n.convertToTensor)(e,"a","greater","string_or_numeric"),l=(0,n.convertToTensor)(i,"b","greater","string_or_numeric");[o,l]=(0,a.makeTypesMatch)(o,l),(0,s.assertAndGetBroadcastShape)(o.shape,l.shape);let u={a:o,b:l};return t.ENGINE.runKernel(r.Greater,u)}});e.s(["greater",0,i])},87432,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(744877),n=e.i(240210),s=e.i(568503);let i=(0,e.i(566389).op)({equal_:function(e,i){let o=(0,n.convertToTensor)(e,"a","equal","string_or_numeric"),l=(0,n.convertToTensor)(i,"b","equal","string_or_numeric");[o,l]=(0,a.makeTypesMatch)(o,l),(0,s.assertAndGetBroadcastShape)(o.shape,l.shape);let u={a:o,b:l};return t.ENGINE.runKernel(r.Equal,u)}});e.s(["equal",0,i])},388566,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(744877),n=e.i(240210),s=e.i(568503);let i=(0,e.i(566389).op)({less_:function(e,i){let o=(0,n.convertToTensor)(e,"a","less","string_or_numeric"),l=(0,n.convertToTensor)(i,"b","less","string_or_numeric");[o,l]=(0,a.makeTypesMatch)(o,l),(0,s.assertAndGetBroadcastShape)(o.shape,l.shape);let u={a:o,b:l};return t.ENGINE.runKernel(r.Less,u)}});e.s(["less",0,i])},394596,e=>{"use strict";var t=e.i(27923),r=e.i(496378),a=e.i(994152);e.s(["zeros",()=>function e(n,s="float32"){if((0,r.assertNonNegativeIntegerDimensions)(n),"complex64"===s){let t=e(n,"float32"),r=e(n,"float32");return(0,a.complex)(t,r)}let i=(0,r.makeZerosTypedArray)((0,r.sizeFromShape)(n),s);return t.ENGINE.makeTensor(i,n,s)}])},434425,e=>{"use strict";var t=e.i(27923),r=e.i(496378),a=e.i(994152),n=e.i(394596);e.s(["ones",()=>function e(s,i="float32"){if((0,r.assertNonNegativeIntegerDimensions)(s),"complex64"===i){let t=e(s,"float32"),r=(0,n.zeros)(s,"float32");return(0,a.complex)(t,r)}let o=(0,r.makeOnesTypedArray)((0,r.sizeFromShape)(s),i);return t.ENGINE.makeTensor(o,s,i)}])},606764,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({slice_:function(e,n,s){let i=(0,a.convertToTensor)(e,"x","slice","string_or_numeric");if(0===i.rank)throw Error("Slicing scalar is not possible");return t.ENGINE.runKernel(r.Slice,{x:i},{begin:n,size:s})}});e.s(["slice",0,n])},21637,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({floor_:function(e){let n=(0,a.convertToTensor)(e,"x","floor","float32");return t.ENGINE.runKernel(r.Floor,{x:n})}});e.s(["floor",0,n])},295175,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({unstack_:function(e,s=0){let i=(0,a.convertToTensor)(e,"x","unstack","string_or_numeric");return n.assert(s>=-i.shape.length&&s<i.shape.length,()=>`Axis = ${s} is not in [-${i.shape.length}, ${i.shape.length})`),t.ENGINE.runKernel(r.Unpack,{value:i},{axis:s})}});e.s(["unstack",0,s])},322459,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({log_:function(e){let n=(0,a.convertToTensor)(e,"x","log","float32");return t.ENGINE.runKernel(r.Log,{x:n})}});e.s(["log",0,n])},764128,e=>{"use strict";var t=e.i(496378);function r(e,r,a){let n=e.shape.length;t.assert(n===r.length,()=>`Error in slice${n}D: Length of begin ${r} must match the rank of the array (${n}).`),t.assert(n===a.length,()=>`Error in slice${n}D: Length of size ${a} must match the rank of the array (${n}).`);for(let s=0;s<n;++s)t.assert(r[s]+a[s]<=e.shape[s],()=>`Error in slice${n}D: begin[${s}] + size[${s}] (${r[s]+a[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function a(e){let t=[],r=0;for(;e>0;)1&e&&t.push(r),e/=2,r++;return t}function n(e,t,r){let a=[];for(let n=0;n<e.length;n++)a[n]=Math.ceil((t[n]-e[n])/r[n]);return a}function s(e,t,r,a){let n=[...e];for(let e=n.length;e<a.length;e++)n.push(1);for(let e=0;e<r;e++)0===e?n[t]=1:(n.splice(t,0,1),n.pop());return n}function i(e,t){let r=[];for(let a=0;a<e;a++)r.push(t+a);return r}function o(e,t,r,a,n,i,o,h,m){let f=e.length,g=Array(f),y=Array(f),b=Array(f);if(t.length&&r>0){let p=t[0],d=r+1;g=l(o,p,d,a,e),y=u(h,p,d,n,e),b=s(i,p,d,e)}else for(let t=0;t<f;t++)g[t]=d(o,a,i,e,t,m),y[t]=c(h,n,i,e,t,m),b[t]=p(i,t,m);return{begin:g,end:y,strides:b}}function l(e,t,r,a,n){let s=[...n],o=i(r,t);for(let n=0;n<s.length;n++)if(o.indexOf(n)>-1)s[n]=0;else{var l,u,p;let i=(l=t,u=r,(p=n)<=l?p:p-(u-1)),o=a[i];e&1<<i&&(o=0),s[n]=o}return s}function u(e,r,a,n,s){let o=[...s],l=i(a,r);for(let t=0;t<o.length;t++)if(l.indexOf(t)>-1)o[t]=Number.MAX_SAFE_INTEGER;else{var u,p,d;let s=(u=r,p=a,(d=t)<=u?d:d-(p-1)),i=n[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),o[t]=i}for(let e=0;e<o.length;e++){let r=s[e];o[e]<0&&(o[e]+=r),o[e]=t.clamp(0,o[e],s[e])}return o}function p(e,t,r){let a=e[t];return(r&1<<t||null==a)&&(a=1),a}function d(e,r,a,n,s,i){let o=r[s],l=a[s]||1;(e&1<<s||i&1<<s||null==o)&&(o=l>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let u=n[s];return o<0&&(o+=u),o=t.clamp(0,o,u-1)}function c(e,r,a,n,s,i){let o=r[s],l=a[s]||1;(e&1<<s||i&1<<s||null==o)&&(o=l>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let u=n[s];return o<0&&(o+=u),o=l>0?t.clamp(0,o,u):t.clamp(-1,o,u-1)}function h(e,t,r){let a=r.length;for(let e=0;e<r.length;e++)if(r[e]>1){a=e;break}for(let n=a+1;n<r.length;n++)if(t[n]>0||r[n]!==e[n])return!1;return!0}function m(e,t){let r=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)r+=e[a]*t[a];return r}function f(e,r,a){let n,s,i=e.shape.length;return(n="number"==typeof r?[r,...Array(i-1).fill(0)]:r.length<i?r.concat(Array(i-r.length).fill(0)):r.slice()).forEach(e=>{t.assert(-1!==e,()=>"slice() does not support negative begin indexing.")}),s=(s=null==a?Array(i).fill(-1):"number"==typeof a?[a,...Array(i-1).fill(-1)]:a.length<i?a.concat(Array(i-a.length).fill(-1)):a).map((r,a)=>r>=0?r:(t.assert(-1===r,()=>`Negative size values should be exactly -1 but got ${r} for the slice() size at index ${a}.`),e.shape[a]-n[a])),[n,s]}function g(e,t,r,a,n,s,i,o,l){let u;if(null==a?(u=Array(t.length)).fill(1):u=a,null!=i&&(i&i-1)!=0)throw Error("Multiple ellipses in slice is not allowed.");let p=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:r.slice(),strides:u.slice(),beginMask:n,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let e=0;e<d.dims;e++)p&&(1<<e&o)!=0&&d.numAddAxisAfterEllipsis++,1<<e&i&&(p=!0);!p&&(d.ellipsisMask|=1<<d.dims,d.dims++);let c={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};var h=d,m=c;m.beginMask=0,m.endMask=0,m.shrinkAxisMask=0;let f=0;m.beginValid=null!=h.begin,m.endValid=null!=h.end,m.begin=Array(m.dims),m.end=Array(m.dims),m.strides=Array(m.dims),m.finalShapeGatherIndices=[],m.finalShapeGatherIndicesSparse=[],m.inputShapeGatherIndicesSparse=Array(m.dims);for(let e=0;e<h.dims;e++)if(1<<e&h.ellipsisMask){let t=Math.min(m.dims-(h.dims-e)+1+h.numAddAxisAfterEllipsis,m.dims);for(;f<t;f++)m.begin[f]=0,m.end[f]=0,m.strides[f]=1,m.beginMask|=1<<f,m.endMask|=1<<f,m.finalShapeGatherIndices.push(f),m.finalShapeGatherIndicesSparse.push(-1),m.inputShapeGatherIndicesSparse[f]=e}else if(1<<e&h.newAxisMask)m.finalShapeGatherIndices.push(-2),m.finalShapeGatherIndicesSparse.push(-1);else{if(f===m.begin.length)throw Error(`Index out of range using input dim ${f}; input has only ${m.dims} dims, ${m.begin.length}.`);null!=h.begin&&(m.begin[f]=h.begin[e]),null!=h.end&&(m.end[f]=h.end[e]),m.strides[f]=h.strides[e],h.beginMask&1<<e&&(m.beginMask|=1<<f),h.endMask&1<<e&&(m.endMask|=1<<f),h.shrinkAxisMask&1<<e?(m.finalShapeGatherIndices.push(-1),m.finalShapeGatherIndicesSparse.push(-1),m.shrinkAxisMask|=1<<f):(m.finalShapeGatherIndices.push(f),m.finalShapeGatherIndicesSparse.push(e)),m.inputShapeGatherIndicesSparse[f]=e,f++}let g=!0,b=!0,T=!0,v=[],N=[];for(let t=0;t<e.length;++t){let r;if(0===c.strides[t])throw Error(`strides[${t}] must be non-zero`);let a=!!(c.shrinkAxisMask&1<<t),n=e[t];if(-1===n){v.push(a?1:-1);continue}let s=[c.beginMask&1<<t,c.endMask&1<<t],i=[c.strides[t]>0?0:-1,c.strides[t]>0?n:n-1];if(a&&c.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");T=T&&1===c.strides[t];let o=!!(c.beginMask&1<<t&&c.endMask&1<<t);if(c.beginValid&&c.endValid){if(a){let e=c.begin[t]<0?n+c.begin[t]:c.begin[t];if(c.begin[t]=e,c.end[t]=c.begin[t]+1,e<0||e>=n)throw Error(`slice index ${c.begin[t]} of dimension ${t} out of bounds.`)}else c.begin[t]=y(c.begin[t],0,c.strides[t],n,s,i),c.end[t]=y(c.end[t],1,c.strides[t],n,s,i);let e=1===c.strides[t]&&0===c.begin[t]&&c.end[t]===n;g=g&&e,b=b&&(0===t&&1===c.strides[t]||e)}else g=g&&1===c.strides[t]&&o,b=b&&(0===t&&1===c.strides[t]||o);let l=!1;if(c.beginValid&&c.endValid?(r=c.end[t]-c.begin[t],l=!0):a?(r=1,l=!0):o&&n>=0&&(r=c.strides[t]<0?-n:n,l=!0),l){let e;e=0===r||r<0!=c.strides[t]<0?0:Math.trunc(r/c.strides[t])+ +(r%c.strides[t]!=0),v.push(e)}else v.push(-1)}for(let e=0;e<c.finalShapeGatherIndices.length;++e){let t=c.finalShapeGatherIndices[e];t>=0?N.push(v[t]):-2===t&&N.push(1)}return{finalShapeSparse:N.filter((e,t)=>-2!==c.finalShapeGatherIndices[t]),finalShape:N,isIdentity:g,sliceDim0:b,isSimpleSlice:T,begin:c.begin,end:c.end,strides:c.strides}}function y(e,t,r,a,n,s){if(n[t])return r>0?s[t]:s[t+1&1];{let t=e<0?a+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}e.s(["assertParamsValid",()=>r,"computeFlatOffset",()=>m,"computeOutShape",()=>n,"getNormalizedAxes",()=>o,"isSliceContinous",()=>h,"maskToAxes",()=>a,"parseSliceParams",()=>f,"sliceInfo",()=>g,"startForAxis",()=>d,"startIndicesWithElidedDims",()=>l,"stopForAxis",()=>c,"stopIndicesWithElidedDims",()=>u,"stridesForAxis",()=>p,"stridesWithElidedDims",()=>s])},75192,264616,947418,329361,e=>{"use strict";var t=e.i(111613);e.i(764128);var r=e.i(496378);function a(e){return e<=30?e:(0,r.nearestDivisor)(e,Math.floor(Math.sqrt(e)))}function n(e,t){let a,n=!1;for(e<=30?(a=e,n=!0):a=(0,r.nearestDivisor)(e,Math.floor(Math.sqrt(e)));!n;)a>t||a===e?n=!0:a=(0,r.nearestDivisor)(e,a+1);return a}function s(e,t,r){let a=[],n=e.length;for(let s=0;s<n;s++)s!==t?a.push(e[s]):a.push(r);return a}function i(e,t,r,a){let n=t.shape.length,s=e.shape.length;if(0!==a&&(a<-n||a>n))throw Error(`Expect batchDims in the range of [-${n}, ${n}], but got ${a}`);if(a<0&&(a+=n),a>s)throw Error(`batchDims (${a}) must be less than rank(x) (
    ${s}).`);if(r<a)throw Error(`batchDims (${a}) must be less than or equal to axis (${r}).`);for(let r=0;r<a;++r)if(e.shape[r]!==t.shape[r])throw Error(`x.shape[${r}]: ${e.shape[r]} should be equal to indices.shape[${r}]: ${t.shape[r]}.`);let i=e.shape[r],o=[],l=1,u=1,p=1;for(let t=0;t<a;++t)o.push(e.shape[t]),l*=e.shape[t];for(let t=a;t<r;t++)o.push(e.shape[t]),u*=e.shape[t];for(let e=a;e<n;e++)o.push(t.shape[e]);for(let t=r+1;t<s;t++)o.push(e.shape[t]),p*=e.shape[t];return{batchSize:l,sliceSize:p,outerSize:u,dimSize:i,outputShape:o}}function o(e){try{return e.map(e=>(0,t.decodeString)(e))}catch(e){throw Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function l(e){return e.map(e=>(0,t.encodeString)(e))}function u(e,t){let a=e[0].length;e.forEach((e,t)=>{r.assert(e.length===a,()=>`Error in concat${a}D: rank of tensors[${t}] must be the same as the rank of the rest (${a})`)}),r.assert(t>=0&&t<a,()=>`Error in concat${a}D: axis must be between 0 and ${a-1}.`);let n=e[0];e.forEach((e,s)=>{for(let i=0;i<a;i++)r.assert(i===t||e[i]===n[i],()=>`Error in concat${a}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function p(e,t){let r=e[0].slice();for(let a=1;a<e.length;a++)r[t]+=e[a][t];return r}e.s(["PARALLELIZE_THRESHOLD",0,30,"computeOptimalWindowSize",()=>a],264616),e.s(["collectGatherOpShapeInfo",()=>i,"computeOutShape",()=>s,"segOpComputeOptimalWindowSize",()=>n],947418),e.i(947418),e.s(["fromStringArrayToUint8",()=>l,"fromUint8ToStringArray",()=>o],75192),e.s(["assertParamsConsistent",()=>u,"computeOutShape",()=>p],329361)},746814,872606,145018,539333,98856,846141,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({elu_:function(e){let n=(0,a.convertToTensor)(e,"x","elu","float32");return t.ENGINE.runKernel(r.Elu,{x:n})}});e.s(["elu",0,s],746814);let i=(0,n.op)({leakyRelu_:function(e,n=.2){let s=(0,a.convertToTensor)(e,"x","leakyRelu");return t.ENGINE.runKernel(r.LeakyRelu,{x:s},{alpha:n})}});e.s(["leakyRelu",0,i],872606);let o=(0,n.op)({prelu_:function(e,n){let s=(0,a.convertToTensor)(e,"x","prelu"),i=(0,a.convertToTensor)(n,"alpha","prelu");return t.ENGINE.runKernel(r.Prelu,{x:s,alpha:i})}});e.s(["prelu",0,o],145018);let l=(0,n.op)({relu_:function(e){let n=(0,a.convertToTensor)(e,"x","relu");return t.ENGINE.runKernel(r.Relu,{x:n})}});e.s(["relu",0,l],539333);let u=(0,n.op)({relu6_:function(e){let n=(0,a.convertToTensor)(e,"x","relu6");return t.ENGINE.runKernel(r.Relu6,{x:n})}});e.s(["relu6",0,u],98856);let p=(0,n.op)({sigmoid_:function(e){let n=(0,a.convertToTensor)(e,"x","sigmoid","float32");return t.ENGINE.runKernel(r.Sigmoid,{x:n})}});e.s(["sigmoid",0,p],846141)},952702,e=>{"use strict";var t=e.i(568503),r=e.i(746814),a=e.i(872606),n=e.i(449404),s=e.i(145018),i=e.i(539333),o=e.i(98856),l=e.i(940570),u=e.i(846141),p=e.i(311709),d=e.i(101669);function c(e,t,r){if(null==r||"linear"===r)return e;if("relu"===r)return(0,n.mul)(e,(0,p.step)(t));throw Error(`Cannot compute gradient for fused activation ${r}.`)}function h(e,r){let a=r,n=t.getReductionAxes(e.shape,r.shape);return n.length>0&&(a=(0,d.sum)(a,n)),(0,l.reshape)(a,e.shape)}function m(e,t,n,l){if("linear"===t)return e;if("relu"===t)return(0,i.relu)(e);if("elu"===t)return(0,r.elu)(e);if("relu6"===t)return(0,o.relu6)(e);if("prelu"===t)return(0,s.prelu)(e,n);else if("leakyrelu"===t)return(0,a.leakyRelu)(e,l);else if("sigmoid"===t)return(0,u.sigmoid)(e);throw Error(`Unknown fused activation ${t}.`)}e.s(["applyActivation",()=>m,"getFusedBiasGradient",()=>h,"getFusedDyActivation",()=>c,"shouldFuse",0,(e,t)=>!(e>0)||"linear"===t])},31733,159334,633229,552007,e=>{"use strict";var t,r;function a(e,t,r){let a=[];if(null==r&&null==t)return a;if(null==t)for(;a.length<e+r.length;)a.push(-1);else a=t.slice();if(null==r)return a;if(e+r.length!==a.length)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+r.length}, but shape.rank = ${a.length}`);for(let n=1;n<r.length;++n){let s=r[n],i=a[a.length-r.length+n],o=a[i];if(s>=0)if(o>=0){if(o!==s)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${n+e}] = ${s} but shape[${n+e}] = ${o}`)}else a[i]=s}return a}function n(e){let r={FIRST_DIM_SIZE:t.FIRST_DIM_SIZE,VALUE_ROWIDS:t.VALUE_ROWIDS,ROW_LENGTHS:t.ROW_LENGTHS,ROW_SPLITS:t.ROW_SPLITS,ROW_LIMITS:t.ROW_LIMITS,ROW_STARTS:t.ROW_STARTS},a=[];for(let t of e)if(t in r)a.push(r[t]);else break;return a}function s(e){return 0===e.length?0:e[0]===t.FIRST_DIM_SIZE?e.length-1:e.length}function i(e,t){if(null==e||null==t)return;let r=e.length,a=t.length;if(r>=a)throw Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${r} must be less than ragged tensor input flatValues.rank = ${a})`);for(let n=0;n<Math.min(r,a-1);++n){let r=e[n],a=t[n+1];if(r>=0&&a>=0&&1!==r&&r!==a)throw Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${n-e.length}] = ${r} but ragged tensor input.flatValues.shape[${n-e.length}] = ${a}`)}}function o(e,t,r){return[r*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function l(e,t,r,a=!0){let n=[];if(a)(n=n.concat(t.slice(0))).push(e[0]/r),n=n.concat(e.slice(1));else{n=n.concat(e[0]);let r=t.length;for(let a=0;a<r;++a)n=n.concat([e[a+1]/t[a],t[a]]);n=n.concat(e.slice(r+1))}return n}function u(e,t,r=!0){let a=[];if(r){a.push(t);for(let r=t+1;r<e;++r)r<=2*t?(a.push(r),a.push(r-(t+1))):a.push(r)}else{let r=[],n=[];for(let a=1;a<e;++a)a>=2*t+1||a%2==1?n.push(a):r.push(a);a.push(...r),a.push(0),a.push(...n)}return a}function p(e,t,r,a=!0){let n=[];a?n.push(e[0]/r):n.push(e[0]*r);for(let r=1;r<e.length;++r)r<=t.length?a?n.push(t[r-1]*e[r]):n.push(e[r]/t[r-1]):n.push(e[r]);return n}function d(e,t){let r=[0];for(let a=0;a<t;++a)r.push(e[a][0]);return r}function c(e,t,r){let a=e.slice(0,1);for(let n=0;n<r;++n)a.push(e[n+1]-t[n][0]-t[n][1]);return a}e.s([],31733),(r=t||(t={}))[r.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",r[r.VALUE_ROWIDS=1]="VALUE_ROWIDS",r[r.ROW_LENGTHS=2]="ROW_LENGTHS",r[r.ROW_SPLITS=3]="ROW_SPLITS",r[r.ROW_LIMITS=4]="ROW_LIMITS",r[r.ROW_STARTS=5]="ROW_STARTS",e.s(["RowPartitionType",()=>t,"combineRaggedTensorToTensorShapes",()=>a,"getRaggedRank",()=>s,"getRowPartitionTypesHelper",()=>n,"validateDefaultValueShape",()=>i],159334),e.s(["getImageCenter",()=>o],633229),e.s(["getPermuted",()=>u,"getReshaped",()=>l,"getReshapedPermuted",()=>p,"getSliceBeginCoords",()=>d,"getSliceSize",()=>c],552007)},17537,e=>{"use strict";var t=e.i(496378);function r(e,r){let a=e.shape.length,n=r.shape.length;if(a<1)throw Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${a}.`);if(n<1)throw Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if("int32"!==r.dtype)throw Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.shape[n-1]>a)throw Error(`index innermost dimension length must be <= tensor rank; saw: ${r.shape[n-1]} vs. ${a}`);if(0===(0,t.sizeFromShape)(e.shape))throw Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let s=r.shape,i=s[s.length-1],o=1;for(let e=0;e<s.length-1;++e)o*=s[e];let l=e.shape,u=s.slice();u.pop();let p=1;for(let e=i;e<a;++e)p*=l[e],u.push(l[e]);let d=[...(0,t.computeStrides)(e.shape).map(e=>e/p),1].slice(0,i);return[u,o,p,d]}e.s(["prepareAndValidate",()=>r])},782826,e=>{"use strict";var t=e.i(496378);function r(e,t,r){let a=t.rank>1?t.shape[t.rank-1]:1,n=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${r.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${n}.`;if(r.rank<n)throw Error(s+` update.rank < ${n}. `);if(e.length<a+(r.rank-n))throw Error(s+` Output shape length < ${a+(r.rank-n)}`);if(r.rank!==n+e.length-a)throw Error(s+` update.rank != ${n+e.length-a}`);for(let e=0;e<n;++e)if(r.shape[e]!==t.shape[e])throw Error(s+` updates.shape[${e}] (${r.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<r.rank-n;++t)if(r.shape[t+n]!==e[t+a])throw Error(s+` updates.shape[${t+n}] (${r.shape[t+n]}) != shape[${t+n}] (${e[t+n]})`)}function a(e,t,a){if(t.rank<1)throw Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(a.length<1)throw Error(`Output rank must be greater or equal to 1, but got shape: ${a}`);if(0===a.length){if(0===t.size)throw Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw Error(`Updates specified for empty output. updates shape: ${e.shape}`)}r(a,t,e)}function n(e,r,a){let n=r.shape.length,s=n>1?r.shape[n-1]:1,i=a.length,o=1;for(let e=s;e<i;++e)o*=a[e];let l=s<1?1:s,u=(0,t.sizeFromShape)(r.shape)/l,p=[...(0,t.computeStrides)(a.slice(0,s)),1];return{sliceRank:s,numUpdates:u,sliceSize:o,strides:p,outputSize:(0,t.sizeFromShape)(a)}}e.s(["calculateShapes",()=>n,"validateInput",()=>a,"validateUpdateShape",()=>r])},829918,612499,e=>{"use strict";var t=e.i(75192),r=e.i(769664),a=e.i(568503),n=e.i(329361),s=e.i(870360),i=e.i(952702);e.i(31733);var o=e.i(159334),l=e.i(264616),u=e.i(764128),p=e.i(320281),d=e.i(633229),c=e.i(552007),h=e.i(17537),m=e.i(782826);e.s(["SELU_SCALE",0,1.0507009873554805,"SELU_SCALEALPHA",0,1.7580993408473768],612499),e.i(612499),e.s(["ERF_A1",0,.254829592,"ERF_A2",0,-.284496736,"ERF_A3",0,1.421413741,"ERF_A4",0,-1.453152027,"ERF_A5",0,1.061405429,"ERF_P",0,.3275911],334174),e.i(334174);var f=e.i(223806);function g(e,t){if(e.length!==t.length)throw Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let r=new Float32Array(2*e.length);for(let a=0;a<r.length;a+=2)r[a]=e[a/2],r[a+1]=t[a/2];return r}function y(e){let t=new Float32Array(e.length/2),r=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],r[a/2]=e[a+1];return{real:t,imag:r}}function b(e){let t=Math.ceil(e.length/4),r=new Float32Array(t),a=new Float32Array(t);for(let t=0;t<e.length;t+=4)r[Math.floor(t/4)]=e[t],a[Math.floor(t/4)]=e[t+1];return{real:r,imag:a}}function T(e){let t=Math.floor(e.length/4),r=new Float32Array(t),a=new Float32Array(t);for(let t=2;t<e.length;t+=4)r[Math.floor(t/4)]=e[t],a[Math.floor(t/4)]=e[t+1];return{real:r,imag:a}}function v(e,t){return{real:e[2*t],imag:e[2*t+1]}}function N(e,t,r,a){e[2*a]=t,e[2*a+1]=r}function x(e,t){let r=new Float32Array(e/2),a=new Float32Array(e/2);for(let n=0;n<Math.ceil(e/2);n++){let s=(t?2:-2)*Math.PI*(n/e);r[n]=Math.cos(s),a[n]=Math.sin(s)}return{real:r,imag:a}}function S(e,t,r){let a=(r?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}e.s(["assignToTypedArray",()=>N,"complexWithEvenIndex",()=>b,"complexWithOddIndex",()=>T,"exponent",()=>S,"exponents",()=>x,"getComplexWithIndex",()=>v,"mergeRealAndImagArrays",()=>g,"splitRealAndImagArrays",()=>y],910428),e.i(910428);var E=e.i(496378);let w=/->/g;function k(e,t){let r=((e=e.replace(/\s/g,"")).length-e.replace(w,"").length)/2;if(r<1)throw Error("Equations without an arrow are not supported.");if(r>1)throw Error('Equation must contain exactly one arrow ("->").');let[a,n]=e.split("->");(0,E.assert)(-1===a.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');let s=a.split(","),i=s.length;if(t!==i)throw Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let e=0;e<n.length;++e){let t=n[e];if(!s.some(e=>-1!==e.indexOf(t)))throw Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let e=0;e<a.length;++e){let t=a[e];-1===o.indexOf(t)&&","!==t&&o.push(t)}let l=Array(s.length);for(let e=0;e<i;++e){if(new Set(s[e].split("")).size!==s[e].length)throw Error(`Found duplicate axes in input component ${s[e]}. Support for duplicate axes in input is not implemented yet.`);l[e]=[];for(let t=0;t<s[e].length;++t)l[e].push(o.indexOf(s[e][t]))}let u=o.length,p=n.length,d=[];for(let e=p;e<u;++e)d.push(e);return{allDims:o,summedDims:d,idDims:l}}function I(e,t){let r=Array(e);r.fill(-1);for(let e=0;e<t.length;++e)r[t[e]]=e;let a=[];for(let t=0;t<e;++t)-1===r[t]&&a.push(t);return{permutationIndices:r=r.filter(e=>-1!==e),expandDims:a}}function A(e,t,r){let a=Array(e);for(let e=0;e<r.length;++e){let n=r[e].shape;for(let r=0;r<t[e].length;++r)void 0===a[t[e][r]]?a[t[e][r]]=n[r]:(0,E.assert)(a[t[e][r]]===n[r],()=>`Expected dimension ${a[t[e][r]]} at axis ${r} of input shaped ${JSON.stringify(n)}, but got dimension ${n[r]}`)}}function P(e,t){let r=[],a=0;0===e.length&&e.push(-1),a=e.length+1;for(let e=0;e<a;++e)r.push([]);let n=[];for(let a=0;a<e.length;++a)for(let s of function(e,t){let r=[];for(let a=0;a<e.length;++a)(0===e[a].length||-1!==e[a].indexOf(t)||-1===t)&&r.push(a);return r}(t,e[a]))-1===n.indexOf(s)&&(r[a].push(s),n.push(s));return{path:e,steps:r}}function M(e){return e.every((e,t)=>e===t)}function _(e,t,r=0){let a=[];if("number"==typeof t)(0,E.assert)(e.shape[r]%t==0,()=>"Number of splits must evenly divide the axis."),a=Array(t).fill(e.shape[r]/t);else{let n=t.reduce((e,t)=>(-1===t&&(e+=1),e),0);(0,E.assert)(n<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(-1!==s){let a=t.reduce((e,t)=>t>0?e+t:e);t[s]=e.shape[r]-a}(0,E.assert)(e.shape[r]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),a=t}return a}function V(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function D(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function $(e,t,r){return`indices(${e}, 0) is invalid: ${t} >= ${r}`}function O(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function R(e,t){return`size ${e} must be non-negative, not ${t}`}function F(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function C(e,t){let r=(0,E.sizeFromShape)(e),a=(0,E.sizeFromShape)(t);return`Input to reshape is a SparseTensor with ${r}
  dense values, but the requested shape requires a multiple of ${a}. inputShape=${e} outputShape= ${t}`}function B(e,t){let r=(0,E.sizeFromShape)(e),a=(0,E.sizeFromShape)(t);return`Input to reshape is a tensor with ${r} dense values, but the requested shape has ${a}. inputShape=${e} outputShape=${t}`}function L(){return"segment ids must be >= 0"}function G(){return"segment ids are not increasing"}function z(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function U(e,t,r){return`Bad: indices[${e}] == ${t} out of range [0, ${r})`}e.s(["checkEinsumDimSizes",()=>A,"decodeEinsumEquation",()=>k,"getEinsumComputePath",()=>P,"getEinsumPermutation",()=>I,"isIdentityPermutation",()=>M],966770),e.i(966770),e.s(["prepareSplitSize",()=>_],637583),e.i(637583),e.s(["getSparseFillEmptyRowsIndicesDenseShapeMismatch",()=>V,"getSparseFillEmptyRowsNegativeIndexErrorMessage",()=>D,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",()=>$],875794),e.i(875794),e.s(["getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",()=>F,"getSparseReshapeInputOutputMismatchErrorMessage",()=>B,"getSparseReshapeInputOutputMultipleErrorMessage",()=>C,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",()=>O,"getSparseReshapeNegativeOutputDimErrorMessage",()=>R],653943),e.i(653943),e.s(["getSparseSegmentReductionIndicesOutOfRangeErrorMessage",()=>U,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",()=>L,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",()=>G,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",()=>z],50668),e.i(50668);var q=e.i(947418);e.s(["ERF_A1",0,.254829592,"ERF_A2",0,-.284496736,"ERF_A3",0,1.421413741,"ERF_A4",0,-1.453152027,"ERF_A5",0,1.061405429,"ERF_P",0,.3275911,"PARALLELIZE_THRESHOLD",()=>l.PARALLELIZE_THRESHOLD,"RowPartitionType",()=>o.RowPartitionType,"SELU_SCALE",0,1.0507009873554805,"SELU_SCALEALPHA",0,1.7580993408473768,"applyActivation",()=>i.applyActivation,"assertAndGetBroadcastShape",()=>a.assertAndGetBroadcastShape,"assertAxesAreInnerMostDims",()=>r.assertAxesAreInnerMostDims,"assertParamsConsistent",()=>n.assertParamsConsistent,"assignToTypedArray",()=>N,"axesAreInnerMostDims",()=>r.axesAreInnerMostDims,"calculateShapes",()=>m.calculateShapes,"checkEinsumDimSizes",()=>A,"checkPadOnDimRoundingMode",()=>s.checkPadOnDimRoundingMode,"combineLocations",()=>r.combineLocations,"combineRaggedTensorToTensorShapes",()=>o.combineRaggedTensorToTensorShapes,"complexWithEvenIndex",()=>b,"complexWithOddIndex",()=>T,"computeConv2DInfo",()=>s.computeConv2DInfo,"computeConv3DInfo",()=>s.computeConv3DInfo,"computeDefaultPad",()=>s.computeDefaultPad,"computeDilation2DInfo",()=>s.computeDilation2DInfo,"computeOptimalWindowSize",()=>l.computeOptimalWindowSize,"computeOutAndReduceShapes",()=>r.computeOutAndReduceShapes,"computeOutShape",()=>n.computeOutShape,"computePool2DInfo",()=>s.computePool2DInfo,"computePool3DInfo",()=>s.computePool3DInfo,"convertConv2DDataFormat",()=>s.convertConv2DDataFormat,"decodeEinsumEquation",()=>k,"eitherStridesOrDilationsAreOne",()=>s.eitherStridesOrDilationsAreOne,"expandShapeToKeepDim",()=>r.expandShapeToKeepDim,"exponent",()=>S,"exponents",()=>x,"fromStringArrayToUint8",()=>t.fromStringArrayToUint8,"fromUint8ToStringArray",()=>t.fromUint8ToStringArray,"getAxesPermutation",()=>r.getAxesPermutation,"getBroadcastDims",()=>a.getBroadcastDims,"getComplexWithIndex",()=>v,"getEinsumComputePath",()=>P,"getEinsumPermutation",()=>I,"getFusedBiasGradient",()=>i.getFusedBiasGradient,"getFusedDyActivation",()=>i.getFusedDyActivation,"getImageCenter",()=>d.getImageCenter,"getInnerMostAxes",()=>r.getInnerMostAxes,"getPermuted",()=>c.getPermuted,"getRaggedRank",()=>o.getRaggedRank,"getReductionAxes",()=>a.getReductionAxes,"getReshaped",()=>c.getReshaped,"getReshapedPermuted",()=>c.getReshapedPermuted,"getRowPartitionTypesHelper",()=>o.getRowPartitionTypesHelper,"getSliceBeginCoords",()=>c.getSliceBeginCoords,"getSliceSize",()=>c.getSliceSize,"getSparseFillEmptyRowsIndicesDenseShapeMismatch",()=>V,"getSparseFillEmptyRowsNegativeIndexErrorMessage",()=>D,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",()=>$,"getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",()=>F,"getSparseReshapeInputOutputMismatchErrorMessage",()=>B,"getSparseReshapeInputOutputMultipleErrorMessage",()=>C,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",()=>O,"getSparseReshapeNegativeOutputDimErrorMessage",()=>R,"getSparseSegmentReductionIndicesOutOfRangeErrorMessage",()=>U,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",()=>L,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",()=>G,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",()=>z,"getUndoAxesPermutation",()=>r.getUndoAxesPermutation,"isIdentityPermutation",()=>M,"log",()=>f.log,"mergeRealAndImagArrays",()=>g,"prepareAndValidate",()=>h.prepareAndValidate,"prepareSplitSize",()=>_,"segment_util",0,q,"shouldFuse",()=>i.shouldFuse,"slice_util",0,u,"splitRealAndImagArrays",()=>y,"stridesOrDilationsArePositive",()=>s.stridesOrDilationsArePositive,"tupleValuesAreOne",()=>s.tupleValuesAreOne,"upcastType",()=>p.upcastType,"validateDefaultValueShape",()=>o.validateDefaultValueShape,"validateInput",()=>m.validateInput,"validateUpdateShape",()=>m.validateUpdateShape,"warn",()=>f.warn],829918)},504785,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({cumprod_:function(e,n=0,s=!1,i=!1){let o=(0,a.convertToTensor)(e,"x","cumprod");return t.ENGINE.runKernel(r.Cumprod,{x:o},{axis:n,exclusive:s,reverse:i})}});e.s(["cumprod",0,n])},185876,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({reverse_:function(e,n){let s=(0,a.convertToTensor)(e,"x","reverse");return t.ENGINE.runKernel(r.Reverse,{x:s},{dims:n})}});e.s(["reverse",0,n])},705680,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({logicalNot_:function(e){let n=(0,a.convertToTensor)(e,"x","logicalNot","bool");return t.ENGINE.runKernel(r.LogicalNot,{x:n})}});e.s(["logicalNot",0,n])},795894,777815,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({cos_:function(e){let n=(0,a.convertToTensor)(e,"x","cos","float32");return t.ENGINE.runKernel(r.Cos,{x:n})}});e.s(["cos",0,s],795894);let i=(0,n.op)({cosh_:function(e){let n=(0,a.convertToTensor)(e,"x","cosh","float32");return t.ENGINE.runKernel(r.Cosh,{x:n})}});e.s(["cosh",0,i],777815)},661193,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({pad_:function(e,n,s=0){let i=(0,a.convertToTensor)(e,"x","pad");if(0===i.rank)throw Error("pad(scalar) is not defined. Pass non-scalar to pad");return t.ENGINE.runKernel(r.PadV2,{x:i},{paddings:n,constantValue:s})}});e.s(["pad",0,n])},657626,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({batchToSpaceND_:function(e,s,i){let o=(0,a.convertToTensor)(e,"x","batchToSpaceND"),l=s.reduce((e,t)=>e*t);return n.assert(o.rank>=1+s.length,()=>`input rank is ${o.rank} but should be > than blockShape.length ${s.length}`),n.assert(i.length===s.length,()=>`crops.length is ${i.length} but should be equal to blockShape.length  ${s.length}`),n.assert(o.shape[0]%l==0,()=>`input tensor batch is ${o.shape[0]} but is not divisible by the product of the elements of blockShape ${s.join(" * ")} === ${l}`),t.ENGINE.runKernel(r.BatchToSpaceND,{x:o},{blockShape:s,crops:i})}});e.s(["batchToSpaceND",0,s])},655015,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(612930);let i=(0,e.i(566389).op)({concat_:function(e,i=0){(0,n.assert)(e.length>=1,()=>"Pass at least one tensor to concat");let o=(0,a.convertToTensorArray)(e,"tensors","concat","string_or_numeric");return("complex64"===o[0].dtype&&o.forEach(e=>{if("complex64"!==e.dtype)throw Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${e.dtype}. `)}),1===o.length)?(0,s.clone)(o[0]):t.ENGINE.runKernel(r.Concat,o,{axis:i})}});e.s(["concat",0,i])},40827,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({expandDims_:function(e,s=0){let i=(0,a.convertToTensor)(e,"x","expandDims","string_or_numeric");return n.assert(s<=i.rank,()=>"Axis must be <= rank of the tensor"),t.ENGINE.runKernel(r.ExpandDims,{input:i},{dim:s})}});e.s(["expandDims",0,s])},81936,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({gather_:function(e,n,s=0,i=0){let o=(0,a.convertToTensor)(e,"x","gather"),l=(0,a.convertToTensor)(n,"indices","gather","int32");return t.ENGINE.runKernel(r.GatherV2,{x:o,indices:l},{axis:s,batchDims:i})}});e.s(["gather",0,n])},873663,176885,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({acos_:function(e){let n=(0,a.convertToTensor)(e,"x","acos");return t.ENGINE.runKernel(r.Acos,{x:n})}});e.s(["acos",0,s],873663);let i=(0,n.op)({acosh_:function(e){let n=(0,a.convertToTensor)(e,"x","acosh");return t.ENGINE.runKernel(r.Acosh,{x:n})}});e.s(["acosh",0,i],176885)},941826,644551,394472,51106,764563,791124,846199,119947,300320,281991,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({all_:function(e,n=null,s=!1){let i=(0,a.convertToTensor)(e,"x","all","bool");return t.ENGINE.runKernel(r.All,{x:i},{axis:n,keepDims:s})}});e.s(["all",0,s],941826);let i=(0,n.op)({any_:function(e,n=null,s=!1){let i=(0,a.convertToTensor)(e,"x","any","bool");return t.ENGINE.runKernel(r.Any,{x:i},{axis:n,keepDims:s})}});e.s(["any",0,i],644551);let o=(0,n.op)({argMax_:function(e,n=0){let s=(0,a.convertToTensor)(e,"x","argMax");return t.ENGINE.runKernel(r.ArgMax,{x:s},{axis:n})}});e.s(["argMax",0,o],394472);let l=(0,n.op)({argMin_:function(e,n=0){let s=(0,a.convertToTensor)(e,"x","argMin");return t.ENGINE.runKernel(r.ArgMin,{x:s},{axis:n})}});e.s(["argMin",0,l],51106);let u=(0,n.op)({asin_:function(e){let n=(0,a.convertToTensor)(e,"x","asin");return t.ENGINE.runKernel(r.Asin,{x:n})}});e.s(["asin",0,u],764563);let p=(0,n.op)({asinh_:function(e){let n=(0,a.convertToTensor)(e,"x","asinh");return t.ENGINE.runKernel(r.Asinh,{x:n})}});e.s(["asinh",0,p],791124);let d=(0,n.op)({atan_:function(e){let n=(0,a.convertToTensor)(e,"x","atan");return t.ENGINE.runKernel(r.Atan,{x:n})}});e.s(["atan",0,d],846199);var c=e.i(744877);let h=(0,n.op)({atan2_:function(e,n){let s=(0,a.convertToTensor)(e,"a","atan2"),i=(0,a.convertToTensor)(n,"b","atan2");[s,i]=(0,c.makeTypesMatch)(s,i);let o={a:s,b:i};return t.ENGINE.runKernel(r.Atan2,o)}});e.s(["atan2",0,h],119947);let m=(0,n.op)({atanh_:function(e){let n=(0,a.convertToTensor)(e,"x","atanh");return t.ENGINE.runKernel(r.Atanh,{x:n})}});e.s(["atanh",0,m],300320);var f=e.i(496378),g=e.i(494096),y=e.i(870360),b=e.i(940570);let T=(0,n.op)({avgPool_:function(e,n,s,i,o){let l=(0,a.convertToTensor)(e,"x","avgPool","float32");f.assert(y.eitherStridesOrDilationsAreOne(s,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);let u=l,p=!1;3===l.rank&&(p=!0,u=(0,b.reshape)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),f.assert(4===u.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${u.rank}.`),y.checkPadOnDimRoundingMode("avgPool",i,o);let d={x:u},c=t.ENGINE.runKernel(r.AvgPool,d,{filterSize:n,strides:s,pad:i,dimRoundingMode:o});return(c=(0,g.cast)(c,l.dtype),p)?(0,b.reshape)(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});e.s(["avgPool",0,T],281991)},394503,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(940570);let i=(0,e.i(566389).op)({batchNorm_:function(e,i,o,l,u,p){let d,c;null==p&&(p=.001);let h=(0,a.convertToTensor)(e,"x","batchNorm"),m=(0,a.convertToTensor)(i,"mean","batchNorm"),f=(0,a.convertToTensor)(o,"variance","batchNorm");null!=u&&(d=(0,a.convertToTensor)(u,"scale","batchNorm")),null!=l&&(c=(0,a.convertToTensor)(l,"offset","batchNorm")),n.assert(m.rank===f.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),n.assert(null==c||m.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),n.assert(null==d||m.rank===d.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let g={x:0===h.rank||1===h.rank?(0,s.reshape)(h,[1,1,1,h.size]):2===h.rank?(0,s.reshape)(h,[1,1,h.shape[0],h.shape[1]]):3===h.rank?(0,s.reshape)(h,[1,h.shape[0],h.shape[1],h.shape[2]]):h,scale:d,offset:c,mean:m,variance:f},y={varianceEpsilon:p},b=t.ENGINE.runKernel(r.FusedBatchNorm,g,y);return(0,s.reshape)(b,h.shape)}});e.s(["batchNorm",0,i],394503)},556422,582343,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({ceil_:function(e){let n=(0,a.convertToTensor)(e,"x","ceil","float32");return t.ENGINE.runKernel(r.Ceil,{x:n})}});e.s(["ceil",0,s],556422);var i=e.i(496378),o=e.i(419886);let l=(0,n.op)({clipByValue_:function(e,n,s){let l=(0,a.convertToTensor)(e,"x","clipByValue");return(i.assert(n<=s,()=>`Error in clip: min (${n}) must be less than or equal to max (${s}).`),n===s)?(0,o.fill)(l.shape,n,l.dtype):t.ENGINE.runKernel(r.ClipByValue,{x:l},{clipValueMin:n,clipValueMax:s})}});e.s(["clipByValue",0,l],582343)},894983,599829,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(673749),n=e.i(870360),s=e.i(566389),i=e.i(940570);let o=(0,s.op)({conv1d_:function(e,s,o,l,u="NWC",p=1,d){let c=(0,t.convertToTensor)(e,"x","conv1d"),h=(0,t.convertToTensor)(s,"filter","conv1d"),m=c,f=!1;2===c.rank&&(f=!0,m=(0,i.reshape)(c,[1,c.shape[0],c.shape[1]])),r.assert(3===m.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${m.rank}.`),r.assert(3===h.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${h.rank}.`),n.checkPadOnDimRoundingMode("conv1d",l,d),r.assert(m.shape[2]===h.shape[1],()=>`Error in conv1d: depth of input (${m.shape[2]}) must match input depth for filter ${h.shape[1]}.`),r.assert(n.eitherStridesOrDilationsAreOne(o,p),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${o} and dilation '${p}'`),r.assert(n.stridesOrDilationsArePositive(p),()=>"Error in conv1D: Dilated rates should be larger than 0."),r.assert(n.stridesOrDilationsArePositive(o),()=>"Error in conv1D: Stride should be larger than 0."),r.assert("NWC"===u,()=>`Error in conv1d: got dataFormat of ${u} but only NWC is currently supported.`);let g=(0,i.reshape)(h,[1,h.shape[0],h.shape[1],h.shape[2]]),y=(0,i.reshape)(m,[m.shape[0],1,m.shape[1],m.shape[2]]),b=(0,a.conv2d)(y,g,[1,o],l,"NHWC",[1,p],d);return f?(0,i.reshape)(b,[b.shape[2],b.shape[3]]):(0,i.reshape)(b,[b.shape[0],b.shape[2],b.shape[3]])}});e.s(["conv1d",0,o],894983);var l=e.i(345161);let u=(0,s.op)({conv2dTranspose_:function(e,r,a,n,s,i){let o=(0,t.convertToTensor)(e,"x","conv2dTranspose"),u=(0,t.convertToTensor)(r,"filter","conv2dTranspose");return(0,l.conv2DBackpropInput)(a,o,u,n,s,"NHWC",i)}});e.s(["conv2dTranspose",0,u],599829)},274619,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({depthToSpace_:function(e,s,i="NHWC"){let o=(0,a.convertToTensor)(e,"x","depthToSpace","float32"),l="NHWC"===i?o.shape[1]:o.shape[2],u="NHWC"===i?o.shape[2]:o.shape[3],p="NHWC"===i?o.shape[3]:o.shape[1];return n.assert(s>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${s}`),n.assert(l*s>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${l} and ${s}  for depthToSpace with input shape
    ${o.shape}`),n.assert(u*s>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${u} and ${s} for depthToSpace with input shape
        ${o.shape}`),n.assert(p%(s*s)==0,()=>`Dimension size must be evenly divisible by ${s*s} but is ${p} for depthToSpace with input shape ${o.shape}`),t.ENGINE.runKernel(r.DepthToSpace,{x:o},{blockSize:s,dataFormat:i})}});e.s(["depthToSpace",0,s])},985730,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(870360),i=e.i(566389),o=e.i(940570);let l=(0,i.op)({depthwiseConv2d_:function(e,i,l,u,p="NHWC",d=[1,1],c){let h=(0,a.convertToTensor)(e,"x","depthwiseConv2d","float32"),m=(0,a.convertToTensor)(i,"filter","depthwiseConv2d","float32"),f=h,g=!1;3===h.rank&&(g=!0,f=(0,o.reshape)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),n.assert(4===f.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),n.assert(4===m.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`);let y="NHWC"===p?f.shape[3]:f.shape[1];n.assert(y===m.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${y}) must match the inChannels dimension in filter ${m.shape[2]}.`),s.checkPadOnDimRoundingMode("depthwiseConv2d",u,c);let b={x:f,filter:m},T=t.ENGINE.runKernel(r.DepthwiseConv2dNative,b,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c});return g?(0,o.reshape)(T,[T.shape[1],T.shape[2],T.shape[3]]):T}});e.s(["depthwiseConv2d",0,l])},805129,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(566389),i=e.i(940570);let o=(0,s.op)({dilation2d_:function(e,s,o,l,u=[1,1],p="NHWC"){let d=(0,a.convertToTensor)(e,"x","dilation2d"),c=(0,a.convertToTensor)(s,"filter","dilation2d");n.assert(3===d.rank||4===d.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${d.rank}.`),n.assert(3===c.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${c.rank}.`),n.assert("NHWC"===p,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${p}`);let h=d,m=!1;3===d.rank&&(h=(0,i.reshape)(d,[1,d.shape[0],d.shape[1],d.shape[2]]),m=!0),n.assert(h.shape[3]===c.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${h.shape[3]} vs ${c.shape[2]}`);let f={x:h,filter:c},g=t.ENGINE.runKernel(r.Dilation2D,f,{strides:o,pad:l,dilations:u});return m?(0,i.reshape)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});e.s(["dilation2d",0,o])},928612,607381,e=>{"use strict";var t=e.i(744877),r=e.i(240210),a=e.i(680837),n=e.i(87432),s=e.i(566389),i=e.i(379250),o=e.i(990256);let l=(0,s.op)({divNoNan_:function(e,s){let l=(0,r.convertToTensor)(e,"a","div"),u=(0,r.convertToTensor)(s,"b","div");[l,u]=(0,t.makeTypesMatch)(l,u);let p=(0,a.div)(l,u),d=(0,o.zerosLike)(p),c=(0,n.equal)(u,d);return(0,i.where)(c,d,p)}});e.s(["divNoNan",0,l],928612);var u=e.i(496378),p=e.i(656040),d=e.i(940570);let c=(0,s.op)({dot_:function(e,t){let a=(0,r.convertToTensor)(e,"t1","dot"),n=(0,r.convertToTensor)(t,"t2","dot");u.assert((1===a.rank||2===a.rank)&&(1===n.rank||2===n.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${a.rank} and ${n.rank}.`);let s=1===a.rank?a.size:a.shape[1],i=1===n.rank?n.size:n.shape[0];if(u.assert(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),1===a.rank&&1===n.rank){let e=(0,d.reshape)(a,[1,-1]),t=(0,d.reshape)(n,[-1,1]),r=(0,p.matMul)(e,t);return(0,d.reshape)(r,[])}if(1===a.rank&&2===n.rank){let e=(0,d.reshape)(a,[1,-1]),t=(0,d.reshape)(n,[n.shape[0],n.shape[1]]),r=(0,p.matMul)(e,t);return(0,d.reshape)(r,[r.size])}if(2===a.rank&&1===n.rank){let e=(0,d.reshape)(n,[-1,1]),t=(0,p.matMul)(a,e);return(0,d.reshape)(t,[t.size])}{let e=(0,d.reshape)(n,[n.shape[0],n.shape[1]]);return(0,p.matMul)(a,e)}}});e.s(["dot",0,c],607381)},923153,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(494096);let i=(0,e.i(566389).op)({erf_:function(e){let i=(0,a.convertToTensor)(e,"x","erf");n.assert("int32"===i.dtype||"float32"===i.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===i.dtype&&(i=(0,s.cast)(i,"float32"));let o={x:i};return t.ENGINE.runKernel(r.Erf,o)}});e.s(["erf",0,i])},683784,37051,551573,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(410616),n=e.i(769664),s=e.i(27923),i=e.i(592061),o=e.i(566389);let l=(0,o.op)({max_:function(e,r=null,a=!1){let n=(0,t.convertToTensor)(e,"x","max");return s.ENGINE.runKernel(i.Max,{x:n},{reductionIndices:r,keepDims:a})}});e.s(["max",0,l],37051);let u=(0,o.op)({min_:function(e,r=null,a=!1){let n=(0,t.convertToTensor)(e,"x","min");return s.ENGINE.runKernel(i.Min,{x:n},{axis:r,keepDims:a})}});e.s(["min",0,u],551573);var p=e.i(26194),d=e.i(940570),c=e.i(919862),h=e.i(119509),m=e.i(240774),f=e.i(101669);let g=(0,o.op)({norm_:function(e,s="euclidean",i=null,o=!1){let g=function e(t,r,n=null){if(0===t.rank)return(0,a.abs)(t);if(1!==t.rank&&null===n)return e((0,d.reshape)(t,[-1]),r,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===r)return(0,f.sum)((0,a.abs)(t),n);if(r===1/0)return l((0,a.abs)(t),n);if(r===-1/0)return u((0,a.abs)(t),n);if("euclidean"===r||2===r)return(0,h.sqrt)((0,f.sum)((0,p.pow)((0,a.abs)(t),(0,c.scalar)(2,"int32")),n));throw Error(`Error in norm: invalid ord value: ${r}`)}if(Array.isArray(n)&&2===n.length){if(1===r)return l((0,f.sum)((0,a.abs)(t),n[0]),n[1]-1);if(r===1/0)return l((0,f.sum)((0,a.abs)(t),n[1]),n[0]);if(r===-1/0)return u((0,f.sum)((0,a.abs)(t),n[1]),n[0]);if("fro"===r||"euclidean"===r)return(0,h.sqrt)((0,f.sum)((0,m.square)(t),n));throw Error(`Error in norm: invalid ord value: ${r}`)}throw Error(`Error in norm: invalid axis: ${n}`)}(e=(0,t.convertToTensor)(e,"x","norm"),s,i),y=g.shape;if(o){let t=(0,r.parseAxisParam)(i,e.shape);y=n.expandShapeToKeepDim(g.shape,t)}return(0,d.reshape)(g,y)}});e.s(["norm",0,g],683784)},729932,81705,e=>{"use strict";var t=e.i(683784),r=e.i(566389);let a=(0,r.op)({euclideanNorm_:function(e,r=null,a=!1){return(0,t.norm)(e,"euclidean",r,a)}});e.s(["euclideanNorm",0,a],729932);var n=e.i(27923),s=e.i(592061),i=e.i(240210);let o=(0,r.op)({expm1_:function(e){let t=(0,i.convertToTensor)(e,"x","expm1");return n.ENGINE.runKernel(s.Expm1,{x:t})}});e.s(["expm1",0,o],81705)},900846,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(496378);let n=(0,e.i(566389).op)({fft_:function(e){return(0,a.assert)("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),t.ENGINE.runKernel(r.FFT,{input:e})}});e.s(["fft",0,n])},965960,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(496378);let n=(0,e.i(566389).op)({ifft_:function(e){return(0,a.assert)("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),t.ENGINE.runKernel(r.IFFT,{input:e})}});e.s(["ifft",0,n])},129476,e=>{"use strict";var t=e.i(994152),r=e.i(655015),a=e.i(176598),n=e.i(449404),s=e.i(566389),i=e.i(404099),o=e.i(940570),l=e.i(185876),u=e.i(919862),p=e.i(606764),d=e.i(965960);let c=(0,s.op)({irfft_:function(e){let s,c=e.shape[e.shape.length-1],h=e.size/c;if(c<=2){let t=(0,o.reshape)(e,[h,c]);s=(0,d.ifft)(t)}else{let m=[h,2*(c-1)],f=(0,o.reshape)((0,i.real)(e),[h,c]),g=(0,o.reshape)((0,a.imag)(e),[h,c]),y=(0,l.reverse)((0,p.slice)(f,[0,1],[h,c-2]),1),b=(0,n.mul)((0,l.reverse)((0,p.slice)(g,[0,1],[h,c-2]),1),(0,u.scalar)(-1)),T=(0,r.concat)([f,y],1),v=(0,r.concat)([g,b],1),N=(0,o.reshape)((0,t.complex)(T,v),[m[0],m[1]]);s=(0,d.ifft)(N)}if(s=(0,i.real)(s),3===e.rank&&0!==e.shape[0]){let t=s,r=e.shape[0];s=(0,o.reshape)(s,[r,s.shape[0]/r,s.shape[1]]),t.dispose()}return s}});e.s(["irfft",0,c])},379973,971805,514149,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({isFinite_:function(e){let n=(0,a.convertToTensor)(e,"x","isFinite");return t.ENGINE.runKernel(r.IsFinite,{x:n})}});e.s(["isFinite",0,s],379973);let i=(0,n.op)({isInf_:function(e){let n=(0,a.convertToTensor)(e,"x","isInf");return t.ENGINE.runKernel(r.IsInf,{x:n})}});e.s(["isInf",0,i],971805);let o=(0,n.op)({isNaN_:function(e){let n=(0,a.convertToTensor)(e,"x","isNaN");return t.ENGINE.runKernel(r.IsNan,{x:n})}});e.s(["isNaN",0,o],514149)},35109,922398,105258,940181,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(566389),i=e.i(940570);let o=(0,s.op)({localResponseNormalization_:function(e,s=5,o=1,l=1,u=.5){let p=(0,a.convertToTensor)(e,"x","localResponseNormalization");n.assert(4===p.rank||3===p.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${p.rank}.`),n.assert(n.isInt(s),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${s}.`);let d=p,c=!1;3===p.rank&&(c=!0,d=(0,i.reshape)(p,[1,p.shape[0],p.shape[1],p.shape[2]]));let h={x:d},m=t.ENGINE.runKernel(r.LRN,h,{depthRadius:s,bias:o,alpha:l,beta:u});return c?(0,i.reshape)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});e.s(["localResponseNormalization",0,o],35109);var l=e.i(860623),u=e.i(449404),p=e.i(408604),d=e.i(846141);let c=(0,s.op)({softplus_:function(e){let n=(0,a.convertToTensor)(e,"x","softplus");return t.ENGINE.runKernel(r.Softplus,{x:n})}});e.s(["softplus",0,c],922398);let h=(0,s.op)({logSigmoid_:function(e){let t=(0,a.convertToTensor)(e,"x","logSigmoid");return(0,l.customGrad)(e=>({value:(0,p.neg)(c((0,p.neg)(e))),gradFunc:t=>(0,u.mul)(t,(0,d.sigmoid)((0,p.neg)(e)))}))(t)}});e.s(["logSigmoid",0,h],105258);var m=e.i(494096),f=e.i(345175),g=e.i(322459),y=e.i(37051),b=e.i(33457),T=e.i(101669);let v=(0,s.op)({logSoftmax_:function(e,t=-1){let r=(0,a.convertToTensor)(e,"logits","logSoftmax");if(-1===t&&(t=r.rank-1),t!==r.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${r.rank} and axis was ${t}`);return(0,l.customGrad)((e,r)=>{let a=(0,y.max)(e,t,!0),n=(0,b.sub)(e,a),s=(0,b.sub)((0,m.cast)(n,"float32"),(0,g.log)((0,T.sum)((0,f.exp)(n),t,!0)));return r([s]),{value:s,gradFunc:(e,r)=>{let[a]=r,n=(0,f.exp)(a);return(0,b.sub)(e,(0,u.mul)((0,T.sum)(e,t,!0),n))}}})(r)}});e.s(["logSoftmax",0,v],940181)},334401,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(536331),n=e.i(769664),s=e.i(345175),i=e.i(322459),o=e.i(37051),l=e.i(566389),u=e.i(940570),p=e.i(33457),d=e.i(101669);let c=(0,l.op)({logSumExp_:function(e,l=null,c=!1){let h=(0,t.convertToTensor)(e,"x","logSumExp"),m=(0,r.parseAxisParam)(l,h.shape),f=(0,o.max)(h,m,!0),g=(0,p.sub)(h,f),y=(0,s.exp)(g),b=(0,d.sum)(y,m),T=(0,i.log)(b),v=(0,a.add)((0,u.reshape)(f,T.shape),T);if(c){let e=(0,n.expandShapeToKeepDim)(v.shape,m);return(0,u.reshape)(v,e)}return v}});e.s(["logSumExp",0,c])},297198,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({log1p_:function(e){let n=(0,a.convertToTensor)(e,"x","log1p");return t.ENGINE.runKernel(r.Log1p,{x:n})}});e.s(["log1p",0,n])},725759,392326,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(568503),s=e.i(566389);let i=(0,s.op)({logicalOr_:function(e,s){let i=(0,a.convertToTensor)(e,"a","logicalOr","bool"),o=(0,a.convertToTensor)(s,"b","logicalOr","bool");return(0,n.assertAndGetBroadcastShape)(i.shape,o.shape),t.ENGINE.runKernel(r.LogicalOr,{a:i,b:o})}});e.s(["logicalOr",0,i],725759);var o=e.i(783171),l=e.i(705680);let u=(0,s.op)({logicalXor_:function(e,t){let r=(0,a.convertToTensor)(e,"a","logicalXor","bool"),s=(0,a.convertToTensor)(t,"b","logicalXor","bool");return(0,n.assertAndGetBroadcastShape)(r.shape,s.shape),(0,o.logicalAnd)(i(e,t),(0,l.logicalNot)((0,o.logicalAnd)(e,t)))}});e.s(["logicalXor",0,u],392326)},168091,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(870360),i=e.i(566389),o=e.i(940570);let l=(0,i.op)({maxPool_:function(e,i,l,u,p){let d=(0,a.convertToTensor)(e,"x","maxPool"),c=d,h=!1;3===d.rank&&(h=!0,c=(0,o.reshape)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),n.assert(4===c.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${c.rank}.`),n.assert(s.eitherStridesOrDilationsAreOne(l,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '1'`),s.checkPadOnDimRoundingMode("maxPool",u,p);let m={x:c},f=t.ENGINE.runKernel(r.MaxPool,m,{filterSize:i,strides:l,pad:u,dimRoundingMode:p});return h?(0,o.reshape)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});e.s(["maxPool",0,l])},155217,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({mean_:function(e,n=null,s=!1){let i=(0,a.convertToTensor)(e,"x","mean");return t.ENGINE.runKernel(r.Mean,{x:i},{axis:n,keepDims:s})}});e.s(["mean",0,n])},600936,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(744877),n=e.i(240210),s=e.i(568503),i=e.i(494096);let o=(0,e.i(566389).op)({minimum_:function(e,o){let l=(0,n.convertToTensor)(e,"a","minimum"),u=(0,n.convertToTensor)(o,"b","minimum");[l,u]=(0,a.makeTypesMatch)(l,u),"bool"===l.dtype&&(l=(0,i.cast)(l,"int32"),u=(0,i.cast)(u,"int32")),(0,s.assertAndGetBroadcastShape)(l.shape,u.shape);let p={a:l,b:u};return t.ENGINE.runKernel(r.Minimum,p)}});e.s(["minimum",0,o])},564418,152522,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(566389);let i=(0,s.op)({mirrorPad_:function(e,s,i){n.assert("reflect"===i||"symmetric"===i,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${i}.`);let o=(0,a.convertToTensor)(e,"x","mirrorPad");if(0===o.rank)throw Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");n.assert(s.length===o.rank,()=>`Padding doesn't match input. Must be ${o.rank}. Got ${s.length}.`);let l=+("reflect"===i);for(let e=0;e<o.rank;e++)n.assert(2===s[e].length,()=>"Invalid number of paddings. Must be length of 2 each."),n.assert(s[e][0]>=0&&s[e][0]<=o.shape[e]-l&&s[e][1]>=0&&s[e][1]<=o.shape[e]-l,()=>`Padding in dimension ${e} cannot be greater than or equal to ${o.shape[e]-l} or less than 0 for input of shape ${o.shape}`);return t.ENGINE.runKernel(r.MirrorPad,{x:o},{paddings:s,mode:i})}});e.s(["mirrorPad",0,i],564418);var o=e.i(744877);let l=(0,s.op)({mod_:function(e,n){let s=(0,a.convertToTensor)(e,"a","mod"),i=(0,a.convertToTensor)(n,"b","mod");[s,i]=(0,o.makeTypesMatch)(s,i);let l={a:s,b:i};return t.ENGINE.runKernel(r.Mod,l)}});e.s(["mod",0,l],152522)},344658,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(744877),n=e.i(240210),s=e.i(568503);let i=(0,e.i(566389).op)({notEqual_:function(e,i){let o=(0,n.convertToTensor)(e,"a","notEqual","string_or_numeric"),l=(0,n.convertToTensor)(i,"b","notEqual","string_or_numeric");[o,l]=(0,a.makeTypesMatch)(o,l),(0,s.assertAndGetBroadcastShape)(o.shape,l.shape);let u={a:o,b:l};return t.ENGINE.runKernel(r.NotEqual,u)}});e.s(["notEqual",0,i])},379778,584525,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({oneHot_:function(e,n,s=1,i=0,o="int32"){if(n<2)throw Error(`Error in oneHot: depth must be >=2, but it is ${n}`);let l=(0,a.convertToTensor)(e,"indices","oneHot","int32");return t.ENGINE.runKernel(r.OneHot,{indices:l},{dtype:o,depth:n,onValue:s,offValue:i})}});e.s(["oneHot",0,s],379778);let i=(0,n.op)({onesLike_:function(e){let n=(0,a.convertToTensor)(e,"x","onesLike");return t.ENGINE.runKernel(r.OnesLike,{x:n})}});e.s(["onesLike",0,i],584525)},871242,345813,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(281991),n=e.i(657626),s=e.i(870360),i=e.i(168091),o=e.i(566389),l=e.i(940570),u=e.i(707019);let p=(0,o.op)({pool_:function(e,o,p,d,c,h,m){var f,g,y,b,T;let v,N,x,S,E,w,k,I,A;null==c&&(c=[1,1]),null==h&&(h=1),0===d&&(d="valid");let P=(0,t.convertToTensor)(e,"x","maxPool"),M=P,_=!1;3===P.rank&&(_=!0,M=(0,l.reshape)(P,[1,P.shape[0],P.shape[1],P.shape[2]])),r.assert(s.eitherStridesOrDilationsAreOne(h,c),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${h} and dilations '${c}'`);let V=s.computePool2DInfo(M.shape,o,h,c,d),D=[V.dilationHeight,V.dilationWidth];v="same"===d?(f=[V.filterHeight,V.filterWidth],g=D,x=(N=f.map((e,t)=>e+(e-1)*(g[t]-1)).map(e=>e-1)).map(e=>Math.floor(e/2)),S=N.map((e,t)=>e-x[t]),N.map((e,t)=>[x[t],S[t]])):[[0,0],[0,0]];let $=1===D[0]&&1===D[1],[O,R]=(y=[V.inHeight,V.inWidth],b=D,E=(T=v).map(e=>e[0]),k=y.concat(E,w=T.map(e=>e[1])),I=b.map((e,t)=>(e-k[t]%e)%e),A=w.map((e,t)=>e+I[t]),[b.map((e,t)=>[E[t],A[t]]),b.map((e,t)=>[0,I[t]])]),F=$?d:"valid",C=$?M:(0,u.spaceToBatchND)(M,D,O),B=("avg"===p?()=>(0,a.avgPool)(C,o,h,F,m):()=>(0,i.maxPool)(C,o,h,F,m))(),L=$?B:(0,n.batchToSpaceND)(B,D,R);return _?(0,l.reshape)(L,[L.shape[1],L.shape[2],L.shape[3]]):L}});e.s(["pool",0,p],871242);var d=e.i(27923),c=e.i(592061),h=e.i(494096);let m=(0,o.op)({prod_:function(e,r=null,a=!1){let n=(0,t.convertToTensor)(e,"x","prod");"bool"===n.dtype&&(n=(0,h.cast)(n,"int32"));let s={x:n};return d.ENGINE.runKernel(c.Prod,s,{axis:r,keepDims:a})}});e.s(["prod",0,m],345813)},283532,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({reciprocal_:function(e){let n=(0,a.convertToTensor)(e,"x","reciprocal");return t.ENGINE.runKernel(r.Reciprocal,{x:n})}});e.s(["reciprocal",0,n])},213482,365506,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(566389),i=e.i(940570);let o=(0,s.op)({resizeBilinear_:function(e,s,o=!1,l=!1){let u=(0,a.convertToTensor)(e,"images","resizeBilinear");n.assert(3===u.rank||4===u.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${u.rank}.`),n.assert(2===s.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${s}.`),n.assert(!1===l||!1===o,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let p=u,d=!1;3===u.rank&&(d=!0,p=(0,i.reshape)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));let[]=s,c={images:p},h=t.ENGINE.runKernel(r.ResizeBilinear,c,{alignCorners:o,halfPixelCenters:l,size:s});return d?(0,i.reshape)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});e.s(["resizeBilinear",0,o],213482);let l=(0,s.op)({resizeNearestNeighbor_:function(e,s,o=!1,l=!1){let u=(0,a.convertToTensor)(e,"images","resizeNearestNeighbor");n.assert(3===u.rank||4===u.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${u.rank}.`),n.assert(2===s.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${s}.`),n.assert("float32"===u.dtype||"int32"===u.dtype,()=>"`images` must have `int32` or `float32` as dtype"),n.assert(!1===l||!1===o,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let p=u,d=!1;3===u.rank&&(d=!0,p=(0,i.reshape)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));let[]=s,c={images:p},h=t.ENGINE.runKernel(r.ResizeNearestNeighbor,c,{alignCorners:o,halfPixelCenters:l,size:s});return d?(0,i.reshape)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});e.s(["resizeNearestNeighbor",0,l],365506)},470353,e=>{"use strict";var t=e.i(496378),r=e.i(994152),a=e.i(655015),n=e.i(176598),s=e.i(566389),i=e.i(404099),o=e.i(940570),l=e.i(606764),u=e.i(798670),p=e.i(394596),d=e.i(990256),c=e.i(900846);let h=(0,s.op)({rfft_:function(e,s){let h;(0,t.assert)("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let m=e.shape[e.shape.length-1],f=e.size/m;if(null!=s&&s<m){let t=e.shape.map(e=>0),r=e.shape.map(e=>e);r[e.shape.length-1]=s,h=(0,l.slice)(e,t,r),m=s}else if(null!=s&&s>m){let t=e.shape.map(e=>e);t[e.shape.length-1]=s-m,h=(0,a.concat)([e,(0,p.zeros)(t)],e.shape.length-1),m=s}else h=e;let g=(0,d.zerosLike)(h),y=(0,o.reshape)((0,r.complex)(h,g),[f,m]),b=(0,c.fft)(y),T=Math.floor(m/2)+1,v=(0,i.real)(b),N=(0,n.imag)(b),x=(0,u.split)(v,[T,m-T],v.shape.length-1),S=(0,u.split)(N,[T,m-T],N.shape.length-1),E=h.shape.slice();return E[h.shape.length-1]=T,(0,o.reshape)((0,r.complex)(x[0],S[0]),E)}});e.s(["rfft",0,h])},751057,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({round_:function(e){let n=(0,a.convertToTensor)(e,"x","round");return t.ENGINE.runKernel(r.Round,{x:n})}});e.s(["round",0,n])},671859,25498,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({selu_:function(e){let n=(0,a.convertToTensor)(e,"x","selu");return t.ENGINE.runKernel(r.Selu,{x:n})}});e.s(["selu",0,s],671859);var i=e.i(496378),o=e.i(673749),l=e.i(985730),u=e.i(940570);let p=(0,n.op)({separableConv2d_:function(e,t,r,n,s,p=[1,1],d="NHWC"){let c=(0,a.convertToTensor)(e,"x","separableConv2d"),h=(0,a.convertToTensor)(t,"depthwiseFilter","separableConv2d"),m=(0,a.convertToTensor)(r,"pointwiseFilter","separableConv2d"),f=c,g=!1;if(3===c.rank&&(g=!0,f=(0,u.reshape)(c,[1,c.shape[0],c.shape[1],c.shape[2]])),"NCHW"===d)throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");i.assert(4===f.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${f.rank}.`),i.assert(4===h.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${h.rank}.`),i.assert(4===m.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${h.rank}.`),i.assert(1===m.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${m.shape[0]}.`),i.assert(1===m.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${m.shape[1]}.`);let y=h.shape[2],b=h.shape[3];i.assert(m.shape[2]===y*b,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${y*b}, but got ${m.shape[2]}.`);let T=(0,l.depthwiseConv2d)(f,h,n,s,d,p),v=(0,o.conv2d)(T,m,1,"valid",d);return g?(0,u.reshape)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});e.s(["separableConv2d",0,p],25498)},153910,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({sign_:function(e){let n=(0,a.convertToTensor)(e,"x","sign");return t.ENGINE.runKernel(r.Sign,{x:n})}});e.s(["sign",0,n])},197631,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({softmax_:function(e,n=-1){let s=(0,a.convertToTensor)(e,"logits","softmax","float32");if(-1===n&&(n=s.rank-1),n!==s.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${s.rank} and dim was ${n}`);let i={dim:n};return t.ENGINE.runKernel(r.Softmax,{logits:s},i)}});e.s(["softmax",0,n])},907467,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(744877),n=e.i(240210),s=e.i(568503);let i=(0,e.i(566389).op)({squaredDifference_:function(e,i){let o=(0,n.convertToTensor)(e,"a","squaredDifference"),l=(0,n.convertToTensor)(i,"b","squaredDifference");[o,l]=(0,a.makeTypesMatch)(o,l),(0,s.assertAndGetBroadcastShape)(o.shape,l.shape);let u={a:o,b:l};return t.ENGINE.runKernel(r.SquaredDifference,u,{})}});e.s(["squaredDifference",0,i])},836111,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(566389),n=e.i(940570);let s=(0,a.op)({squeeze_:function(e,a){let s=(0,t.convertToTensor)(e,"x","squeeze","string_or_numeric");return(0,n.reshape)(s,(0,r.squeezeShape)(s.shape,a).newShape)}});e.s(["squeeze",0,s])},241468,59143,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({stridedSlice_:function(e,n,s,i,o=0,l=0,u=0,p=0,d=0){let c=(0,a.convertToTensor)(e,"x","stridedSlice","string_or_numeric");return t.ENGINE.runKernel(r.StridedSlice,{x:c},{begin:n,end:s,strides:i,beginMask:o,endMask:l,ellipsisMask:u,newAxisMask:p,shrinkAxisMask:d})}});e.s(["stridedSlice",0,s],241468);let i=(0,n.op)({tan_:function(e){let n=(0,a.convertToTensor)(e,"x","tan","float32");return t.ENGINE.runKernel(r.Tan,{x:n})}});e.s(["tan",0,i],59143)},199009,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({tanh_:function(e){let n=(0,a.convertToTensor)(e,"x","tanh","float32");return t.ENGINE.runKernel(r.Tanh,{x:n})}});e.s(["tanh",0,n])},210487,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({topk_:function(e,n=1,s=!0){let i=(0,a.convertToTensor)(e,"x","topk");if(0===i.rank)throw Error("topk() expects the input to be of rank 1 or higher");let o=i.shape[i.shape.length-1];if(n<0)throw Error(`'k' passed to topk() must be >= 0 but got ${n}`);if(n>o)throw Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${n}`);let[l,u]=t.ENGINE.runKernel(r.TopK,{x:i},{k:n,sorted:s});return{values:l,indices:u}}});e.s(["topk",0,n])},41735,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({unique_:function(e,s=0){let i=(0,a.convertToTensor)(e,"x","unique","string_or_numeric");(0,n.assert)(i.rank>0,()=>"The input tensor must be at least 1D");let[o,l]=t.ENGINE.runKernel(r.Unique,{x:i},{axis:s});return{values:o,indices:l}}});e.s(["unique",0,s])},415995,(e,t,r)=>{t.exports=n;var a=null;try{a=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,r){this.low=0|e,this.high=0|t,this.unsigned=!!r}function s(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=s;var i={},o={};function l(e,t){var r,a,n;if(t)return(e>>>=0,(n=0<=e&&e<256)&&(a=o[e]))?a:(r=p(e,(0|e)<0?-1:0,!0),n&&(o[e]=r),r);return(e|=0,(n=-128<=e&&e<128)&&(a=i[e]))?a:(r=p(e,e<0?-1:0,!1),n&&(i[e]=r),r)}function u(e,t){if(isNaN(e))return t?T:b;if(t){if(e<0)return T;if(e>=f)return E}else{if(e<=-g)return w;if(e+1>=g)return S}return e<0?u(-e,t).neg():p(e%m|0,e/m|0,t)}function p(e,t,r){return new n(e,t,r)}n.fromInt=l,n.fromNumber=u,n.fromBits=p;var d=Math.pow;function c(e,t,r){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return b;if("number"==typeof t?(r=t,t=!1):t=!!t,(r=r||10)<2||36<r)throw RangeError("radix");if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return c(e.substring(1),t,r).neg();for(var a,n=u(d(r,8)),s=b,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+o),r);if(o<8){var p=u(d(r,o));s=s.mul(p).add(u(l))}else s=(s=s.mul(n)).add(u(l))}return s.unsigned=t,s}function h(e,t){return"number"==typeof e?u(e,t):"string"==typeof e?c(e,t):p(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=h;var m=0x100000000,f=0xffffffffffffffff,g=0x8000000000000000,y=l(0x1000000),b=l(0);n.ZERO=b;var T=l(0,!0);n.UZERO=T;var v=l(1);n.ONE=v;var N=l(1,!0);n.UONE=N;var x=l(-1);n.NEG_ONE=x;var S=p(-1,0x7fffffff,!1);n.MAX_VALUE=S;var E=p(-1,-1,!0);n.MAX_UNSIGNED_VALUE=E;var w=p(0,-0x80000000,!1);n.MIN_VALUE=w;var k=n.prototype;k.toInt=function(){return this.unsigned?this.low>>>0:this.low},k.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},k.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(!this.eq(w))return"-"+this.neg().toString(e);else{var t=u(e),r=this.div(t),a=r.mul(t).sub(this);return r.toString(e)+a.toInt().toString(e)}for(var n=u(d(e,6),this.unsigned),s=this,i="";;){var o=s.div(n),l=(s.sub(o.mul(n)).toInt()>>>0).toString(e);if((s=o).isZero())return l+i;for(;l.length<6;)l="0"+l;i=""+l+i}},k.getHighBits=function(){return this.high},k.getHighBitsUnsigned=function(){return this.high>>>0},k.getLowBits=function(){return this.low},k.getLowBitsUnsigned=function(){return this.low>>>0},k.getNumBitsAbs=function(){if(this.isNegative())return this.eq(w)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return 0!=this.high?t+33:t+1},k.isZero=function(){return 0===this.high&&0===this.low},k.eqz=k.isZero,k.isNegative=function(){return!this.unsigned&&this.high<0},k.isPositive=function(){return this.unsigned||this.high>=0},k.isOdd=function(){return(1&this.low)==1},k.isEven=function(){return(1&this.low)==0},k.equals=function(e){return s(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},k.eq=k.equals,k.notEquals=function(e){return!this.eq(e)},k.neq=k.notEquals,k.ne=k.notEquals,k.lessThan=function(e){return 0>this.comp(e)},k.lt=k.lessThan,k.lessThanOrEqual=function(e){return 0>=this.comp(e)},k.lte=k.lessThanOrEqual,k.le=k.lessThanOrEqual,k.greaterThan=function(e){return this.comp(e)>0},k.gt=k.greaterThan,k.greaterThanOrEqual=function(e){return this.comp(e)>=0},k.gte=k.greaterThanOrEqual,k.ge=k.greaterThanOrEqual,k.compare=function(e){if(s(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},k.comp=k.compare,k.negate=function(){return!this.unsigned&&this.eq(w)?w:this.not().add(v)},k.neg=k.negate,k.add=function(e){s(e)||(e=h(e));var t,r,a=this.high>>>16,n=65535&this.high,i=this.low>>>16,o=65535&this.low,l=e.high>>>16,u=65535&e.high,d=e.low>>>16,c=65535&e.low,m=0,f=0;return t=0+((r=0+(o+c))>>>16),r&=65535,t+=i+d,f+=t>>>16,t&=65535,f+=n+u,m+=f>>>16,f&=65535,m+=a+l,p(t<<16|r,(m&=65535)<<16|f,this.unsigned)},k.subtract=function(e){return s(e)||(e=h(e)),this.add(e.neg())},k.sub=k.subtract,k.multiply=function(e){if(this.isZero())return b;if(s(e)||(e=h(e)),a)return p(a.mul(this.low,this.high,e.low,e.high),a.get_high(),this.unsigned);if(e.isZero())return b;if(this.eq(w))return e.isOdd()?w:b;if(e.eq(w))return this.isOdd()?w:b;if(this.isNegative())if(e.isNegative())return this.neg().mul(e.neg());else return this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(y)&&e.lt(y))return u(this.toNumber()*e.toNumber(),this.unsigned);var t,r,n=this.high>>>16,i=65535&this.high,o=this.low>>>16,l=65535&this.low,d=e.high>>>16,c=65535&e.high,m=e.low>>>16,f=65535&e.low,g=0,T=0;return t=0+((r=0+l*f)>>>16),r&=65535,t+=o*f,T+=t>>>16,t&=65535,t+=l*m,T+=t>>>16,t&=65535,T+=i*f,g+=T>>>16,T&=65535,T+=o*m,g+=T>>>16,T&=65535,T+=l*c,g+=T>>>16,T&=65535,g+=n*f+i*m+o*c+l*d,p(t<<16|r,(g&=65535)<<16|T,this.unsigned)},k.mul=k.multiply,k.divide=function(e){if(s(e)||(e=h(e)),e.isZero())throw Error("division by zero");if(a){var t,r,n;return this.unsigned||-0x80000000!==this.high||-1!==e.low||-1!==e.high?p((this.unsigned?a.div_u:a.div_s)(this.low,this.high,e.low,e.high),a.get_high(),this.unsigned):this}if(this.isZero())return this.unsigned?T:b;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return T;if(e.gt(this.shru(1)))return N;n=T}else{if(this.eq(w))if(e.eq(v)||e.eq(x))return w;else return e.eq(w)?v:(t=this.shr(1).div(e).shl(1)).eq(b)?e.isNegative()?v:x:(r=this.sub(e.mul(t)),n=t.add(r.div(e)));if(e.eq(w))return this.unsigned?T:b;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();n=b}for(r=this;r.gte(e);){for(var i=Math.ceil(Math.log(t=Math.max(1,Math.floor(r.toNumber()/e.toNumber())))/Math.LN2),o=i<=48?1:d(2,i-48),l=u(t),c=l.mul(e);c.isNegative()||c.gt(r);)t-=o,c=(l=u(t,this.unsigned)).mul(e);l.isZero()&&(l=v),n=n.add(l),r=r.sub(c)}return n},k.div=k.divide,k.modulo=function(e){return(s(e)||(e=h(e)),a)?p((this.unsigned?a.rem_u:a.rem_s)(this.low,this.high,e.low,e.high),a.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},k.mod=k.modulo,k.rem=k.modulo,k.not=function(){return p(~this.low,~this.high,this.unsigned)},k.and=function(e){return s(e)||(e=h(e)),p(this.low&e.low,this.high&e.high,this.unsigned)},k.or=function(e){return s(e)||(e=h(e)),p(this.low|e.low,this.high|e.high,this.unsigned)},k.xor=function(e){return s(e)||(e=h(e)),p(this.low^e.low,this.high^e.high,this.unsigned)},k.shiftLeft=function(e){return(s(e)&&(e=e.toInt()),0==(e&=63))?this:e<32?p(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):p(0,this.low<<e-32,this.unsigned)},k.shl=k.shiftLeft,k.shiftRight=function(e){return(s(e)&&(e=e.toInt()),0==(e&=63))?this:e<32?p(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):p(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},k.shr=k.shiftRight,k.shiftRightUnsigned=function(e){if(s(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?p(this.low>>>e|t<<32-e,t>>>e,this.unsigned):32===e?p(t,0,this.unsigned):p(t>>>e-32,0,this.unsigned)},k.shru=k.shiftRightUnsigned,k.shr_u=k.shiftRightUnsigned,k.toSigned=function(){return this.unsigned?p(this.low,this.high,!1):this},k.toUnsigned=function(){return this.unsigned?this:p(this.low,this.high,!0)},k.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},k.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},k.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},449672,353055,e=>{"use strict";var t=e.i(111613),r=e.i(496378),a=e.i(415995);let n=a.default||a;function s(e){return n.fromString(e,!0,16)}let i=s("c3a5c85c97cb3127"),o=s("b492b66fbe98f273"),l=s("9ae16a3b2f90404f");function u(e){return e.xor(e.shru(47))}function p(e,t,r){let a=e.slice(t,t+r);return n.fromBytes(Array.from(a),!0,!0)}function d(e,t){return p(e,t,8)}function c(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function h(e,t,r=s("9ddfea08eb382d69")){let a=e.xor(t).mul(r);a=a.xor(a.shru(47));let n=t.xor(a).mul(r);return(n=n.xor(n.shru(47))).mul(r)}function m(e,t,r,a){var n,s,i,o,l,u;let p;return n=d(e,t),s=d(e,t+8),i=d(e,t+16),o=d(e,t+24),l=r,u=a,l=l.add(n),u=c(u.add(l).add(o),21),p=l,l=(l=l.add(s)).add(i),u=u.add(c(l,44)),[l.add(o),u.add(p)]}function f(e,t=e.length){let r=n.fromNumber(81,!0);if(t<=32)if(t<=16)return function(e,t=e.length){if(t>=8){let r=l.add(2*t),a=d(e,0).add(l),n=d(e,t-8);return h(c(n,37).mul(r).add(a),c(a,25).add(n).mul(r),r)}if(t>=4){let r=l.add(2*t);return h(p(e,0,4).shl(3).add(t),p(e,t-4,4),r)}if(t>0){let r=e[0],a=e[t>>1],n=e[t-1];return u(l.mul(r+(a<<8)).xor(i.mul(t+(n<<2)))).mul(l)}return l}(e,t);else return function(e,t=e.length){let r=l.add(2*t),a=d(e,0).mul(o),n=d(e,8),s=d(e,t-8).mul(r),i=d(e,t-16).mul(l);return h(c(a.add(n),43).add(c(s,30)).add(i),a.add(c(n.add(l),18)).add(s),r)}(e,t);if(t<=64)return function(e,t=e.length){let r=l.add(2*t),a=d(e,0).mul(l),n=d(e,8),s=d(e,t-8).mul(r),i=d(e,t-16).mul(l),o=c(a.add(n),43).add(c(s,30)).add(i),u=h(o,a.add(c(n.add(l),18)).add(s),r),p=d(e,16).mul(r),m=d(e,24),f=o.add(d(e,t-32)).mul(r),g=u.add(d(e,t-24)).mul(r);return h(c(p.add(m),43).add(c(f,30)).add(g),p.add(c(m.add(a),18)).add(f),r)}(e,t);let a=r,s=r.mul(o).add(113),g=u(s.mul(l).add(113)).mul(l),y=[n.UZERO,n.UZERO],b=[n.UZERO,n.UZERO];a=a.mul(l).add(d(e,0));let T=0,v=(t-1>>6)*64,N=v+(t-1&63)-63;do a=c(a.add(s).add(y[0]).add(d(e,T+8)),37).mul(o),s=c(s.add(y[1]).add(d(e,T+48)),42).mul(o),a=a.xor(b[1]),s=s.add(y[0]).add(d(e,T+40)),g=c(g.add(b[0]),33).mul(o),y=m(e,T,y[1].mul(o),a.add(b[0])),b=m(e,T+32,g.add(b[1]),s.add(d(e,T+16))),[g,a]=[a,g],T+=64;while(T!==v)let x=o.add(g.and(255).shl(1));return T=N,b[0]=b[0].add(t-1&63),y[0]=y[0].add(b[0]),b[0]=b[0].add(y[0]),a=c(a.add(s).add(y[0]).add(d(e,T+8)),37).mul(x),s=c(s.add(y[1]).add(d(e,T+48)),42).mul(x),a=a.xor(b[1].mul(9)),s=s.add(y[0].mul(9).add(d(e,T+40))),g=c(g.add(b[0]),33).mul(x),y=m(e,T,y[1].mul(x),a.add(b[0])),b=m(e,T+32,g.add(b[1]),s.add(d(e,T+16))),[g,a]=[a,g],h(h(y[0],b[0],x).add(u(s).mul(i)).add(g),h(y[1],b[1],x).add(a),x)}e.s(["fingerPrint64",()=>f,"hexToLong",()=>s],707443),e.i(707443),e.s(["arraysEqual",()=>r.arraysEqual,"arraysEqualWithNull",()=>r.arraysEqualWithNull,"assert",()=>r.assert,"assertNonNegativeIntegerDimensions",()=>r.assertNonNegativeIntegerDimensions,"assertNonNull",()=>r.assertNonNull,"assertShapesMatch",()=>r.assertShapesMatch,"bytesFromStringArray",()=>r.bytesFromStringArray,"bytesPerElement",()=>r.bytesPerElement,"checkConversionForErrors",()=>r.checkConversionForErrors,"clamp",()=>r.clamp,"computeStrides",()=>r.computeStrides,"convertBackendValuesAndArrayBuffer",()=>r.convertBackendValuesAndArrayBuffer,"createScalarValue",()=>t.createScalarValue,"createShuffledIndices",()=>r.createShuffledIndices,"decodeString",()=>t.decodeString,"distSquared",()=>r.distSquared,"encodeString",()=>t.encodeString,"fetch",()=>t.fetch,"fingerPrint64",()=>f,"flatten",()=>t.flatten,"getArrayFromDType",()=>r.getArrayFromDType,"getTypedArrayFromDType",()=>r.getTypedArrayFromDType,"hasEncodingLoss",()=>r.hasEncodingLoss,"hexToLong",()=>s,"indexToLoc",()=>r.indexToLoc,"inferDtype",()=>r.inferDtype,"inferFromImplicitShape",()=>r.inferFromImplicitShape,"isBoolean",()=>r.isBoolean,"isFunction",()=>r.isFunction,"isInt",()=>r.isInt,"isNumber",()=>r.isNumber,"isPromise",()=>r.isPromise,"isScalarShape",()=>r.isScalarShape,"isString",()=>r.isString,"isTypedArray",()=>t.isTypedArray,"isValidDtype",()=>r.isValidDtype,"locToIndex",()=>r.locToIndex,"makeOnesTypedArray",()=>r.makeOnesTypedArray,"makeZerosNestedTypedArray",()=>r.makeZerosNestedTypedArray,"makeZerosTypedArray",()=>r.makeZerosTypedArray,"nearestDivisor",()=>r.nearestDivisor,"nearestLargerEven",()=>r.nearestLargerEven,"now",()=>t.now,"parseAxisParam",()=>r.parseAxisParam,"randUniform",()=>r.randUniform,"repeatedTry",()=>r.repeatedTry,"rightPad",()=>r.rightPad,"shuffle",()=>r.shuffle,"shuffleCombo",()=>r.shuffleCombo,"sizeFromShape",()=>r.sizeFromShape,"sizeToSquarishShape",()=>r.sizeToSquarishShape,"squeezeShape",()=>r.squeezeShape,"sum",()=>r.sum,"swap",()=>r.swap,"tanh",()=>r.tanh,"toNestedArray",()=>r.toNestedArray,"toTypedArray",()=>t.toTypedArray],353055);var g=e.i(353055);e.s(["util",0,g],449672)},516954,e=>{"use strict";var t=e.i(792452),r=e.i(40827),a=e.i(566389),n=e.i(940570),s=e.i(551200);let i=(0,a.op)({eye_:function(e,a,i,o="float32"){null==a&&(a=e);let l=(0,t.buffer)([e,a],o),u=e<=a?e:a;for(let e=0;e<u;++e)l.set(1,e,e);let p=(0,n.reshape)(l.toTensor(),[e,a]);if(null==i)return p;if(1===i.length)return(0,s.tile)((0,r.expandDims)(p,0),[i[0],1,1]);if(2===i.length)return(0,s.tile)((0,r.expandDims)((0,r.expandDims)(p,0),0),[i[0],i[1],1,1]);if(3===i.length)return(0,s.tile)((0,r.expandDims)((0,r.expandDims)((0,r.expandDims)(p,0),0),0),[i[0],i[1],i[2],1,1]);throw Error(`eye() currently supports only 1D and 2D batchShapes, but received ${i.length}D.`)}});e.s(["eye",0,i])},103624,e=>{"use strict";var t=e.i(27923),r=e.i(860623),a=e.i(592061),n=e.i(744877),s=e.i(240210),i=e.i(496378),o=e.i(536331),l=e.i(568503),u=e.i(673749),p=e.i(110369),d=e.i(345161),c=e.i(870360),h=e.i(952702),m=e.i(566389),f=e.i(940570);let g=(0,m.op)({fusedConv2d_:function({x:e,filter:m,strides:g,pad:y,dataFormat:b="NHWC",dilations:T=[1,1],dimRoundingMode:v,bias:N,activation:x="linear",preluActivationWeights:S,leakyreluAlpha:E}){let w,k;if(x=x||"linear",!1===(0,h.shouldFuse)(t.ENGINE.state.gradientDepth,x)){i.assert("NHWC"===b,()=>`Error in fused conv2d: got dataFormat of ${b} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let t=(0,u.conv2d)(e,m,g,y,b,T,v);return null!=N&&(t=(0,o.add)(t,N)),(0,h.applyActivation)(t,x,S,E)}let I=(0,s.convertToTensor)(e,"x","conv2d","float32"),A=(0,s.convertToTensor)(m,"filter","conv2d","float32"),P=I,M=!1;3===I.rank&&(M=!0,P=(0,f.reshape)(I,[1,I.shape[0],I.shape[1],I.shape[2]])),i.assert(4===P.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${P.rank}.`),i.assert(4===A.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${A.rank}.`),c.checkPadOnDimRoundingMode("fused conv2d",y,v);let _="NHWC"===b?P.shape[3]:P.shape[1];i.assert(A.shape[2]===_,()=>`Error in conv2d: depth of input (${_}) must match input depth for filter ${A.shape[2]}.`),i.assert(c.eitherStridesOrDilationsAreOne(g,T),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${g} and dilations '${T}'`);let V=c.computeConv2DInfo(P.shape,A.shape,g,T,y,v);if(null!=N&&(w=(0,s.convertToTensor)(N,"bias","fused conv2d"),[w]=(0,n.makeTypesMatch)(w,I),"NHWC"===b?l.assertAndGetBroadcastShape(V.outShape,w.shape):(i.assert(w.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${w.shape.length}.`),i.assert(0===w.shape.length||w.shape[0]===V.outChannels||1===w.shape[0],()=>`Error in fused conv2d: bias shape (${w.shape}) is not compatible with the number of output channels (${V.outChannels})`))),null!=S){let e=S.shape;if(i.assert(e.length<=1||3===e.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`),1===e.length)i.assert(1===e[0]||e[0]===V.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${V.outChannels}).`);else if(3===e.length)try{l.assertAndGetBroadcastShape(e,V.outShape)}catch(t){throw Error(`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${V.outShape}).`)}k=(0,s.convertToTensor)(S,"prelu weights","fused conv2d")}let D=(e,t)=>{i.assert("NHWC"===b,()=>`Error in gradient of fused conv2D: got dataFormat of ${b} but only NHWC is currently supported.`);let[r,a,n,s]=t,o=(0,h.getFusedDyActivation)(e,n,x);i.assert(c.tupleValuesAreOne(T),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${T}'`);let l=[(0,d.conv2DBackpropInput)(a.shape,o,r,g,y),(0,p.conv2DBackpropFilter)(a,o,r.shape,g,y)];if(null!=s){let e=(0,h.getFusedBiasGradient)(s,o);l.push(e)}return l},$={x:P,filter:A,bias:w,preluActivationWeights:k},O={strides:g,pad:y,dataFormat:b,dilations:T,dimRoundingMode:v,activation:x,leakyreluAlpha:E};return null==N?(0,r.customGrad)((e,r,n)=>{let s=t.ENGINE.runKernel(a.FusedConv2D,$,O);return n([r,e,s]),M&&(s=(0,f.reshape)(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:D}})(P,A):(0,r.customGrad)((e,r,n,s)=>{let i=t.ENGINE.runKernel(a.FusedConv2D,$,O);return s([r,e,i,n]),M&&(i=(0,f.reshape)(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:D}})(P,A,w)}});e.s(["conv2d",0,g])},607476,e=>{"use strict";var t=e.i(27923),r=e.i(860623),a=e.i(592061),n=e.i(744877),s=e.i(240210),i=e.i(496378),o=e.i(536331),l=e.i(568503),u=e.i(870360),p=e.i(985730),d=e.i(240053),c=e.i(156329),h=e.i(952702),m=e.i(566389),f=e.i(940570);let g=(0,m.op)({fusedDepthwiseConv2d_:function({x:e,filter:m,strides:g,pad:y,dataFormat:b="NHWC",dilations:T=[1,1],dimRoundingMode:v,bias:N,activation:x="linear",preluActivationWeights:S,leakyreluAlpha:E}){let w,k;if(!1===(0,h.shouldFuse)(t.ENGINE.state.gradientDepth,x)){let t=(0,p.depthwiseConv2d)(e,m,g,y,b,T,v);return null!=N&&(t=(0,o.add)(t,N)),(0,h.applyActivation)(t,x,S,E)}let I=(0,s.convertToTensor)(e,"x","depthwiseConv2d","float32"),A=(0,s.convertToTensor)(m,"filter","depthwiseConv2d","float32"),P=I,M=!1;3===I.rank&&(M=!0,P=(0,f.reshape)(I,[1,I.shape[0],I.shape[1],I.shape[2]])),i.assert(4===P.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${P.rank}.`),i.assert(4===A.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${A.rank}.`),i.assert(P.shape[3]===A.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${P.shape[3]}) must match the inChannels dimension in filter ${A.shape[2]}.`),null==T&&(T=[1,1]),i.assert(u.eitherStridesOrDilationsAreOne(g,T),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${g} and dilations '${T}'`),u.checkPadOnDimRoundingMode("fused depthwiseConv2d",y,v);let _=u.computeConv2DInfo(P.shape,A.shape,g,T,y,v,!0);null!=N&&(w=(0,s.convertToTensor)(N,"bias","fused conv2d"),[w]=(0,n.makeTypesMatch)(w,I),l.assertAndGetBroadcastShape(_.outShape,w.shape)),null!=S&&(k=(0,s.convertToTensor)(S,"prelu weights","fused depthwiseConv2d"));let V=(e,t)=>{i.assert(u.tupleValuesAreOne(T),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${T}'`);let[r,a,n,s]=t,o=(0,h.getFusedDyActivation)(e,n,x),l=(0,c.depthwiseConv2dNativeBackpropInput)(a.shape,o,r,g,y,T,v),p=(0,d.depthwiseConv2dNativeBackpropFilter)(a,o,r.shape,g,y,T,v);return null!=s?[l,p,(0,h.getFusedBiasGradient)(w,o)]:[l,p]},D={x:P,filter:A,bias:w,preluActivationWeights:k},$={strides:g,pad:y,dataFormat:b,dilations:T,dimRoundingMode:v,activation:x,leakyreluAlpha:E};return null==N?(0,r.customGrad)((e,r,n)=>{let s=t.ENGINE.runKernel(a.FusedDepthwiseConv2D,D,$);return n([r,e,s]),M&&(s=(0,f.reshape)(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:V}})(P,A):(0,r.customGrad)((e,r,n,s)=>{let i=t.ENGINE.runKernel(a.FusedDepthwiseConv2D,D,$);return s([r,e,i,n]),M&&(i=(0,f.reshape)(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:V}})(P,A,w)}});e.s(["depthwiseConv2d",0,g])},809827,260188,512960,669487,747418,973946,913269,566617,239110,597730,e=>{"use strict";var t=e.i(103624),r=e.i(607476),a=e.i(27923),n=e.i(860623),s=e.i(592061),i=e.i(744877),o=e.i(240210),l=e.i(496378),u=e.i(536331),p=e.i(568503),d=e.i(952702),c=e.i(656040),h=e.i(566389),m=e.i(940570);let f=(0,h.op)({fusedMatMul_:function({a:e,b:t,transposeA:r=!1,transposeB:h=!1,bias:f,activation:g="linear",preluActivationWeights:y,leakyreluAlpha:b=.2}){let T,v;if(!1===(0,d.shouldFuse)(a.ENGINE.state.gradientDepth,g)){let a=(0,c.matMul)(e,t,r,h);return null!=f&&(a=(0,u.add)(a,f)),(0,d.applyActivation)(a,g,y,b)}let N=(0,o.convertToTensor)(e,"a","fused matMul"),x=(0,o.convertToTensor)(t,"b","fused matMul");[N,x]=(0,i.makeTypesMatch)(N,x);let S=r?N.shape[N.rank-2]:N.shape[N.rank-1],E=h?x.shape[x.rank-1]:x.shape[x.rank-2],w=r?N.shape[N.rank-1]:N.shape[N.rank-2],k=h?x.shape[x.rank-2]:x.shape[x.rank-1],I=N.shape.slice(0,-2),A=x.shape.slice(0,-2),P=l.sizeFromShape(I),M=l.sizeFromShape(A);l.assert(S===E,()=>`Error in fused matMul: inner shapes (${S}) and (${E}) of Tensors with shapes ${N.shape} and ${x.shape} and transposeA=${r} and transposeB=${h} must match.`);let _=p.assertAndGetBroadcastShape(N.shape.slice(0,-2),x.shape.slice(0,-2)).concat([w,k]),V=r?(0,m.reshape)(N,[P,S,w]):(0,m.reshape)(N,[P,w,S]),D=h?(0,m.reshape)(x,[M,k,E]):(0,m.reshape)(x,[M,E,k]);null!=f&&(T=(0,o.convertToTensor)(f,"bias","fused matMul"),[T]=(0,i.makeTypesMatch)(T,N),p.assertAndGetBroadcastShape(_,T.shape)),null!=y&&(v=(0,o.convertToTensor)(y,"prelu weights","fused matMul"));let $=(e,t)=>{let a,n,[s,i,o,l]=t,u=(0,d.getFusedDyActivation)((0,m.reshape)(e,o.shape),o,g);return(r||h?!r&&h?(a=(0,c.matMul)(u,i,!1,!1),n=(0,c.matMul)(u,s,!0,!1)):r&&!h?(a=(0,c.matMul)(i,u,!1,!0),n=(0,c.matMul)(s,u,!1,!1)):(a=(0,c.matMul)(i,u,!0,!0),n=(0,c.matMul)(u,s,!0,!0)):(a=(0,c.matMul)(u,i,!1,!0),n=(0,c.matMul)(s,u,!0,!1)),null!=f)?[a,n,(0,d.getFusedBiasGradient)(l,u)]:[a,n]},O={a:V,b:D,bias:T,preluActivationWeights:v},R={transposeA:r,transposeB:h,activation:g,leakyreluAlpha:b};return null==f?(0,n.customGrad)((e,t,r)=>{let n=a.ENGINE.runKernel(s._FusedMatMul,O,R);return r([e,t,n]),{value:(0,m.reshape)(n,_),gradFunc:$}})(V,D):(0,n.customGrad)((e,t,r,n)=>{let i=a.ENGINE.runKernel(s._FusedMatMul,O,R);return n([e,t,i,r]),{value:(0,m.reshape)(i,_),gradFunc:$}})(V,D,T)}});e.s([],554238),e.i(554238),e.s(["conv2d",()=>t.conv2d,"depthwiseConv2d",()=>r.depthwiseConv2d,"matMul",0,f],809827);var g=e.i(121930);function y(e,t){(0,l.assertNonNull)(e);let r=(0,o.inferShape)(e,t);if(1!==r.length)throw Error("tensor1d() requires values to be a flat/TypedArray");return(0,g.makeTensor)(e,null,r,t)}function b(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function T(e,t,r){let a=1-e%2,n=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+a-1);n[s]=t-r*Math.cos(i)}return y(n,"float32")}e.s(["tensor1d",()=>y],260188),e.s(["cosineWindow",()=>T,"enclosingPowerOfTwo",()=>b],512960);let v=(0,h.op)({hammingWindow_:function(e){return T(e,.54,.46)}});e.s(["hammingWindow",0,v],669487);let N=(0,h.op)({hannWindow_:function(e){return T(e,.5,.5)}});e.s(["hannWindow",0,N],747418);var x=e.i(655015),S=e.i(419886),E=e.i(606764);function w(e,t,r){if((0,l.assertNonNull)(e),null!=t&&2!==t.length)throw Error("tensor2d() requires shape to have two numbers");let a=(0,o.inferShape)(e,r);if(2!==a.length&&1!==a.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,g.makeTensor)(e,t,a,r)}e.s(["tensor2d",()=>w],973946);let k=(0,h.op)({frame_:function(e,t,r,a=!1,n=0){let s=0,i=[];for(;s+t<=e.size;)i.push((0,E.slice)(e,s,t)),s+=r;if(a)for(;s<e.size;){let a=s+t-e.size,o=(0,x.concat)([(0,E.slice)(e,s,t-a),(0,S.fill)([a],n)]);i.push(o),s+=r}return 0===i.length?w([],[0,t]):(0,m.reshape)((0,x.concat)(i),[i.length,t])}});e.s(["frame",0,k],913269);var I=e.i(449404),A=e.i(470353);let P=(0,h.op)({stft_:function(e,t,r,a,n=N){null==a&&(a=b(t));let s=k(e,t,r),i=(0,I.mul)(s,n(t));return(0,A.rfft)(i,a)}});e.s(["stft",0,P],566617);let M=(0,h.op)({cropAndResize_:function(e,t,r,n,i="bilinear",u=0){let p=(0,o.convertToTensor)(e,"image","cropAndResize"),d=(0,o.convertToTensor)(t,"boxes","cropAndResize","float32"),c=(0,o.convertToTensor)(r,"boxInd","cropAndResize","int32"),h=d.shape[0];return l.assert(4===p.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${p.rank}.`),l.assert(2===d.rank&&4===d.shape[1],()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${d.shape}.`),l.assert(1===c.rank&&c.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${d.shape}.`),l.assert(2===n.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),l.assert(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),l.assert("bilinear"===i||"nearest"===i,()=>`method must be bilinear or nearest, but was ${i}`),a.ENGINE.runKernel(s.CropAndResize,{image:p,boxes:d,boxInd:c},{method:i,extrapolationValue:u,cropSize:n})}});e.s(["cropAndResize",0,M],239110);let _=(0,h.op)({flipLeftRight_:function(e){let t=(0,o.convertToTensor)(e,"image","flipLeftRight","float32");return l.assert(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),a.ENGINE.runKernel(s.FlipLeftRight,{image:t},{})}});e.s(["flipLeftRight",0,_],597730)},197293,725517,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(566389),n=e.i(551200);let s=(0,a.op)({grayscaleToRGB_:function(e){let a=(0,t.convertToTensor)(e,"image","grayscaleToRGB"),s=a.rank-1,i=a.shape[s];r.assert(a.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${a.rank}.`),r.assert(1===i,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${i}.`);let o=Array(a.rank);return o.fill(1,0,s),o[s]=3,(0,n.tile)(a,o)}});e.s(["grayscaleToRGB",0,s],197293);var i=e.i(27923),o=e.i(592061);let l=(0,a.op)({einsum_:function(e,...r){let a=r.map((e,r)=>(0,t.convertToTensor)(e,`tensors${r}`,"einsum"));return i.ENGINE.runKernel(o.Einsum,a,{equation:e})}});e.s(["einsum",0,l],725517)},800591,142311,637659,665971,656139,16523,679754,842976,47046,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(494096),n=e.i(725517),s=e.i(40827),i=e.i(566389),o=e.i(260188);let l=(0,i.op)({rgbToGrayscale_:function(e){let i,l=(0,t.convertToTensor)(e,"image","RGBToGrayscale"),u=l.rank-1,p=l.shape[u];r.assert(l.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${l.rank}.`),r.assert(3===p,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${p}.`);let d=l.dtype,c=(0,a.cast)(l,"float32"),h=(0,o.tensor1d)([.2989,.587,.114]);switch(l.rank){case 2:i=(0,n.einsum)("ij,j->i",c,h);break;case 3:i=(0,n.einsum)("ijk,k->ij",c,h);break;case 4:i=(0,n.einsum)("ijkl,l->ijk",c,h);break;case 5:i=(0,n.einsum)("ijklm,m->ijkl",c,h);break;case 6:i=(0,n.einsum)("ijklmn,n->ijklm",c,h);break;default:throw Error("Not a valid tensor rank.")}return i=(0,s.expandDims)(i,-1),(0,a.cast)(i,d)}});e.s(["rgbToGrayscale",0,l],800591);var u=e.i(27923),p=e.i(592061);let d=(0,i.op)({rotateWithOffset_:function(e,a,n=0,s=.5){let i=(0,t.convertToTensor)(e,"image","rotateWithOffset","float32");return r.assert(4===i.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`),u.ENGINE.runKernel(p.RotateWithOffset,{image:i},{radians:a,fillValue:n,center:s})}});function c(e,t,a,n,s,i){null==n&&(n=.5),null==s&&(s=-1/0),null==i&&(i=0);let o=e.shape[0];return a=Math.min(a,o),r.assert(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),r.assert(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),r.assert(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),r.assert(1===t.rank,()=>"scores must be a 1D tensor"),r.assert(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),r.assert(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:a,iouThreshold:n,scoreThreshold:s,softNmsSigma:i}}e.s(["rotateWithOffset",0,d],142311);let h=(0,i.op)({nonMaxSuppression_:function(e,r,a,n=.5,s=-1/0){let i=(0,t.convertToTensor)(e,"boxes","nonMaxSuppression","float32"),o=(0,t.convertToTensor)(r,"scores","nonMaxSuppression","float32"),l=c(i,o,a,n,s);a=l.maxOutputSize;let d={maxOutputSize:a,iouThreshold:n=l.iouThreshold,scoreThreshold:s=l.scoreThreshold};return u.ENGINE.runKernel(p.NonMaxSuppressionV3,{boxes:i,scores:o},d)}});function m(e,t){return e>t?1:e<t?-1:0}function f(e,t,r,a,n){return b(e,t,r,a,n,0)}function g(e,t,r,a,n,s){return b(e,t,r,a,n,0,!1,s,!0)}function y(e,t,r,a,n,s){return b(e,t,r,a,n,s,!0)}function b(e,t,r,a,n,s,i=!1,o=!1,l=!1){let u=[];for(let e=0;e<t.length;e++)t[e]>n&&u.push({score:t[e],boxIndex:e,suppressBeginIndex:0});u.sort(T);let p=s>0?-.5/s:0,d=[],c=[];for(;d.length<r&&u.length>0;){let t=u.pop(),{score:r,boxIndex:s,suppressBeginIndex:i}=t;if(r<n)break;let o=!1;for(let r=d.length-1;r>=i;--r){let i=function(e,t,r){let a=e.subarray(4*t,4*t+4),n=e.subarray(4*r,4*r+4),s=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),l=Math.max(a[1],a[3]),u=Math.min(n[0],n[2]),p=Math.min(n[1],n[3]),d=Math.max(n[0],n[2]),c=Math.max(n[1],n[3]),h=(o-s)*(l-i),m=(d-u)*(c-p);if(h<=0||m<=0)return 0;let f=Math.max(Math.min(o,d)-Math.max(s,u),0)*Math.max(Math.min(l,c)-Math.max(i,p),0);return f/(h+m-f)}(e,s,d[r]);if(i>=a){o=!0;break}if(t.score=t.score*function(e,t,r){let a=Math.exp(t*r*r);return r<=e?a:0}(a,p,i),t.score<=n)break}t.suppressBeginIndex=d.length,!o&&(t.score===r?(d.push(s),c.push(t.score)):t.score>n&&function(e,t,r){let a=function(e,t,r){let a=0,n=e.length,s=0,i=!1;for(;a<n;){let o=r(t,e[s=a+(n-a>>>1)]);o>0?a=s+1:(n=s,i=!o)}return i?a:-a-1}(e,t,r||m);e.splice(a<0?-(a+1):a,0,t)}(u,t,T))}let h=d.length,f=r-h;o&&f>0&&(d.push(...Array(f).fill(0)),c.push(...Array(f).fill(0)));let g={selectedIndices:d};return i&&(g.selectedScores=c),l&&(g.validOutputs=h),g}function T(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function v(e,r,a,n=.5,s=-1/0){let i=(0,t.convertToTensor)(e,"boxes","nonMaxSuppressionAsync"),l=(0,t.convertToTensor)(r,"scores","nonMaxSuppressionAsync"),u=c(i,l,a,n,s);a=u.maxOutputSize,n=u.iouThreshold,s=u.scoreThreshold;let p=await Promise.all([i.data(),l.data()]),{selectedIndices:d}=f(p[0],p[1],a,n,s);return i!==e&&i.dispose(),l!==r&&l.dispose(),(0,o.tensor1d)(d,"int32")}e.s(["nonMaxSuppression",0,h],637659),e.s(["nonMaxSuppressionV3Impl",()=>f,"nonMaxSuppressionV4Impl",()=>g,"nonMaxSuppressionV5Impl",()=>y],665971),e.s(["nonMaxSuppressionAsync",0,v],656139);let N=(0,i.op)({nonMaxSuppressionWithScore_:function(e,r,a,n=.5,s=-1/0,i=0){let o=(0,t.convertToTensor)(e,"boxes","nonMaxSuppression"),l=(0,t.convertToTensor)(r,"scores","nonMaxSuppression"),d=c(o,l,a,n,s,i);a=d.maxOutputSize,n=d.iouThreshold,s=d.scoreThreshold;let h={maxOutputSize:a,iouThreshold:n,scoreThreshold:s,softNmsSigma:i=d.softNmsSigma},m=u.ENGINE.runKernel(p.NonMaxSuppressionV5,{boxes:o,scores:l},h);return{selectedIndices:m[0],selectedScores:m[1]}}});async function x(e,r,a,n=.5,s=-1/0,i=0){let l=(0,t.convertToTensor)(e,"boxes","nonMaxSuppressionAsync"),u=(0,t.convertToTensor)(r,"scores","nonMaxSuppressionAsync"),p=c(l,u,a,n,s,i);a=p.maxOutputSize,n=p.iouThreshold,s=p.scoreThreshold,i=p.softNmsSigma;let d=await Promise.all([l.data(),u.data()]),{selectedIndices:h,selectedScores:m}=y(d[0],d[1],a,n,s,i);return l!==e&&l.dispose(),u!==r&&u.dispose(),{selectedIndices:(0,o.tensor1d)(h,"int32"),selectedScores:(0,o.tensor1d)(m)}}e.s(["nonMaxSuppressionWithScore",0,N],16523),e.s(["nonMaxSuppressionWithScoreAsync",0,x],679754);let S=(0,i.op)({nonMaxSuppressionPadded_:function(e,r,a,n=.5,s=-1/0,i=!1){let o=(0,t.convertToTensor)(e,"boxes","nonMaxSuppression"),l=(0,t.convertToTensor)(r,"scores","nonMaxSuppression"),d=c(o,l,a,n,s,null),h=d.maxOutputSize,m=d.iouThreshold,f=d.scoreThreshold,g=u.ENGINE.runKernel(p.NonMaxSuppressionV4,{boxes:o,scores:l},{maxOutputSize:h,iouThreshold:m,scoreThreshold:f,padToMaxOutputSize:i});return{selectedIndices:g[0],validOutputs:g[1]}}});e.s(["nonMaxSuppressionPadded",0,S],842976);var E=e.i(919862);async function w(e,r,a,n=.5,s=-1/0,i=!1){let l=(0,t.convertToTensor)(e,"boxes","nonMaxSuppressionAsync"),u=(0,t.convertToTensor)(r,"scores","nonMaxSuppressionAsync"),p=c(l,u,a,n,s,null),d=p.maxOutputSize,h=p.iouThreshold,m=p.scoreThreshold,[f,y]=await Promise.all([l.data(),u.data()]),{selectedIndices:b,validOutputs:T}=g(f,y,d,h,m,i);return l!==e&&l.dispose(),u!==r&&u.dispose(),{selectedIndices:(0,o.tensor1d)(b,"int32"),validOutputs:(0,E.scalar)(T,"int32")}}e.s(["nonMaxSuppressionPaddedAsync",0,w],47046)},722097,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({bincount_:function(e,s,i){let o=(0,a.convertToTensor)(e,"x","bincount"),l=(0,a.convertToTensor)(s,"weights","bincount");return n.assert("int32"===o.dtype,()=>`Error in bincount: input dtype must be int32, but got ${o.dtype}`),n.assert(i>=0,()=>`size must be non-negative, but got ${i}.`),n.assert(l.size===o.size||0===l.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${o.shape}, weights shape: ${l.shape}.`),t.ENGINE.runKernel(r.Bincount,{x:o,weights:l},{size:i})}});e.s(["bincount",0,s])},625792,528280,33701,e=>{"use strict";var t=e.i(260188),r=e.i(566389),a=e.i(494096),n=e.i(798670),s=e.i(722097),i=e.i(612700),o=e.i(101123),l=e.i(101669),u=e.i(536331),p=e.i(449404),d=e.i(680837),c=e.i(33457),h=e.i(751057),m=e.i(379250),f=e.i(419886),g=e.i(606764),y=e.i(27923),b=e.i(592061);function T(e,t,r=1,a="float32"){if(0===r)throw Error("Cannot have a step of zero");return y.ENGINE.runKernel(b.Range,{},{start:e,stop:t,step:r,dtype:a})}e.s(["range",()=>T],528280);var v=e.i(861392),N=e.i(496378),x=e.i(240210);let S=(0,r.op)({threshold_:function(e,r="binary",y=!1,b=.5){let S,E,w,k,I=(0,x.convertToTensor)(e,"image","threshold"),A=I.shape[0]*I.shape[1],P=(0,p.mul)((0,t.tensor1d)([b]),255);if(N.assert(3===I.rank,()=>`Error in threshold: image must be rank 3,but got rank ${I.rank}.`),N.assert(3===I.shape[2]||1===I.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${I.shape[2]}.`),N.assert("int32"===I.dtype||"float32"===I.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${I.dtype}.`),N.assert("otsu"===r||"binary"===r,()=>`Method must be binary or otsu, but was ${r}`),3===I.shape[2]){[S,E,w]=(0,n.split)(I,[1,1,1],-1);let e=(0,p.mul)(S,.2989),t=(0,p.mul)(E,.587),r=(0,p.mul)(w,.114);k=(0,u.add)((0,u.add)(e,t),r)}else k=e;"otsu"===r&&(P=function(e,r){let a,n,s,i,h,y,b=(0,t.tensor1d)([-1]),v=(0,t.tensor1d)([0]),N=(0,t.tensor1d)([0]);for(let x=0;x<e.size-1;x++){a=(0,g.slice)(e,0,x+1),n=(0,g.slice)(e,x+1),h=(0,d.div)((0,l.sum)(a),r),y=(0,d.div)((0,l.sum)(n),r);let S=(0,l.sum)((0,p.mul)(a,T(0,a.size)));s=(0,d.div)(S,(0,l.sum)(a));let E=(0,f.fill)(n.shape,a.size),w=(0,u.add)(T(0,n.size),E),k=(0,p.mul)(n,w);i=(0,d.div)((0,l.sum)(k),(0,l.sum)(n));let I=(0,c.sub)(s,i),A=(0,c.sub)(s,i),P=(0,p.mul)(h,y);N=(0,p.mul)((0,p.mul)(P,I),A);let M=(0,o.greater)(N,v);v=(0,m.where)(M,N,v),b=(0,m.where)(M,(0,t.tensor1d)([x]),b)}return b}((0,s.bincount)((0,a.cast)((0,h.round)(k),"int32"),(0,v.tensor)([]),256),A));let M=y?(0,i.lessEqual)(k,P):(0,o.greater)(k,P);return(0,a.cast)((0,p.mul)(M,255),"int32")}});e.s(["threshold",0,S],625792);let E=(0,r.op)({transform_:function(e,t,r="nearest",a="constant",n=0,s){let i=(0,x.convertToTensor)(e,"image","transform","float32"),o=(0,x.convertToTensor)(t,"transforms","transform","float32");return N.assert(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),N.assert(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),N.assert(null==s||2===s.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`),y.ENGINE.runKernel(b.Transform,{image:i,transforms:o},{interpolation:r,fillMode:a,fillValue:n,outputShape:s})}});e.s(["transform",0,E],33701)},554864,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(318814),n=e.i(388566),s=e.i(612700),i=e.i(783171),o=e.i(600936),l=e.i(408604),u=e.i(566389),p=e.i(528280),d=e.i(940570),c=e.i(691832),h=e.i(33457),m=e.i(295175),f=e.i(379250),g=e.i(394596);let y=(0,u.op)({bandPart_:function(e,u,y){let b,T,v=(0,t.convertToTensor)(e,"a","bandPart");(0,r.assert)(v.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${v.rank}.`);let N=v.shape,[x,S]=v.shape.slice(-2);"number"==typeof u?((0,r.assert)(u%1==0,()=>`bandPart(): numLower must be an integer, got ${u}.`),(0,r.assert)(u<=x,()=>`bandPart(): numLower (${u}) must not be greater than the number of rows (${x}).`),b=(0,t.convertToTensor)(u<0?x:u,"numLower","bandPart")):((0,r.assert)("int32"===u.dtype,()=>"bandPart(): numLower's dtype must be an int32."),b=(0,f.where)((0,n.less)(u,0),x,(0,o.minimum)(u,x))),"number"==typeof y?((0,r.assert)(y%1==0,()=>`bandPart(): numUpper must be an integer, got ${y}.`),(0,r.assert)(y<=S,()=>`bandPart(): numUpper (${y}) must not be greater than the number of columns (${S}).`),T=(0,t.convertToTensor)(y<0?S:y,"numUpper","bandPart")):((0,r.assert)("int32"===y.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),T=(0,f.where)((0,n.less)(y,0),S,(0,o.minimum)(y,S)));let E=(0,d.reshape)((0,p.range)(0,x,1,"int32"),[-1,1]),w=(0,p.range)(0,S,1,"int32"),k=(0,h.sub)(E,w),I=(0,i.logicalAnd)((0,s.lessEqual)(k,b),(0,a.greaterEqual)(k,(0,l.neg)(T))),A=(0,g.zeros)([x,S],v.dtype);return(0,d.reshape)((0,c.stack)((0,m.unstack)((0,d.reshape)(v,[-1,x,S])).map(e=>(0,f.where)(I,e,A))),N)}});e.s(["bandPart",0,y])},893857,e=>{"use strict";var t=e.i(27923),r=e.i(496378),a=e.i(680837),n=e.i(449404),s=e.i(683784),i=e.i(566389),o=e.i(798670),l=e.i(836111),u=e.i(691832),p=e.i(33457),d=e.i(101669);let c=(0,i.op)({gramSchmidt_:function(e){let i;if(Array.isArray(e)){i=!1,(0,r.assert)(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let t=e[0].shape[0];for(let a=1;a<e.length;++a)(0,r.assert)(e[a].shape[0]===t,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${t})`)}else i=!0,e=(0,o.split)(e,e.shape[0],0).map(e=>(0,l.squeeze)(e,[0]));(0,r.assert)(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let c=[],h=e;for(let r=0;r<e.length;++r)c.push(t.ENGINE.tidy(()=>{let e=h[r];if(r>0)for(let t=0;t<r;++t){let r=(0,n.mul)((0,d.sum)((0,n.mul)(c[t],e)),c[t]);e=(0,p.sub)(e,r)}return(0,a.div)(e,(0,s.norm)(e,"euclidean"))}));return i?(0,u.stack)(c,0):c}});e.s(["gramSchmidt",0,c])},355821,784367,e=>{"use strict";var t,r,a=e.i(27923),n=e.i(720606),s=e.i(496378),i=e.i(612930),o=e.i(655015),l=e.i(680837),u=e.i(516954),p=e.i(101123),d=e.i(656040),c=e.i(449404),h=e.i(408604),m=e.i(683784),f=e.i(566389),g=e.i(940570),y=e.i(606764),b=e.i(691832),T=e.i(33457),v=e.i(973946),N=e.i(604907),x=e.i(295175),S=e.i(379250);function E(e,t=!1){return a.ENGINE.tidy(()=>{(0,s.assert)(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let r=e.shape[0],f=e.shape[1],g=(0,u.eye)(r),b=(0,i.clone)(e),x=(0,v.tensor2d)([[1]],[1,1]),E=(0,i.clone)(x),w=r>=f?f:r;for(let e=0;e<w;++e){let t=b,s=E,u=g;[E,b,g]=a.ENGINE.tidy(()=>{let t=(0,y.slice)(b,[e,e],[r-e,1]),a=(0,m.norm)(t),n=(0,y.slice)(b,[e,e],[1,1]),s=(0,S.where)((0,p.greater)(n,0),(0,v.tensor2d)([[-1]]),(0,v.tensor2d)([[1]])),u=(0,T.sub)(n,(0,c.mul)(s,a)),w=(0,l.div)(t,u);E=1===w.shape[0]?(0,i.clone)(x):(0,o.concat)([x,(0,y.slice)(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);let k=(0,h.neg)((0,l.div)((0,d.matMul)(s,u),a)),I=(0,y.slice)(b,[e,0],[r-e,f]),A=(0,c.mul)(k,E),P=(0,N.transpose)(E);if(0===e)b=(0,T.sub)(I,(0,d.matMul)(A,(0,d.matMul)(P,I)));else{let t=(0,T.sub)(I,(0,d.matMul)(A,(0,d.matMul)(P,I)));b=(0,o.concat)([(0,y.slice)(b,[0,0],[e,f]),t],0)}let M=(0,N.transpose)(A),_=(0,y.slice)(g,[0,e],[r,g.shape[1]-e]);if(0===e)g=(0,T.sub)(_,(0,d.matMul)((0,d.matMul)(_,E),M));else{let t=(0,T.sub)(_,(0,d.matMul)((0,d.matMul)(_,E),M));g=(0,o.concat)([(0,y.slice)(g,[0,0],[r,e]),t],1)}return[E,b,g]}),(0,n.dispose)([t,s,u])}return!t&&r>f&&(g=(0,y.slice)(g,[0,0],[r,f]),b=(0,y.slice)(b,[0,0],[f,f])),[g,b]})}let w=(0,f.op)({qr_:function(e,t=!1){if((0,s.assert)(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return E(e,t);{let r=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),a=(0,x.unstack)((0,g.reshape)(e,[r,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),n=[],s=[];return a.forEach(e=>{let[r,a]=E(e,t);n.push(r),s.push(a)}),[(0,g.reshape)((0,b.stack)(n,0),e.shape),(0,g.reshape)((0,b.stack)(s,0),e.shape)]}}});e.s(["qr",0,w],355821),(t=r||(r={}))[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",e.s(["Reduction",()=>r],784367)},947064,802504,532193,148446,489762,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(410616),n=e.i(784367),s=e.i(566389),i=e.i(33457),o=e.i(494096),l=e.i(680837),u=e.i(155217),p=e.i(449404),d=e.i(344658),c=e.i(434425),h=e.i(919862),m=e.i(101669);let f=(0,s.op)({computeWeightedLoss_:function(e,r,a=n.Reduction.SUM_BY_NONZERO_WEIGHTS){let s=(0,t.convertToTensor)(e,"losses","computeWeightedLoss"),i=null;null!=r&&(i=(0,t.convertToTensor)(r,"weights","computeWeightedLoss"));let f=null==i?s:(0,p.mul)(s,i);if(a===n.Reduction.NONE)return f;if(a===n.Reduction.SUM)return(0,m.sum)(f);if(a===n.Reduction.MEAN)if(null==i)return(0,u.mean)(f);else{let e=s.size/i.size,t=(0,l.div)((0,m.sum)(f),(0,m.sum)(i));return e>1?(0,l.div)(t,(0,h.scalar)(e)):t}if(a===n.Reduction.SUM_BY_NONZERO_WEIGHTS)if(null==i)return(0,l.div)((0,m.sum)(f),(0,h.scalar)(s.size));else{let e=(0,p.mul)(i,(0,c.ones)(s.shape)),t=(0,o.cast)((0,m.sum)((0,d.notEqual)(e,(0,h.scalar)(0))),"float32");return(0,l.div)((0,m.sum)(f),t)}throw Error(`Unknown reduction: ${a}`)}});e.s(["computeWeightedLoss",0,f],802504);let g=(0,s.op)({absoluteDifference_:function(e,s,o,l=n.Reduction.SUM_BY_NONZERO_WEIGHTS){let u=(0,t.convertToTensor)(e,"labels","absoluteDifference"),p=(0,t.convertToTensor)(s,"predictions","absoluteDifference"),d=null;return null!=o&&(d=(0,t.convertToTensor)(o,"weights","absoluteDifference")),(0,r.assertShapesMatch)(u.shape,p.shape,"Error in absoluteDifference: "),f((0,a.abs)((0,i.sub)(u,p)),d,l)}});e.s(["absoluteDifference",0,g],947064);let y=(0,s.op)({cosineDistance_:function(e,a,s,o,l=n.Reduction.SUM_BY_NONZERO_WEIGHTS){let u=(0,t.convertToTensor)(e,"labels","cosineDistance"),d=(0,t.convertToTensor)(a,"predictions","cosineDistance"),c=null;null!=o&&(c=(0,t.convertToTensor)(o,"weights","cosineDistance")),(0,r.assertShapesMatch)(u.shape,d.shape,"Error in cosineDistance: ");let g=(0,h.scalar)(1);return f((0,i.sub)(g,(0,m.sum)((0,p.mul)(u,d),s,!0)),c,l)}});e.s(["cosineDistance",0,y],532193);var b=e.i(539333);let T=(0,s.op)({hingeLoss_:function(e,a,s,o=n.Reduction.SUM_BY_NONZERO_WEIGHTS){let l=(0,t.convertToTensor)(e,"labels","hingeLoss"),u=(0,t.convertToTensor)(a,"predictions","hingeLoss"),d=null;null!=s&&(d=(0,t.convertToTensor)(s,"weights","hingeLoss")),(0,r.assertShapesMatch)(l.shape,u.shape,"Error in hingeLoss: ");let c=(0,h.scalar)(1);return l=(0,i.sub)((0,p.mul)((0,h.scalar)(2),l),c),f((0,b.relu)((0,i.sub)(c,(0,p.mul)(l,u))),d,o)}});e.s(["hingeLoss",0,T],148446);var v=e.i(536331),N=e.i(600936),x=e.i(240774);let S=(0,s.op)({huberLoss_:function(e,s,o,l=1,u=n.Reduction.SUM_BY_NONZERO_WEIGHTS){let d=(0,t.convertToTensor)(e,"labels","huberLoss"),c=(0,t.convertToTensor)(s,"predictions","huberLoss"),m=null;null!=o&&(m=(0,t.convertToTensor)(o,"weights","huberLoss")),(0,r.assertShapesMatch)(d.shape,c.shape,"Error in huberLoss: ");let g=(0,h.scalar)(l),y=(0,a.abs)((0,i.sub)(c,d)),b=(0,N.minimum)(y,g),T=(0,i.sub)(y,b);return f((0,v.add)((0,p.mul)((0,h.scalar)(.5),(0,x.square)(b)),(0,p.mul)(g,T)),m,u)}});e.s(["huberLoss",0,S],489762)},285192,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(536331),n=e.i(322459),s=e.i(784367),i=e.i(449404),o=e.i(408604),l=e.i(566389),u=e.i(919862),p=e.i(33457),d=e.i(802504);let c=(0,l.op)({logLoss_:function(e,l,c,h=1e-7,m=s.Reduction.SUM_BY_NONZERO_WEIGHTS){let f=(0,t.convertToTensor)(e,"labels","logLoss"),g=(0,t.convertToTensor)(l,"predictions","logLoss"),y=null;null!=c&&(y=(0,t.convertToTensor)(c,"weights","logLoss")),(0,r.assertShapesMatch)(f.shape,g.shape,"Error in logLoss: ");let b=(0,u.scalar)(1),T=(0,u.scalar)(h),v=(0,o.neg)((0,i.mul)(f,(0,n.log)((0,a.add)(g,T)))),N=(0,i.mul)((0,p.sub)(b,f),(0,n.log)((0,a.add)((0,p.sub)(b,g),T))),x=(0,p.sub)(v,N);return(0,d.computeWeightedLoss)(x,y,m)}});e.s(["logLoss",0,c])},435959,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(784367),n=e.i(566389),s=e.i(907467),i=e.i(802504);let o=(0,n.op)({meanSquaredError_:function(e,n,o,l=a.Reduction.SUM_BY_NONZERO_WEIGHTS){let u=(0,t.convertToTensor)(e,"labels","meanSquaredError"),p=(0,t.convertToTensor)(n,"predictions","meanSquaredError"),d=null;null!=o&&(d=(0,t.convertToTensor)(o,"weights","meanSquaredError")),(0,r.assertShapesMatch)(u.shape,p.shape,"Error in meanSquaredError: ");let c=(0,s.squaredDifference)(u,p);return(0,i.computeWeightedLoss)(c,d,l)}});e.s(["meanSquaredError",0,o])},65170,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(410616),n=e.i(536331),s=e.i(345175),i=e.i(297198),o=e.i(784367),l=e.i(449404),u=e.i(408604),p=e.i(566389),d=e.i(539333),c=e.i(919862),h=e.i(33457),m=e.i(802504);let f=(0,p.op)({sigmoidCrossEntropy_:function(e,p,f,g=0,y=o.Reduction.SUM_BY_NONZERO_WEIGHTS){var b;let T,v,N,x,S,E=(0,t.convertToTensor)(e,"multiClassLabels","sigmoidCrossEntropy"),w=(0,t.convertToTensor)(p,"logits","sigmoidCrossEntropy"),k=null;if(null!=f&&(k=(0,t.convertToTensor)(f,"weights","sigmoidCrossEntropy")),(0,r.assertShapesMatch)(E.shape,w.shape,"Error in sigmoidCrossEntropy: "),g>0){let e=(0,c.scalar)(g),t=(0,c.scalar)(1),r=(0,c.scalar)(.5);E=(0,n.add)((0,l.mul)(E,(0,h.sub)(t,e)),(0,l.mul)(r,e))}let I=(b=E,T=(0,t.convertToTensor)(b,"labels","sigmoidCrossEntropyWithLogits"),v=(0,t.convertToTensor)(w,"logits","sigmoidCrossEntropyWithLogits"),(0,r.assertShapesMatch)(T.shape,v.shape,"Error in sigmoidCrossEntropyWithLogits: "),N=(0,d.relu)(v),x=(0,l.mul)(v,T),S=(0,i.log1p)((0,s.exp)((0,u.neg)((0,a.abs)(v)))),(0,n.add)((0,h.sub)(N,x),S));return(0,m.computeWeightedLoss)(I,k,y)}});e.s(["sigmoidCrossEntropy",0,f])},976654,e=>{"use strict";var t=e.i(470353),r=e.i(900846),a=e.i(965960),n=e.i(129476);e.i(809827);var s=e.i(669487),i=e.i(747418),o=e.i(913269),l=e.i(566617),u=e.i(239110),p=e.i(597730),d=e.i(197293),c=e.i(800591),h=e.i(142311),m=e.i(637659),f=e.i(656139),g=e.i(16523),y=e.i(679754),b=e.i(842976),T=e.i(47046),v=e.i(213482),N=e.i(365506),x=e.i(625792),S=e.i(33701),E=e.i(554864),w=e.i(893857),k=e.i(355821),I=e.i(947064),A=e.i(802504),P=e.i(532193),M=e.i(148446),_=e.i(489762),V=e.i(285192),D=e.i(435959),$=e.i(65170),O=e.i(860623),R=e.i(240210),F=e.i(496378),C=e.i(536331),B=e.i(769664),L=e.i(494096),G=e.i(680837),z=e.i(345175),U=e.i(334401),q=e.i(784367),W=e.i(449404),K=e.i(408604),H=e.i(566389),j=e.i(940570),J=e.i(919862),Z=e.i(33457),X=e.i(101669);let Q=(0,H.op)({softmaxCrossEntropy_:function(e,t,r,a=0,n=q.Reduction.SUM_BY_NONZERO_WEIGHTS){let s=(0,R.convertToTensor)(e,"onehotLabels","softmaxCrossEntropy"),i=(0,R.convertToTensor)(t,"logits","softmaxCrossEntropy"),o=null;if(null!=r&&(o=(0,R.convertToTensor)(r,"weights","softmaxCrossEntropy")),(0,F.assertShapesMatch)(s.shape,i.shape,"Error in softmaxCrossEntropy: "),a>0){let e=(0,J.scalar)(a),t=(0,J.scalar)(1),r=(0,J.scalar)(s.shape[1]);s=(0,C.add)((0,W.mul)(s,(0,Z.sub)(t,e)),(0,G.div)(e,r))}let l=function(e,t,r=-1){if(-1===r&&(r=t.rank-1),r!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${r}`);return(0,O.customGrad)((e,t,a)=>{let n=(0,U.logSumExp)(t,[r],!0),s=(0,Z.sub)((0,L.cast)(t,"float32"),n);a([e,s]);let i=(0,K.neg)((0,W.mul)(s,e));return{value:(0,X.sum)(i,[r]),gradFunc:(e,t)=>{let[a,n]=t,s=(0,B.expandShapeToKeepDim)(e.shape,[r]);return[(0,W.mul)((0,j.reshape)(e,s),(0,Z.sub)((0,L.cast)(a,"float32"),(0,z.exp)(n))),(0,W.mul)((0,j.reshape)(e,s),(0,Z.sub)((0,z.exp)(n),(0,L.cast)(a,"float32")))]}}})(e,t)}(s,i);return(0,A.computeWeightedLoss)(l,o,n)}});var Y=e.i(27923),ee=e.i(592061);let et=(0,H.op)({sparseFillEmptyRows_:function(e,t,r,a){let n=(0,R.convertToTensor)(e,"indices","sparseFillEmptyRows","int32"),s=(0,R.convertToTensor)(t,"values","sparseFillEmptyRows"),i=(0,R.convertToTensor)(r,"denseShape","sparseFillEmptyRows","int32"),o=(0,R.convertToTensor)(a,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==n.rank)throw Error(`Indices should be Tensor2D but received shape
        ${n.shape}`);if(1!==s.rank)throw Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw Error(`Default value should be a scalar but received shape ${o.shape}`);let l=Y.ENGINE.runKernel(ee.SparseFillEmptyRows,{indices:n,values:s,denseShape:i,defaultValue:o});return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),er=(0,H.op)({sparseReshape_:function(e,t,r){let a=(0,R.convertToTensor)(e,"inputIndices","sparseReshape","int32"),n=(0,R.convertToTensor)(t,"inputShape","sparseReshape","int32"),s=(0,R.convertToTensor)(r,"newShape","sparseReshape","int32");if(2!==a.rank)throw Error(`Input indices should be Tensor2D but received shape
        ${a.shape}`);if(1!==n.rank)throw Error(`Input shape should be Tensor1D but received shape ${n.shape}`);if(1!==s.rank)throw Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i=Y.ENGINE.runKernel(ee.SparseReshape,{inputIndices:a,inputShape:n,newShape:s});return{outputIndices:i[0],outputShape:i[1]}}}),ea=(0,H.op)({sparseSegmentMean_:function(e,t,r){let a=(0,R.convertToTensor)(e,"data","sparseSegmentMean"),n=(0,R.convertToTensor)(t,"indices","sparseSegmentMean","int32"),s=(0,R.convertToTensor)(r,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==n.rank)throw Error(`Indices should be Tensor1D but received shape
          ${n.shape}`);if(1!==s.rank)throw Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);return Y.ENGINE.runKernel(ee.SparseSegmentMean,{data:a,indices:n,segmentIds:s})}}),en=(0,H.op)({sparseSegmentSum_:function(e,t,r){let a=(0,R.convertToTensor)(e,"data","sparseSegmentSum"),n=(0,R.convertToTensor)(t,"indices","sparseSegmentSum","int32"),s=(0,R.convertToTensor)(r,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==n.rank)throw Error(`Indices should be Tensor1D but received shape
         ${n.shape}`);if(1!==s.rank)throw Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);return Y.ENGINE.runKernel(ee.SparseSegmentSum,{data:a,indices:n,segmentIds:s})}}),es=(0,H.op)({stringNGrams_:function(e,t,r,a,n,s,i,o){let l=(0,R.convertToTensor)(e,"data","stringNGrams","string");if("string"!==l.dtype)throw Error("Data must be of datatype string");if(1!==l.shape.length)throw Error(`Data must be a vector, saw: ${l.shape}`);let u=(0,R.convertToTensor)(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw Error("Data splits must be of datatype int32");let p=Y.ENGINE.runKernel(ee.StringNGrams,{data:l,dataSplits:u},{separator:r,nGramWidths:a,leftPad:n,rightPad:s,padWidth:i,preserveShortSequences:o});return{nGrams:p[0],nGramsSplits:p[1]}}}),ei=(0,H.op)({stringSplit_:function(e,t,r=!0){let a=(0,R.convertToTensor)(e,"input","stringSplit","string"),n=(0,R.convertToTensor)(t,"delimiter","stringSplit","string");if(1!==a.rank)throw Error(`Input should be Tensor1D but received shape ${a.shape}`);if(0!==n.rank)throw Error(`Delimiter should be a scalar but received shape ${n.shape}`);let s=Y.ENGINE.runKernel(ee.StringSplit,{input:a,delimiter:n},{skipEmpty:r});return{indices:s[0],values:s[1],shape:s[2]}}}),eo=(0,H.op)({stringToHashBucketFast_:function(e,t){let r=(0,R.convertToTensor)(e,"input","stringToHashBucketFast","string");if(t<=0)throw Error("Number of buckets must be at least 1");return Y.ENGINE.runKernel(ee.StringToHashBucketFast,{input:r},{numBuckets:t})}}),el=(0,H.op)({staticRegexReplace_:function(e,t,r,a=!0){let n=(0,R.convertToTensor)(e,"input","staticRegexReplace","string");return Y.ENGINE.runKernel(ee.StaticRegexReplace,{x:n},{pattern:t,rewrite:r,replaceGlobal:a})}}),eu={fft:r.fft,ifft:a.ifft,rfft:t.rfft,irfft:n.irfft},ep={hammingWindow:s.hammingWindow,hannWindow:i.hannWindow,frame:o.frame,stft:l.stft},ed={flipLeftRight:p.flipLeftRight,grayscaleToRGB:d.grayscaleToRGB,resizeNearestNeighbor:N.resizeNearestNeighbor,resizeBilinear:v.resizeBilinear,rgbToGrayscale:c.rgbToGrayscale,rotateWithOffset:h.rotateWithOffset,cropAndResize:u.cropAndResize,nonMaxSuppression:m.nonMaxSuppression,nonMaxSuppressionAsync:f.nonMaxSuppressionAsync,nonMaxSuppressionWithScore:g.nonMaxSuppressionWithScore,nonMaxSuppressionWithScoreAsync:y.nonMaxSuppressionWithScoreAsync,nonMaxSuppressionPadded:b.nonMaxSuppressionPadded,nonMaxSuppressionPaddedAsync:T.nonMaxSuppressionPaddedAsync,threshold:x.threshold,transform:S.transform},ec={bandPart:E.bandPart,gramSchmidt:w.gramSchmidt,qr:k.qr},eh={absoluteDifference:I.absoluteDifference,computeWeightedLoss:A.computeWeightedLoss,cosineDistance:P.cosineDistance,hingeLoss:M.hingeLoss,huberLoss:_.huberLoss,logLoss:V.logLoss,meanSquaredError:D.meanSquaredError,sigmoidCrossEntropy:$.sigmoidCrossEntropy,softmaxCrossEntropy:Q},em={sparseFillEmptyRows:et,sparseReshape:er,sparseSegmentMean:ea,sparseSegmentSum:en},ef={stringNGrams:es,stringSplit:ei,stringToHashBucketFast:eo,staticRegexReplace:el};e.s(["image",()=>ed,"linalg",()=>ec,"losses",()=>eh,"signal",()=>ep,"sparse",()=>em,"spectral",()=>eu,"string",()=>ef],976654)},800308,(e,t,r)=>{!function(t,r,a){function n(e){var t,r=this,a=(t=0xefc8249d,function(e){e=String(e);for(var r=0;r<e.length;r++){var a=.02519603282416938*(t+=e.charCodeAt(r));t=a>>>0,a-=t,a*=t,t=a>>>0,a-=t,t+=0x100000000*a}return(t>>>0)*23283064365386963e-26});r.next=function(){var e=2091639*r.s0+23283064365386963e-26*r.c;return r.s0=r.s1,r.s1=r.s2,r.s2=e-(r.c=0|e)},r.c=1,r.s0=a(" "),r.s1=a(" "),r.s2=a(" "),r.s0-=a(e),r.s0<0&&(r.s0+=1),r.s1-=a(e),r.s1<0&&(r.s1+=1),r.s2-=a(e),r.s2<0&&(r.s2+=1)}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function i(e,t){var r=new n(e),a=t&&t.state,i=r.next;return i.int32=function(){return 0x100000000*r.next()|0},i.double=function(){return i()+(2097152*i()|0)*11102230246251565e-32},i.quick=i,a&&("object"==typeof a&&s(a,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(a&&a.amd)e.r,void 0!==i&&e.v(i);else this.alea=i}(e.e,t,"function"==typeof define&&define)},657362,(e,t,r)=>{!function(t,r,a){function n(e){var t=this,r="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:r+=e;for(var a=0;a<r.length+64;a++)t.x^=r.charCodeAt(a),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function i(e,t){var r=new n(e),a=t&&t.state,i=function(){return(r.next()>>>0)/0x100000000};return i.double=function(){do var e=((r.next()>>>11)+(r.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=r.next,i.quick=i,a&&("object"==typeof a&&s(a,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(a&&a.amd)e.r,void 0!==i&&e.v(i);else this.xor128=i}(e.e,t,"function"==typeof define&&define)},49206,(e,t,r)=>{!function(t,r,a){function n(e){var t=this,r="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:r+=e;for(var a=0;a<r.length+64;a++)t.x^=r.charCodeAt(a),a==r.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function i(e,t){var r=new n(e),a=t&&t.state,i=function(){return(r.next()>>>0)/0x100000000};return i.double=function(){do var e=((r.next()>>>11)+(r.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=r.next,i.quick=i,a&&("object"==typeof a&&s(a,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(a&&a.amd)e.r,void 0!==i&&e.v(i);else this.xorwow=i}(e.e,t,"function"==typeof define&&define)},19799,(e,t,r)=>{!function(t,r,a){function n(e){var t=this;t.next=function(){var e,r,a=t.x,n=t.i;return e=a[n],e^=e>>>7,r=e^e<<24^((e=a[n+1&7])^e>>>10)^((e=a[n+3&7])^e>>>3)^((e=a[n+4&7])^e<<7),e=a[n+7&7],e^=e<<13,r^=e^e<<9,a[n]=r,t.i=n+1&7,r};var r,a=e,n=[];if(a===(0|a))n[0]=a;else for(r=0,a=""+a;r<a.length;++r)n[7&r]=n[7&r]<<15^a.charCodeAt(r)+n[r+1&7]<<13;for(;n.length<8;)n.push(0);for(r=0;r<8&&0===n[r];++r);for(8==r?n[7]=-1:n[r],t.x=n,t.i=0,r=256;r>0;--r)t.next()}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function i(e,t){null==e&&(e=+new Date);var r=new n(e),a=t&&t.state,i=function(){return(r.next()>>>0)/0x100000000};return i.double=function(){do var e=((r.next()>>>11)+(r.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=r.next,i.quick=i,a&&(a.x&&s(a,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(a&&a.amd)e.r,void 0!==i&&e.v(i);else this.xorshift7=i}(e.e,t,"function"==typeof define&&define)},203207,(e,t,r)=>{!function(t,r,a){function n(e){var t=this;t.next=function(){var e,r,a=t.w,n=t.X,s=t.i;return t.w=a=a+0x61c88647|0,r=n[s+34&127],e=n[s=s+1&127],r^=r<<13,e^=e<<17,r^=r>>>15,e^=e>>>12,r=n[s]=r^e,t.i=s,r+(a^a>>>16)|0},!function(e,t){var r,a,n,s,i,o=[],l=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,l=Math.max(l,t.length)),n=0,s=-32;s<l;++s)t&&(a^=t.charCodeAt((s+32)%t.length)),0===s&&(i=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,s>=0&&(i=i+0x61c88647|0,n=0==(r=o[127&s]^=a+i)?n+1:0);for(n>=128&&(o[127&(t&&t.length||0)]=-1),n=127,s=512;s>0;--s)a=o[n+34&127],r=o[n=n+1&127],a^=a<<13,r^=r<<17,a^=a>>>15,r^=r>>>12,o[n]=a^r;e.w=i,e.X=o,e.i=n}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function i(e,t){null==e&&(e=+new Date);var r=new n(e),a=t&&t.state,i=function(){return(r.next()>>>0)/0x100000000};return i.double=function(){do var e=((r.next()>>>11)+(r.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=r.next,i.quick=i,a&&(a.X&&s(a,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(a&&a.amd)e.r,void 0!==i&&e.v(i);else this.xor4096=i}(e.e,t,"function"==typeof define&&define)},334885,(e,t,r)=>{!function(t,r,a){function n(e){var t=this,r="";t.next=function(){var e=t.b,r=t.c,a=t.d,n=t.a;return e=e<<25^e>>>7^r,r=r-a|0,a=a<<24^a>>>8^n,n=n-e|0,t.b=e=e<<20^e>>>12^r,t.c=r=r-a|0,t.d=a<<16^r>>>16^n,t.a=n-e|0},t.a=0,t.b=0,t.c=-0x61c88647,t.d=0x517cc1b7,e===Math.floor(e)?(t.a=e/0x100000000|0,t.b=0|e):r+=e;for(var a=0;a<r.length+20;a++)t.b^=r.charCodeAt(a),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function i(e,t){var r=new n(e),a=t&&t.state,i=function(){return(r.next()>>>0)/0x100000000};return i.double=function(){do var e=((r.next()>>>11)+(r.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=r.next,i.quick=i,a&&("object"==typeof a&&s(a,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(a&&a.amd)e.r,void 0!==i&&e.v(i);else this.tychei=i}(e.e,t,"function"==typeof define&&define)},513484,(e,t,r)=>{!function(r,a,n){var s,i="random",o=n.pow(256,6),l=n.pow(2,52),u=2*l;function p(e,t,p){var f=[],g=h(function e(t,r){var a,n=[],s=typeof t;if(r&&"object"==s)for(a in t)try{n.push(e(t[a],r-1))}catch(e){}return n.length?n:"string"==s?t:t+"\0"}((t=!0==t?{entropy:!0}:t||{}).entropy?[e,m(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(256):(e=new Uint8Array(256),(r.crypto||r.msCrypto).getRandomValues(e)),m(e)}catch(e){var t=r.navigator,n=t&&t.plugins;return[+new Date,r,n,r.screen,m(a)]}}():e,3),f),y=new d(f),b=function(){for(var e=y.g(6),t=o,r=0;e<l;)e=(e+r)*256,t*=256,r=y.g(1);for(;e>=u;)e/=2,t/=2,r>>>=1;return(e+r)/t};return b.int32=function(){return 0|y.g(4)},b.quick=function(){return y.g(4)/0x100000000},b.double=b,h(m(y.S),a),(t.pass||p||function(e,t,r,a){return(a&&(a.S&&c(a,y),e.state=function(){return c(y,{})}),r)?(n[i]=e,t):e})(b,g,"global"in t?t.global:this==n,t.state)}function d(e){var t,r=e.length,a=this,n=0,s=a.i=a.j=0,i=a.S=[];for(r||(e=[r++]);n<256;)i[n]=n++;for(n=0;n<256;n++)i[n]=i[s=255&s+e[n%r]+(t=i[n])],i[s]=t;(a.g=function(e){for(var t,r=0,n=a.i,s=a.j,i=a.S;e--;)t=i[n=255&n+1],r=256*r+i[255&(i[n]=i[s=255&s+t])+(i[s]=t)];return a.i=n,a.j=s,r})(256)}function c(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){for(var r,a=e+"",n=0;n<a.length;)t[255&n]=255&(r^=19*t[255&n])+a.charCodeAt(n++);return m(t)}function m(e){return String.fromCharCode.apply(0,e)}if(h(n.random(),a),t.exports){t.exports=p;try{s={}}catch(e){}}else if("function"==typeof define&&define.amd)e.r,void 0!==p&&e.v(p);else n["seed"+i]=p}("undefined"!=typeof self?self:e.e,[],Math)},347713,(e,t,r)=>{var a=e.r(800308),n=e.r(657362),s=e.r(49206),i=e.r(19799),o=e.r(203207),l=e.r(334885),u=e.r(513484);u.alea=a,u.xor128=n,u.xorwow=s,u.xorshift7=i,u.xor4096=o,u.tychei=l,t.exports=u},285871,14257,e=>{"use strict";var t=e.i(347713),r=e.i(27923),a=e.i(240210),n=e.i(496378),s=e.i(111613);function i(e,t,r){return null==r&&(r=o()),l(e,t,(e,t)=>c(e,t,r))}function o(){return 32===r.ENGINE.backend.floatPrecision()?.001:.1}function l(e,t,r){let i=!0;if(((0,s.isTypedArray)(e)||(0,s.isTypedArray)(t))&&(i=!1),(0,s.isTypedArray)(e)&&(0,s.isTypedArray)(t)&&(i=!0),i){let r=e.constructor.name,a=t.constructor.name;if(r!==a)throw Error(`Arrays are of different type. Actual: ${r}. Expected: ${a}`)}if(Array.isArray(e)&&Array.isArray(t)){let r=(0,a.inferShape)(e),s=(0,a.inferShape)(t);if(!(0,n.arraysEqual)(r,s))throw Error(`Arrays have different shapes. Actual: [${r}]. Expected: [${s}]`)}let o=(0,s.isTypedArray)(e)?e:(0,s.flatten)(e),l=(0,s.isTypedArray)(t)?t:(0,s.flatten)(t);if(o.length!==l.length)throw Error(`Arrays have different lengths actual: ${o.length} vs expected: ${l.length}.
Actual:   ${o}.
Expected: ${l}.`);for(let e=0;e<l.length;++e){let t=o[e],a=l[e];if(!r(t,a))throw Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${a}.
Actual:   ${o}.
Expected: ${l}.`)}"undefined"!=typeof expect&&expect().nothing()}function u(e,t){e().then(()=>t.fail(),()=>t()),"undefined"!=typeof expect&&expect().nothing()}function p(e,t){let r="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return(0,n.isString)(e)||(0,n.isString)(e[0])||(0,n.isString)(t)||(0,n.isString)(t[0])?l(e,r,(e,t)=>e==t):l(e,t,(e,t)=>c(e,t,0))}function d(e,t,r){if(null==r&&(r=o()),!c(e,t,r))throw Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function c(e,t,r){return!(isFinite(e)||isFinite(t))||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>r)}function h(e,t,r){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>r)throw Error(`Value out of range:${e[a]} low: ${t}, high: ${r}`)}function m(e,t){let r=new Float32Array(e),a=new Float32Array(t);if(r.length!==a.length)throw Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${r.length}`);for(let e=0;e<a.length;e++)if(r[e]!==a[e])throw Error(`Expected ArrayBuffer value at ${e} to be ${a[e]} but got ${r[e]} instead`)}function f(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(e=>{t.addEventListener("loadeddata",r=>e(t)),t.load()})}async function g(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}e.s(["TEST_EPSILON_FLOAT16",0,.1,"createVideoElement",()=>f,"encodeStrings",()=>function e(t){for(let r=0;r<t.length;r++){let a=t[r];Array.isArray(a)?e(a):t[r]=(0,s.encodeString)(a)}return t},"expectArrayBuffersEqual",()=>m,"expectArraysClose",()=>i,"expectArraysEqual",()=>p,"expectNumbersClose",()=>d,"expectPromiseToFail",()=>u,"expectValuesInRange",()=>h,"play",()=>g,"testEpsilon",()=>o],14257);class y{constructor(e,r,a,n,s){this.mean=e,this.stdDev=r,this.dtype=a,this.nextVal=NaN,this.truncated=n,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=s||Math.random();this.random=t.alea(i.toString())}nextValue(){let e,t;if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let r=!1;for(;!r;){let a,n,s;do s=(a=2*this.random()-1)*a+(n=2*this.random()-1)*n;while(s>=1||0===s)let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*i,t=this.mean+this.stdDev*n*i,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class b{constructor(e,r,a,n){this.alpha=e,this.beta=1/r,this.dtype=a;const s=n||Math.random();this.randu=t.alea(s.toString()),this.randn=new y(0,1,a,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,a,n,s;for(;;){do a=this.randn.nextValue(),s=1+this.c*a;while(s<=0)if(s*=s*s,t=1-.331*(e=a*a)*e,r=.5*e+this.d*(1-s+Math.log(s)),(n=this.randu())<t||Math.log(n)<r)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class T{constructor(e=0,r=1,a,n){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=r-e,this.dtype=a,null==n&&(n=Math.random()),"number"==typeof n&&(n=n.toString()),!this.canReturnFloat()&&this.range<=1)throw Error(`The difference between ${e} - ${r} <= 1 and dtype is not float`);this.random=t.alea(n)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}e.s(["MPRandGauss",()=>y,"RandGamma",()=>b,"UniformRandom",()=>T],285871)},844220,e=>{"use strict";var t=e.i(496378),r=e.i(792452),a=e.i(566389),n=e.i(285871);let s=(0,a.op)({randomUniform_:function(e,a=0,s=1,i="float32",o){(0,t.assertNonNegativeIntegerDimensions)(e);let l=(0,r.buffer)(e,i),u=new n.UniformRandom(a,s,null,o);for(let e=0;e<l.values.length;e++)l.values[e]=u.nextValue();return l.toTensor()}});e.s(["randomUniform",0,s])},944867,e=>{"use strict";var t=e.i(496378),r=e.i(792452),a=e.i(566389),n=e.i(285871);let s=(0,a.op)({truncatedNormal_:function(e,a=0,s=1,i,o){if((0,t.assertNonNegativeIntegerDimensions)(e),null!=i&&"bool"===i)throw Error("Unsupported data type $ { dtype }");let l=new n.MPRandGauss(a,s,i,!0,o),u=(0,r.buffer)(e,i);for(let e=0;e<u.values.length;e++)u.values[e]=l.nextValue();return u.toTensor()}});e.s(["truncatedNormal",0,s])},629999,261413,678041,40017,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(566389),n=e.i(606764);let s=(0,a.op)({slice1d_:function(e,a,s){let i=(0,t.convertToTensor)(e,"x","slice1d");return r.assert(1===i.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${i.rank} tensor`),(0,n.slice)(i,[a],[s])}});e.s(["slice1d",0,s],629999);let i=(0,a.op)({slice2d_:function(e,a,s){let i=(0,t.convertToTensor)(e,"x","slice2d");return r.assert(2===i.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${i.rank} tensor`),(0,n.slice)(i,a,s)}});e.s(["slice2d",0,i],261413);let o=(0,a.op)({slice3d_:function(e,a,s){let i=(0,t.convertToTensor)(e,"x","slice3d");return r.assert(3===i.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${i.rank} tensor`),(0,n.slice)(i,a,s)}});e.s(["slice3d",0,o],678041);let l=(0,a.op)({slice4d_:function(e,a,s){let i=(0,t.convertToTensor)(e,"x","slice4d");return r.assert(4===i.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${i.rank} tensor`),(0,n.slice)(i,a,s)}});e.s(["slice4d",0,l],40017)},542670,813546,86361,843008,e=>{"use strict";var t=e.i(655015),r=e.i(566389);let a=(0,r.op)({concat1d_:function(e){return(0,t.concat)(e,0)}});e.s(["concat1d",0,a],542670);let n=(0,r.op)({concat2d_:function(e,r){return(0,t.concat)(e,r)}});e.s(["concat2d",0,n],813546);let s=(0,r.op)({concat3d_:function(e,r){return(0,t.concat)(e,r)}});e.s(["concat3d",0,s],86361);let i=(0,r.op)({concat4d_:function(e,r){return(0,t.concat)(e,r)}});e.s(["concat4d",0,i],843008)},431100,e=>{"use strict";var t=e.i(496378),r=e.i(792452),a=e.i(566389),n=e.i(285871);let s=(0,a.op)({randomNormal_:function(e,a=0,s=1,i,o){if((0,t.assertNonNegativeIntegerDimensions)(e),null!=i&&"bool"===i)throw Error(`Unsupported data type ${i}`);let l=new n.MPRandGauss(a,s,i,!1,o),u=(0,r.buffer)(e,i);for(let e=0;e<u.values.length;e++)u.values[e]=l.nextValue();return u.toTensor()}});e.s(["randomNormal",0,s])},963496,e=>{"use strict";var t=e.i(527081),r=e.i(240210),a=e.i(496378),n=e.i(536331),s=e.i(680837),i=e.i(21637),o=e.i(449404),l=e.i(566389),u=e.i(844220);let p=(0,l.op)({dropout_:function(e,l,p,d){let c=(0,r.convertToTensor)(e,"x","dropout");if(a.assert("float32"===c.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${c.dtype} tensor instead.`),a.assert(l>=0&&l<1,()=>`rate must be a float in the range [0, 1), but got ${l}.`),0===l)return e instanceof t.Tensor?c.clone():c;let h=function(e,t){if(null==t)return e.shape.slice();if(a.arraysEqual(e.shape,t))return t;if(e.shape.length===t.length){let r=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?r.push(e.shape[a]):r.push(t[a]);return r}return t}(c,p),m=1-l,f=(0,s.div)((0,i.floor)((0,n.add)((0,u.randomUniform)(h,0,1,"float32",d),m)),m);return(0,o.mul)(c,f)}});e.s(["dropout",0,p],963496)},200649,e=>{"use strict";var t=e.i(27923);function r(e,a=!0,n,s){return t.ENGINE.makeVariable(e,a,n,s)}e.s(["variable",()=>r])},42330,e=>{"use strict";let t="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function r(){return new Promise(e=>t(()=>e()))}e.s(["nextFrame",()=>r])},889135,186451,406412,e=>{"use strict";e.i(329654),e.i(312757),e.i(35412);var t=e.i(177990),r=e.i(254577),a=e.i(804493),n=e.i(661758);function s(e){return new Promise(e=>setTimeout(e)).then(e)}class i{constructor(e){if(!(0,t.env)().getBool("IS_BROWSER"))throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(i.URL_SCHEME)&&(e=e.slice(i.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw Error("Browser downloads are not supported in this environment since `document` is not present");let t=n.CompositeArrayBuffer.join(e.weightData),a=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],n=(0,r.getModelJSONForModelArtifacts)(e,t),i=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),o=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await s(()=>o.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=a,await s(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:(0,r.getModelArtifactsInfoForJSON)(e)}}}}i.URL_SCHEME="downloads://";class o{constructor(e){if(null==e||e.length<1)throw Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let a=new FileReader;a.onload=a=>{let n=JSON.parse(a.target.result),s=n.modelTopology;null==s?t(Error(`modelTopology field is missing from file ${this.jsonFile.name}`)):null==n.weightsManifest?t(Error(`weightManifest field is missing from file ${this.jsonFile.name}`)):0===this.weightsFiles.length?e({modelTopology:s}):e((0,r.getModelArtifactsForJSON)(n,e=>this.loadWeights(e)))},a.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),a.readAsText(this.jsonFile)})}loadWeights(e){let t=[],r=[];for(let a of e)t.push(...a.weights),r.push(...a.paths);let a=this.checkManifestAndWeightFiles(e);return Promise.all(r.map(e=>this.loadWeightsFile(e,a[e]))).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((r,a)=>{let n=new FileReader;n.onload=e=>{r(e.target.result)},n.onerror=t=>a(`Failed to weights data from file of path '${e}'.`),n.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],a=this.weightsFiles.map(e=>(0,r.basename)(e.name)),n={};for(let s of e)s.paths.forEach(e=>{let s=(0,r.basename)(e);if(-1!==t.indexOf(s))throw Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===a.indexOf(s))throw Error(`Weight file with basename '${s}' is not provided.`);n[e]=this.weightsFiles[a.indexOf(s)]});if(t.length!==this.weightsFiles.length)throw Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return n}}function l(e){return new o(e)}a.IORouterRegistry.registerSaveRouter(e=>(0,t.env)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(i.URL_SCHEME)?function(e="model"){return new i(e)}(e.slice(i.URL_SCHEME.length)):null);var u=e.i(496378);function p(e,t,r,a){var n,s,i;n=e,(0,u.assert)(null!=n&&Array.isArray(n)&&n.length>0,()=>"promises must be a none empty array"),s=r=null==r?0:r,i=a=null==a?1:a,(0,u.assert)(s>=0&&s<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${s}`),(0,u.assert)(i>=0&&i<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${i}`),(0,u.assert)(i>=s,()=>`startFraction must be no more than endFraction, but got startFraction ${s} and endFraction ${i}`);let o=0;return Promise.all(e.map(n=>(n.then(n=>(t(r+ ++o/e.length*(a-r)),n)),n)))}var d=e.i(310897);async function c(e,r){null==r&&(r={});let a=null==r.fetchFunc?(0,t.env)().platform.fetch:r.fetchFunc,n=e.map(e=>a(e,r.requestInit,{isBinary:!0})),s=(null==r.onProgress?await Promise.all(n):await p(n,r.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==r.onProgress?await Promise.all(s):await p(s,r.onProgress,.5,1)}async function h(e,t="",r,a){return m(e=>c(e,{requestInit:a}))(e,t,r)}function m(e){return async(t,a="",s)=>{let i=t.map(()=>!1),o={},l=null!=s?s.map(()=>!1):[],p=[];if(t.forEach((e,t)=>{let r=0;e.weights.forEach(e=>{let a="quantization"in e?e.quantization.dtype:e.dtype,n=d.DTYPE_VALUE_SIZE_MAP[a]*u.sizeFromShape(e.shape),c=()=>{i[t]=!0,null==o[t]&&(o[t]=[]),o[t].push({manifestEntry:e,groupOffset:r,sizeBytes:n})};null!=s?s.forEach((t,r)=>{t===e.name&&(c(),l[r]=!0)}):c(),p.push(e.name),r+=n})}),!l.every(e=>e)){let e=s.filter((e,t)=>!l[t]);throw Error(`Could not find weights in manifest with names: ${e.join(", ")}. 
Manifest JSON has weights with names: ${p.join(", ")}.`)}let c=i.reduce((e,t,r)=>(t&&e.push(r),e),[]),h=[];c.forEach(e=>{t[e].paths.forEach(e=>{let t=a+(a.endsWith("/")?"":"/")+e;h.push(t)})});let m=await e(h),f={},g=0;return c.forEach(e=>{let a=t[e].paths.length,s=new n.CompositeArrayBuffer(m.slice(g,g+a));o[e].forEach(e=>{let t=s.slice(e.groupOffset,e.groupOffset+e.sizeBytes),a=(0,r.decodeWeights)(t,[e.manifestEntry]);for(let e in a)f[e]=a[e]}),g+=a}),f}}class f{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?((0,u.assert)("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=(0,t.env)().platform.fetch,(0,u.assert)(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&(0,u.assert)(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let a=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=(0,r.getModelJSONForModelArtifacts)(e,a);if(t.body.append("model.json",new Blob([JSON.stringify(s)],{type:"application/json"}),"model.json"),null!=e.weightData){let r=n.CompositeArrayBuffer.join(e.weightData);t.body.append("model.weights.bin",new Blob([r],{type:"application/octet-stream"}),"model.weights.bin")}let i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:(0,r.getModelArtifactsInfoForJSON)(e),responses:[i]};throw Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",Error(e)}let r=e.modelTopology,a=e.weightsManifest;if(null==r&&null==a)throw Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return(0,r.getModelArtifactsForJSON)(e,e=>this.loadWeights(e))}async loadStream(){let e=await this.loadModelJSON(),a=await this.getWeightUrls(e.weightsManifest),n=(0,r.getWeightSpecs)(e.weightsManifest),s=()=>{var e,r;let n,s,i;return s=null==(e=this.loadOptions).fetchFunc?(0,t.env)().platform.fetch:e.fetchFunc,i=0,null==(r=e.onProgress)||r.call(e,0),new ReadableStream({pull:async t=>{for(var r;i<a.length;){n||(n=(await s(a[i],e.requestInit,{isBinary:!0})).body.getReader());let{done:o,value:l}=await n.read();if(o){i++,n=void 0,null==(r=e.onProgress)||r.call(e,i/a.length);continue}t.enqueue(l);return}t.close()}})};return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:s})}async getWeightUrls(e){var t;let r,a,[n,s]=(r=(t=Array.isArray(this.path)?this.path[1]:this.path).lastIndexOf("/"),a=t.lastIndexOf("?"),[t.substring(0,r)+"/",a>r?t.substring(a):""]),i=this.weightPathPrefix||n,o=[],l=[];for(let t of e)for(let e of t.paths)null!=this.weightUrlConverter?l.push(this.weightUrlConverter(e)):o.push(i+e+s);return this.weightUrlConverter&&o.push(...await Promise.all(l)),o}async loadWeights(e){let t=await this.getWeightUrls(e);return[(0,r.getWeightSpecs)(e),await c(t,this.loadOptions)]}}function g(e){return null!=e.match(f.URL_SCHEME_REGEX)}f.URL_SCHEME_REGEX=/^https?:\/\//;let y=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc));else if(Array.isArray(e)?e.every(e=>g(e)):g(e))return b(e,t);return null};function b(e,t){return new f(e,t)}function T(e,t){return b(e,t)}a.IORouterRegistry.registerSaveRouter(y),a.IORouterRegistry.registerLoadRouter(y);class v{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class N{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class x{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function S(e,t,r,a){let n=arguments;return new x(E(...n))}function E(e,t,r,a){return 1!=arguments.length?(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new v({modelTopology:e,weightSpecs:t,weightData:r,trainingConfig:a})):null!=e.modelTopology||null!=e.weightSpecs?new v(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new v({modelTopology:e}))}function w(e){return new N(e)}function k(e){return new N(e)}var I=e.i(63340);e.s([],186451),e.i(186451),e.s(["CompositeArrayBuffer",()=>n.CompositeArrayBuffer,"browserFiles",()=>l,"browserHTTPRequest",()=>T,"concatenateArrayBuffers",()=>r.concatenateArrayBuffers,"copyModel",()=>I.copyModel,"decodeWeights",()=>r.decodeWeights,"decodeWeightsStream",()=>r.decodeWeightsStream,"encodeWeights",()=>r.encodeWeights,"fromMemory",()=>S,"fromMemorySync",()=>E,"getLoadHandlers",()=>a.getLoadHandlers,"getModelArtifactsForJSON",()=>r.getModelArtifactsForJSON,"getModelArtifactsForJSONSync",()=>r.getModelArtifactsForJSONSync,"getModelArtifactsInfoForJSON",()=>r.getModelArtifactsInfoForJSON,"getSaveHandlers",()=>a.getSaveHandlers,"getWeightSpecs",()=>r.getWeightSpecs,"http",()=>b,"isHTTPScheme",()=>g,"listModels",()=>I.listModels,"loadWeights",()=>h,"moveModel",()=>I.moveModel,"registerLoadRouter",()=>a.registerLoadRouter,"registerSaveRouter",()=>a.registerSaveRouter,"removeModel",()=>I.removeModel,"weightsLoaderFactory",()=>m,"withSaveHandler",()=>w,"withSaveHandlerSync",()=>k],406412);var A=e.i(406412);e.s(["io",0,A],889135)},674519,861720,e=>{"use strict";var t=e.i(548863),r=e.i(461215),a=e.i(370811),n=e.i(998029),s=e.i(889306),i=e.i(85824),o=e.i(953734);class l{static sgd(e){return new o.SGDOptimizer(e)}static momentum(e,t,r=!1){return new s.MomentumOptimizer(e,t,r)}static rmsprop(e,t=.9,r=0,a=null,n=!1){return new i.RMSPropOptimizer(e,t,r,a,n)}static adam(e=.001,t=.9,r=.999,n=null){return new a.AdamOptimizer(e,t,r,n)}static adadelta(e=.001,r=.95,a=null){return new t.AdadeltaOptimizer(e,r,a)}static adamax(e=.002,t=.9,r=.999,a=null,s=0){return new n.AdamaxOptimizer(e,t,r,a,s)}static adagrad(e,t=.1){return new r.AdagradOptimizer(e,t)}}e.s(["OptimizerConstructors",()=>l],861720),e.s(["train",0,l],674519)},385846,e=>{"use strict";var t=e.i(240210),r=e.i(107235);let a=(0,e.i(566389).op)({conv3dTranspose_:function(e,a,n,s,i){let o=(0,t.convertToTensor)(e,"x","conv3dTranspose"),l=(0,t.convertToTensor)(a,"filter","conv3dTranspose");return(0,r.conv3DBackpropInput)(n,o,l,s,i)}});e.s(["conv3dTranspose",0,a])},127063,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(870360),i=e.i(566389),o=e.i(940570);let l=(0,i.op)({conv3d_:function(e,i,l,u,p="NDHWC",d=[1,1,1]){let c=(0,a.convertToTensor)(e,"x","conv3d"),h=(0,a.convertToTensor)(i,"filter","conv3d"),m=c,f=!1;4===c.rank&&(f=!0,m=(0,o.reshape)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),n.assert(5===m.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${m.rank}.`),n.assert(5===h.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${h.rank}.`),n.assert(m.shape[4]===h.shape[3],()=>`Error in conv3d: depth of input (${m.shape[4]}) must match input depth for filter ${h.shape[3]}.`),n.assert((0,s.eitherStridesOrDilationsAreOne)(l,d),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${l} and dilations '${d}'`),n.assert("NDHWC"===p,()=>`Error in conv3d: got dataFormat of ${p} but only NDHWC is currently supported.`),n.assert((0,s.stridesOrDilationsArePositive)(d),()=>"Error in conv3D: Dilated rates should be larger than 0."),n.assert((0,s.stridesOrDilationsArePositive)(l),()=>"Error in conv3D: Strides should be larger than 0.");let g={x:m,filter:h},y=t.ENGINE.runKernel(r.Conv3D,g,{strides:l,pad:u,dataFormat:p,dilations:d});return f?(0,o.reshape)(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}});e.s(["conv3d",0,l])},762452,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(394503);let n=(0,e.i(566389).op)({batchNorm4d_:function(e,n,s,i,o,l){let u,p,d=(0,t.convertToTensor)(e,"x","batchNorm"),c=(0,t.convertToTensor)(n,"mean","batchNorm"),h=(0,t.convertToTensor)(s,"variance","batchNorm");return null!=o&&(u=(0,t.convertToTensor)(o,"scale","batchNorm")),null!=i&&(p=(0,t.convertToTensor)(i,"offset","batchNorm")),r.assert(4===d.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${d.rank}.`),r.assert(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${c.rank}.`),r.assert(4===h.rank||1===h.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${h.rank}.`),null!=u&&r.assert(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=p&&r.assert(4===p.rank||1===p.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),(0,a.batchNorm)(d,c,h,p,u,l)}});e.s(["batchNorm4d",0,n])},239197,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(394503);let n=(0,e.i(566389).op)({batchNorm3d_:function(e,n,s,i,o,l){let u,p,d=(0,t.convertToTensor)(e,"x","batchNorm"),c=(0,t.convertToTensor)(n,"mean","batchNorm"),h=(0,t.convertToTensor)(s,"variance","batchNorm");return null!=o&&(u=(0,t.convertToTensor)(o,"scale","batchNorm")),null!=i&&(p=(0,t.convertToTensor)(i,"offset","batchNorm")),r.assert(3===d.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${d.rank}.`),r.assert(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${c.rank}.`),r.assert(3===h.rank||1===h.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${h.rank}.`),null!=u&&r.assert(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=p&&r.assert(3===p.rank||1===p.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),(0,a.batchNorm)(d,c,h,p,u,l)}});e.s(["batchNorm3d",0,n])},147311,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(394503);let n=(0,e.i(566389).op)({batchNorm2d_:function(e,n,s,i,o,l){let u,p,d=(0,t.convertToTensor)(e,"x","batchNorm"),c=(0,t.convertToTensor)(n,"mean","batchNorm"),h=(0,t.convertToTensor)(s,"variance","batchNorm");return null!=o&&(u=(0,t.convertToTensor)(o,"scale","batchNorm")),null!=i&&(p=(0,t.convertToTensor)(i,"offset","batchNorm")),r.assert(2===d.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${d.rank}.`),r.assert(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${c.rank}.`),r.assert(2===h.rank||1===h.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${h.rank}.`),null!=u&&r.assert(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=p&&r.assert(2===p.rank||1===p.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),(0,a.batchNorm)(d,c,h,p,u,l)}});e.s(["batchNorm2d",0,n])},876852,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(769664),n=e.i(494096),s=e.i(155217),i=e.i(566389),o=e.i(940570),l=e.i(240774),u=e.i(33457);let p=(0,i.op)({moments_:function(e,i=null,p=!1){e=(0,t.convertToTensor)(e,"x","moments");let d=(0,r.parseAxisParam)(i,e.shape),c=(0,s.mean)(e,d,p),h=c.shape;p||(h=(0,a.expandShapeToKeepDim)(c.shape,d));let m=(0,l.square)((0,u.sub)((0,n.cast)(e,"float32"),(0,o.reshape)(c,h)));return{mean:c,variance:(0,s.mean)(m,d,p)}}});e.s(["moments",0,p])},217896,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(494096),i=e.i(870360),o=e.i(566389),l=e.i(940570);let u=(0,o.op)({avgPool3d_:function(e,o,u,p,d,c="NDHWC"){let h=(0,a.convertToTensor)(e,"x","avgPool3d","float32"),m=h,f=!1;4===h.rank&&(f=!0,m=(0,l.reshape)(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),n.assert(5===m.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${m.rank}.`),n.assert("NDHWC"===c,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${c}`),n.assert("number"==typeof u&&u>0||Array.isArray(u)&&u[0]>0&&u[1]>0&&u[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${u}'`),(0,i.checkPadOnDimRoundingMode)("avgPool3d",p,d);let g={x:m},y=t.ENGINE.runKernel(r.AvgPool3D,g,{filterSize:o,strides:u,pad:p,dimRoundingMode:d,dataFormat:c});return(y=(0,s.cast)(y,m.dtype),f)?(0,l.reshape)(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}});e.s(["avgPool3d",0,u])},264564,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(870360),i=e.i(566389),o=e.i(940570);let l=(0,i.op)({maxPool3d_:function(e,i=[1,1,1],l,u,p,d="NDHWC"){let c=(0,a.convertToTensor)(e,"x","maxPool3d"),h=c,m=!1;4===c.rank&&(m=!0,h=(0,o.reshape)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),n.assert(5===h.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${h.rank}.`),n.assert("NDHWC"===d,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${d}`),(0,s.checkPadOnDimRoundingMode)("maxPool3d",u,p);let f={x:h},g=t.ENGINE.runKernel(r.MaxPool3D,f,{filterSize:i,strides:l,pad:u,dimRoundingMode:p,dataFormat:d});return m?(0,o.reshape)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}});e.s(["maxPool3d",0,l])},570097,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({denseBincount_:function(e,s,i,o=!1){let l=(0,a.convertToTensor)(e,"x","denseBincount"),u=(0,a.convertToTensor)(s,"weights","denseBincount");return n.assert("int32"===l.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${l.dtype}`),n.assert(l.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${l.rank}.`),n.assert(i>=0,()=>`size must be non-negative, but got ${i}.`),n.assert(u.size===l.size||0===u.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${l.shape}, weights shape: ${u.shape}.`),t.ENGINE.runKernel(r.DenseBincount,{x:l,weights:u},{size:i,binaryOutput:o})}});e.s(["denseBincount",0,s])},600059,e=>{"use strict";e.i(704411),(0,e.i(177990).env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),e.s([])},284216,252900,251315,520445,947837,e=>{"use strict";var t,r,a,n,s,i=e.i(221168);e.i(704411);var o=e.i(177990);(t=n||(n={}))[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF",(a=(r=s||(s={})).CheckpointFormatVersion||(r.CheckpointFormatVersion={}))[a.LEGACY=0]="LEGACY",a[a.V1=1]="V1",a[a.V2=2]="V2";let l={};function u(e,t){l[e]={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t}}function p(e){return l[e]}function d(e){delete l[e]}e.s(["deregisterOp",()=>d,"getRegisteredOp",()=>p,"registerOp",()=>u],252900);var c=e.i(612930),h=e.i(449672);function m(e,t,r,a,n){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return f(t.inputNames[o],r,a,n);if("tensors"===s.type){let s=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter((e,t)=>{var r;return(null==(r=s[t])?void 0:r.op)!=="NoOp"}).map(e=>f(e,r,a,n))}let l=f(t.inputNames[o],r,a,n),u=l.dataSync();return"number"===s.type?u[0]:h.util.toNestedArray(l.shape,u)}let i=t.attrParams[e];return i&&i.value}function f(e,t,r,a){let[n,s]=T(e,r);if(null!=a){let e=a.getHashTableHandleByName(n);if(null!=e)return e}let i=r.currentContextIds.find(e=>!!t[b(n,e)]);return void 0!==i?t[b(n,i)][s]:void 0}function g(e,t,r){return t[b(e,r.currentContextId)]}function y(e,t){let[r,a,n]=T(e,t);return[b(r,t&&t.currentContextId),a,n]}function b(e,t){return t?`${e}-${t}`:e}function T(e,t){let r;if(""===e)return["",0,void 0];let a=null!=t&&null!=t.parseNodeNameCache;if(a){let r=t.parseNodeNameCache.get(e);if(null!=r)return r}let n=e.split(":");if(1===n.length)r=[e,0,void 0];else{let e=n[0],t=3===n.length?n[1]:void 0;r=[e,Number(n[n.length-1]),t]}return a&&t.parseNodeNameCache.set(e,r),r}function v(e,t,r){let a=m("pad",e,t,r);if("explicit"===a){a=m("explicitPaddings",e,t,r);let n=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)n[e][0]=a[2*e],n[e][1]=a[2*e+1];return n}return a}function N(e){return e.kept?e:(0,c.clone)(e)}e.s(["cloneTensor",()=>N,"getNodeNameAndIndex",()=>y,"getPadding",()=>v,"getParamValue",()=>m,"getTensor",()=>f,"getTensorsForCurrentContext",()=>g,"parseNodeName",()=>T],251315),e.s(["json",0,[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],728116);var x=e.i(728116);e.s(["json",0,[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],227455);var S=e.i(227455);e.s(["json",0,[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]],650612);var E=e.i(650612);e.s(["json",0,[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]],398155);var w=e.i(398155);e.s(["json",0,[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]],529418);var k=e.i(529418);e.s(["json",0,[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],718004);var I=e.i(718004);e.s(["json",0,[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]],247963);var A=e.i(247963);e.s(["json",0,[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]],372683);var P=e.i(372683);e.s(["json",0,[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]],701190);var M=e.i(701190);e.s(["json",0,[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]],238065);var _=e.i(238065);e.s(["json",0,[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}]],481663);var V=e.i(481663);e.s(["json",0,[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}]],254572);var D=e.i(254572);e.s(["json",0,[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}]],799427);var $=e.i(799427);e.s(["json",0,[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]],931401);var O=e.i(931401);e.s(["json",0,[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]],610196);var R=e.i(610196);e.s(["json",0,[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]],246095);var F=e.i(246095);e.s(["json",0,[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]],931666);var C=e.i(931666);e.s(["json",0,[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]],792957);var B=e.i(792957);e.s(["json",0,[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]],746838);var L=e.i(746838);class G{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[x,S,E,w,k,I,A,P,M,_,V,D,$,O,R,F,C,B,L].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){let r=e.node,a=[],n=[],s=[],i=r.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?n.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e),{}),o=[],l=[],u={},p={};null!=t&&(u=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach(e=>{let t=i[e];t.inputNames.forEach((e,r)=>{let[a,,n]=y(e),s=i[a];if(null!=s.outputs){let e=s.outputs.indexOf(n);if(-1!==e){let n=`${a}:${e}`;t.inputNames[r]=n}}t.inputs.push(s),s.children.push(t)})}),0===Object.keys(p).length?d.forEach(e=>{let t=i[e];0===t.children.length&&l.push(t)}):Object.keys(p).forEach(e=>{let[t]=y(e),r=i[t];null!=r&&(r.signatureKey=p[e],l.push(r))}),Object.keys(u).length>0?Object.keys(u).forEach(e=>{let[t]=y(e),r=i[t];r&&(r.signatureKey=u[e],o.push(r))}):o=a;let c={};null!=e.library&&null!=e.library.function&&(c=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));let h={nodes:i,inputs:o,outputs:l,weights:n,placeholders:a,signature:t,functions:c};return s.length>0&&(h.initNodes=s),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){let t=l[e.op]||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(r.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(r.attrParams=t.attrs.reduce((t,r)=>{let a,n=r.type;switch(r.type){case"string":void 0===(a=U(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(a=U(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":void 0===(a=Y(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(a=Y(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":void 0===(a=W(e.attr,r.tfName,r.defaultValue||0))&&r.tfDeprecatedName&&(a=W(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":void 0===(a=Q(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(a=Q(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":void 0===(a=q(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(a=q(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":void 0===(a=et(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(a=et(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":void 0===(a=X(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(a=X(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":void 0===(a=ee(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(a=ee(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":void 0===(a=j(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(a=j(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":void 0===(a=J(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(a=J(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":void 0===(a=H(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(a=H(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return t[r.name]={value:a,type:n},t},{})),r}mapFunction(e){let t=e.nodeDef,r=[],a={};null!=t&&(a=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&r.push(e[t.name]),e),{}));let n=[],s=[];e.signature.inputArg.forEach(e=>{let[t]=y(e.name),r={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:K(e.type),type:"dtype"}},children:[]};r.signatureKey=e.name,n.push(r),a[t]=r}),Object.keys(a).forEach(e=>{let t=a[e];t.inputNames.forEach((e,r)=>{let[n,,s]=y(e),i=a[n];if(null!=i.outputs){let e=i.outputs.indexOf(s);if(-1!==e){let a=`${n}:${e}`;t.inputNames[r]=a}}t.inputs.push(i),i.children.push(t)})});let i=e.ret;e.signature.outputArg.forEach(e=>{let[t,r]=y(i[e.name]),n=a[t];null!=n&&(n.defaultOutput=r,s.push(n))});let o=this.mapArgsToSignature(e);return{nodes:a,inputs:n,outputs:s,weights:r,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return null!=t&&(r=t[r]),{name:r,dtype:e.type}}}function z(e,t){let r=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){let t=(0,o.env)().global;if(void 0!==t.atob)return t.atob(e);if(void 0!==i.Buffer)return new i.Buffer(e,"base64").toString();throw Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?r:r.toLowerCase()}function U(e,t,r,a=!1){let n=e[t];return null!=n?z(n.s,a):r}function q(e,t,r){let a=e[t];return a?a.b:r}function W(e,t,r){let a=e[t]||{},n=null!=a.i?a.i:null!=a.f?a.f:r;return"number"==typeof n?n:parseInt(n,10)}function K(e){switch("string"==typeof e&&(e=n[e]),e){case n.DT_FLOAT:case n.DT_HALF:return"float32";case n.DT_INT32:case n.DT_INT64:case n.DT_INT8:case n.DT_UINT8:return"int32";case n.DT_BOOL:return"bool";case n.DT_DOUBLE:return"float32";case n.DT_STRING:return"string";case n.DT_COMPLEX64:case n.DT_COMPLEX128:return"complex64";default:return null}}function H(e,t,r){let a=e[t];return a&&a.func?a.func.name:r}function j(e,t,r){let a=e[t];return a&&a.type?K(a.type):r}function J(e,t,r){let a=e[t];return a&&a.list&&a.list.type?a.list.type.map(e=>K(e)):r}function Z(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function X(e,t,r){let a=e[t];return a&&a.shape?Z(a.shape):r}function Q(e,t,r){let a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):r}function Y(e,t,r,a=!1){let n=e[t];return n&&n.list&&n.list.s?n.list.s.map(e=>z(e,a)):r}function ee(e,t,r){let a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(e=>Z(e)):r}function et(e,t,r){let a=e[t];return a&&a.list&&a.list.b?a.list.b:r}e.s(["OperationMapper",()=>G,"getBoolArrayParam",()=>et,"getBoolParam",()=>q,"getDtypeArrayParam",()=>J,"getDtypeParam",()=>j,"getNumberParam",()=>W,"getNumericArrayParam",()=>Q,"getStringArrayParam",()=>Y,"getStringParam",()=>U,"getTensorShapeArrayParam",()=>ee,"getTensorShapeParam",()=>X],284216);class er{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return f(e,this.tensorMap,this.context)}getAttr(e,t){let r=this.node.rawAttrs[e];if(null!=r.tensor)return f(e,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return W(this.node.rawAttrs,e,t);if(null!=r.s)return U(this.node.rawAttrs,e,t);if(null!=r.b)return q(this.node.rawAttrs,e,t);if(null!=r.shape)return X(this.node.rawAttrs,e,t);if(null!=r.type)return j(this.node.rawAttrs,e,t);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return Q(this.node.rawAttrs,e,t);if(null!=r.list.s)return Y(this.node.rawAttrs,e,t);if(null!=r.list.shape)return ee(this.node.rawAttrs,e,t);if(null!=r.list.b)return et(this.node.rawAttrs,e,t);if(null!=r.list.type)return J(this.node.rawAttrs,e,t)}return t}}e.s(["NodeValueImpl",()=>er],520445),e.s([],947837)},208468,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378);let s=(0,e.i(566389).op)({addN_:function(e){n.assert(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),n.assert(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let s=e.map((e,t)=>(0,a.convertToTensor)(e,`tensors${t}`,"addN")),i=s[0];return s.forEach(e=>{if(e.dtype!==i.dtype)throw Error("All tensors passed to tf.addN() must have the same dtype")}),s.forEach(e=>{if(!n.arraysEqual(e.shape,i.shape))throw Error("All tensors passed to tf.addN() must have the same shape")}),t.ENGINE.runKernel(r.AddN,s)}});e.s(["addN",0,s])},360061,e=>{"use strict";var t=e.i(240210),r=e.i(536331),a=e.i(655015),n=e.i(656040),s=e.i(449404),i=e.i(566389),o=e.i(846141),l=e.i(606764),u=e.i(199009);let p=(0,i.op)({basicLSTMCell_:function(e,i,p,d,c,h){let m=(0,t.convertToTensor)(e,"forgetBias","basicLSTMCell"),f=(0,t.convertToTensor)(i,"lstmKernel","basicLSTMCell"),g=(0,t.convertToTensor)(p,"lstmBias","basicLSTMCell"),y=(0,t.convertToTensor)(d,"data","basicLSTMCell"),b=(0,t.convertToTensor)(c,"c","basicLSTMCell"),T=(0,t.convertToTensor)(h,"h","basicLSTMCell"),v=(0,a.concat)([y,T],1),N=(0,n.matMul)(v,f),x=(0,r.add)(N,g),S=x.shape[0],E=x.shape[1]/4,w=[S,E],k=(0,l.slice)(x,[0,0],w),I=(0,l.slice)(x,[0,E],w),A=(0,l.slice)(x,[0,2*E],w),P=(0,l.slice)(x,[0,3*E],w),M=(0,r.add)((0,s.mul)((0,o.sigmoid)(k),(0,u.tanh)(I)),(0,s.mul)(b,(0,o.sigmoid)((0,r.add)(m,A)))),_=(0,s.mul)((0,u.tanh)(M),(0,o.sigmoid)(P));return[M,_]}});e.s(["basicLSTMCell",0,p])},533016,601312,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(566389);let i=(0,s.op)({bitwiseAnd_:function(e,s){let i=(0,a.convertToTensor)(e,"x","bitwiseAnd"),o=(0,a.convertToTensor)(s,"y","bitwiseAnd");if(!(0,n.arraysEqual)(i.shape,o.shape))throw Error(`BitwiseAnd: Tensors must have the same shape. x: ${i.shape}, y: ${o.shape}`);if("int32"!==i.dtype||"int32"!==o.dtype)throw Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${i.dtype} and type of y: ${o.dtype}`);return t.ENGINE.runKernel(r.BitwiseAnd,{a:i,b:o})}});e.s(["bitwiseAnd",0,i],533016);let o=(0,s.op)({broadcastArgs_:function(e,n){let s=(0,a.convertToTensor)(e,"s0","broadcastArgs","int32"),i=(0,a.convertToTensor)(n,"s1","broadcastArgs","int32");if(1!==s.rank)throw Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${s.rank}`);if(1!==i.rank)throw Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${i.rank}`);return t.ENGINE.runKernel(r.BroadcastArgs,{s0:s,s1:i})}});e.s(["broadcastArgs",0,o],601312)},378804,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({diag_:function(e){let n=(0,a.convertToTensor)(e,"x","diag");return t.ENGINE.runKernel(r.Diag,{x:n})}});e.s(["diag",0,n])},17074,e=>{"use strict";var t=e.i(240210),r=e.i(496378);let a=(0,e.i(566389).op)({ensureShape_:function(e,a){let n=(0,t.convertToTensor)(e,"x","ensureShape","string_or_numeric");if(!(0,r.arraysEqualWithNull)(n.shape,a))throw Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${a}`);return e}});e.s(["ensureShape",0,a])},371888,e=>{"use strict";var t=e.i(27923),r=e.i(592061);function a(e,a,n){if(n<=0)throw Error("The number of values should be positive.");return t.ENGINE.runKernel(r.LinSpace,{},{start:e,stop:a,num:n})}e.s(["linspace",()=>a])},404138,973272,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(496378),s=e.i(566389),i=e.i(940570);let o=(0,s.op)({searchSorted_:function(e,s,o="left"){let l=(0,a.convertToTensor)(e,"sortedSequence","searchSorted"),u=(0,a.convertToTensor)(s,"values","searchSorted"),p=l.shape[l.shape.length-1],d=u.shape[u.shape.length-1],c=(0,i.reshape)(l,[-1,p]),h=(0,i.reshape)(u,[-1,d]);if(c.rank<2)throw Error("Sorted input argument must be at least 2-dimensional");if(c.shape[0]!==h.shape[0])throw Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,n.sizeFromShape)(h.shape)>=0x80000000)throw Error("values tensor size must less than 2147483648");if(c.shape[1]>=0x80000000)throw Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${c.shape[1]}`);return t.ENGINE.runKernel(r.SearchSorted,{sortedSequence:c,values:h},{side:o})}});function l(e,t){return o(e,t,"left")}e.s(["searchSorted",0,o],973272),e.s(["lowerBound",()=>l],404138)},255401,754665,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210);let n=(0,e.i(566389).op)({maxPoolWithArgmax_:function(e,n,s,i,o=!1){let l=(0,a.convertToTensor)(e,"x","maxPoolWithArgmax"),u=t.ENGINE.runKernel(r.MaxPoolWithArgmax,{x:l},{filterSize:n,strides:s,pad:i,includeBatchInIndex:o});return{result:u[0],indexes:u[1]}}});e.s(["maxPoolWithArgmax",0,n],255401);var s=e.i(656040),i=e.i(434425),o=e.i(940570),l=e.i(527081),u=e.i(496378);function p(e,t,{indexing:r="xy"}={}){if("xy"!==r&&"ij"!==r)throw TypeError(`${r} is not a valid third argument to meshgrid`);if(void 0===e)return[];let n=(0,a.convertToTensor)(e,"x","meshgrid",e instanceof l.Tensor?e.dtype:"float32");if(void 0===t)return[n];let d=(0,a.convertToTensor)(t,"y","meshgrid",t instanceof l.Tensor?t.dtype:"float32"),c=(0,u.sizeFromShape)(n.shape),h=(0,u.sizeFromShape)(d.shape);return"xy"===r?(n=(0,o.reshape)(n,[1,-1]),d=(0,o.reshape)(d,[-1,1]),[(0,s.matMul)((0,i.ones)([h,1],n.dtype),n),(0,s.matMul)(d,(0,i.ones)([1,c],d.dtype))]):(n=(0,o.reshape)(n,[-1,1]),d=(0,o.reshape)(d,[1,-1]),[(0,s.matMul)(n,(0,i.ones)([1,h],n.dtype)),(0,s.matMul)((0,i.ones)([c,1],d.dtype),d)])}e.s(["meshgrid",()=>p],754665)},820538,774116,e=>{"use strict";var t=e.i(240210),r=e.i(566389);let a=(0,r.op)({multiRNNCell_:function(e,r,a,n){let s=(0,t.convertToTensor)(r,"data","multiRNNCell"),i=(0,t.convertToTensorArray)(a,"c","multiRNNCell"),o=(0,t.convertToTensorArray)(n,"h","multiRNNCell"),l=s,u=[];for(let t=0;t<e.length;t++){let r=e[t](l,i[t],o[t]);u.push(r[0]),u.push(r[1]),l=r[1]}let p=[],d=[];for(let e=0;e<u.length;e+=2)p.push(u[e]),d.push(u[e+1]);return[p,d]}});e.s(["multiRNNCell",0,a],820538);var n=e.i(27923),s=e.i(592061),i=e.i(940570);let o=(0,r.op)({multinomial_:function(e,r,a,o=!1){let l=(0,t.convertToTensor)(e,"logits","multinomial"),u=l.size,p=l.rank;if(u<2)throw Error(`Error in multinomial: you need at least 2 outcomes, but got ${u}.`);if(p>2)throw Error(`Rank of probabilities must be 1 or 2, but is ${p}`);a=a||Math.random();let d=1===p?(0,i.reshape)(l,[1,-1]):l,c={numSamples:r,seed:a,normalized:o},h=n.ENGINE.runKernel(s.Multinomial,{logits:d},c);return 1===p?(0,i.reshape)(h,[h.size]):h}});e.s(["multinomial",0,o],774116)},588581,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(656040),n=e.i(566389),s=e.i(940570);let i=(0,n.op)({outerProduct_:function(e,n){let i=(0,t.convertToTensor)(e,"v1","outerProduct"),o=(0,t.convertToTensor)(n,"v2","outerProduct");r.assert(1===i.rank&&1===o.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${i.rank} and ${o.rank}.`);let l=(0,s.reshape)(i,[-1,1]),u=(0,s.reshape)(o,[1,-1]);return(0,a.matMul)(l,u)}});e.s(["outerProduct",0,i])},740560,820829,593510,191938,e=>{"use strict";var t=e.i(496378),r=e.i(566389),a=e.i(661193);let n=(0,r.op)({pad1d_:function(e,r,n=0){return(0,t.assert)(2===r.length,()=>"Invalid number of paddings. Must be length of 2."),(0,a.pad)(e,[r],n)}});e.s(["pad1d",0,n],740560);let s=(0,r.op)({pad2d_:function(e,r,n=0){return(0,t.assert)(2===r.length&&2===r[0].length&&2===r[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,a.pad)(e,r,n)}});e.s(["pad2d",0,s],820829);let i=(0,r.op)({pad3d_:function(e,r,n=0){return(0,t.assert)(3===r.length&&2===r[0].length&&2===r[1].length&&2===r[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,a.pad)(e,r,n)}});e.s(["pad3d",0,i],593510);let o=(0,r.op)({pad4d_:function(e,r,n=0){return(0,t.assert)(4===r.length&&2===r[0].length&&2===r[1].length&&2===r[2].length&&2===r[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,a.pad)(e,r,n)}});e.s(["pad4d",0,o],191938)},712397,878638,881234,850273,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389);let s=(0,n.op)({raggedGather_:function(e,n,s,i){let o=e.map((e,t)=>(0,a.convertToTensor)(e,`tensors${t}`,"raggedGather","int32")),l=(0,a.convertToTensor)(n,"paramsDenseValues","raggedGather"),u=(0,a.convertToTensor)(s,"indices","raggedGather","int32"),p=t.ENGINE.runKernel(r.RaggedGather,{paramsNestedSplits:o,paramsDenseValues:l,indices:u},{outputRaggedRank:i});return{outputNestedSplits:p.slice(0,p.length-1),outputDenseValues:p[p.length-1]}}});e.s(["raggedGather",0,s],712397);let i=(0,n.op)({raggedRange_:function(e,n,s){let i=(0,a.convertToTensor)(e,"starts","raggedRange"),o=(0,a.convertToTensor)(n,"limits","raggedRange",i.dtype),l=(0,a.convertToTensor)(s,"deltas","raggedRange",i.dtype),u=t.ENGINE.runKernel(r.RaggedRange,{starts:i,limits:o,deltas:l});return{rtNestedSplits:u[0],rtDenseValues:u[1]}}});e.s(["raggedRange",0,i],878638);let o=(0,n.op)({raggedTensorToTensor_:function(e,n,s,i,o){let l=(0,a.convertToTensor)(e,"shape","raggedTensorToTensor","int32"),u=(0,a.convertToTensor)(n,"values","raggedTensorToTensor"),p=(0,a.convertToTensor)(s,"defaultValue","raggedTensorToTensor",u.dtype),d=i.map((e,t)=>(0,a.convertToTensor)(e,`tensors${t}`,"raggedTensorToTensor","int32"));return t.ENGINE.runKernel(r.RaggedTensorToTensor,{shape:l,values:u,defaultValue:p,rowPartitionTensors:d},{rowPartitionTypes:o})}});e.s(["raggedTensorToTensor",0,o],881234);var l=e.i(496378);let u=(0,n.op)({rand_:function(e,r,a){(0,l.assertNonNegativeIntegerDimensions)(e);let n=(0,l.sizeFromShape)(e),s=null;if(null==a||"float32"===a)s=new Float32Array(n);else if("int32"===a)s=new Int32Array(n);else if("bool"===a)s=new Uint8Array(n);else throw Error(`Unknown data type ${a}`);for(let e=0;e<n;e++)s[e]=r();return t.ENGINE.makeTensor(s,e,a)}});e.s(["rand",0,u],850273)},200619,e=>{"use strict";var t=e.i(496378),r=e.i(792452),a=e.i(566389),n=e.i(285871);let s=(0,a.op)({randomGamma_:function(e,a,s=1,i="float32",o){if((0,t.assertNonNegativeIntegerDimensions)(e),null==s&&(s=1),null==i&&(i="float32"),"float32"!==i&&"int32"!==i)throw Error(`Unsupported data type ${i}`);let l=new n.RandGamma(a,s,i,o),u=(0,r.buffer)(e,i);for(let e=0;e<u.values.length;e++)u.values[e]=l.nextValue();return u.toTensor()}});e.s(["randomGamma",0,s])},51270,e=>{"use strict";var t=e.i(566389),r=e.i(431100);let a=(0,t.op)({randomStandardNormal_:function(e,t,a){if(null!=t&&"bool"===t)throw Error(`Unsupported data type ${t}`);return(0,r.randomNormal)(e,0,1,t,a)}});e.s(["randomStandardNormal",0,a])},359254,e=>{"use strict";var t=e.i(566389),r=e.i(844220);let a=(0,t.op)({randomUniformInt_:function(e,t,a,n){return(0,r.randomUniform)(e,t,a,"int32",n)}});e.s(["randomUniformInt",0,a])},243822,146747,593355,985957,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(566389),n=e.i(185876);let s=(0,a.op)({reverse1d_:function(e){let a=(0,t.convertToTensor)(e,"x","reverse");return r.assert(1===a.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${a.rank}.`),(0,n.reverse)(a,0)}});e.s(["reverse1d",0,s],243822);let i=(0,a.op)({reverse2d_:function(e,a){let s=(0,t.convertToTensor)(e,"x","reverse");return r.assert(2===s.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${s.rank}.`),(0,n.reverse)(s,a)}});e.s(["reverse2d",0,i],146747);let o=(0,a.op)({reverse3d_:function(e,a){let s=(0,t.convertToTensor)(e,"x","reverse");return r.assert(3===s.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${s.rank}.`),(0,n.reverse)(s,a)}});e.s(["reverse3d",0,o],593355);let l=(0,a.op)({reverse4d_:function(e,a){let s=(0,t.convertToTensor)(e,"x","reverse");return r.assert(4===s.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${s.rank}.`),(0,n.reverse)(s,a)}});e.s(["reverse4d",0,l],985957)},465470,e=>{"use strict";var t=e.i(527081),r=e.i(240210),a=e.i(496378);async function n(e,n){let s=(0,r.convertToTensor)(e,"x","setdiff1d"),i=(0,r.convertToTensor)(n,"y","setdiff1d");a.assert(s.dtype===i.dtype,()=>`x and y should have the same dtype, but got x (${s.dtype}) and y (${i.dtype}).`),a.assert(1===s.rank,()=>`x should be 1D tensor, but got x (${s.shape}).`),a.assert(1===i.rank,()=>`y should be 1D tensor, but got y (${i.shape}).`);let o=await s.data(),l=new Set(await i.data()),u=0;for(let e=0;e<o.length;e++)!l.has(o[e])&&u++;let p=new t.TensorBuffer([u],s.dtype),d=new t.TensorBuffer([u],"int32");for(let e=0,t=0;e<o.length;e++)!l.has(o[e])&&(p.values[t]=o[e],d.values[t]=e,t++);return[p.toTensor(),d.toTensor()]}e.s(["setdiff1dAsync",0,n])},104802,941486,349913,83301,e=>{"use strict";var t=e.i(240210),r=e.i(496378),a=e.i(121930);function n(e,n,s){if((0,r.assertNonNull)(e),null!=n&&3!==n.length)throw Error("tensor3d() requires shape to have three numbers");let i=(0,t.inferShape)(e,s);if(3!==i.length&&1!==i.length)throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===i.length&&null==n)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,a.makeTensor)(e,n,i,s)}function s(e,n,s){if((0,r.assertNonNull)(e),null!=n&&4!==n.length)throw Error("tensor4d() requires shape to have four numbers");let i=(0,t.inferShape)(e,s);if(4!==i.length&&1!==i.length)throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===i.length&&null==n)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,a.makeTensor)(e,n,i,s)}function i(e,n,s){if((0,r.assertNonNull)(e),null!=n&&5!==n.length)throw Error("tensor5d() requires shape to have five numbers");let i=(0,t.inferShape)(e,s);if(5!==i.length&&1!==i.length)throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===i.length&&null==n)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,a.makeTensor)(e,n,i,s)}function o(e,n,s){if((0,r.assertNonNull)(e),null!=n&&6!==n.length)throw Error("tensor6d() requires shape to have six numbers");let i=(0,t.inferShape)(e,s);if(6!==i.length&&1!==i.length)throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===i.length&&null==n)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return n=n||i,(0,a.makeTensor)(e,n,i,s)}e.s(["tensor3d",()=>n],104802),e.s(["tensor4d",()=>s],941486),e.s(["tensor5d",()=>i],349913),e.s(["tensor6d",()=>o],83301)},552336,e=>{"use strict";var t=e.i(27923),r=e.i(592061),a=e.i(240210),n=e.i(566389),s=e.i(782826);let i=(0,n.op)({tensorScatterUpdate_:function(e,n,i){let o=(0,a.convertToTensor)(e,"tensor","tensorScatterupdate"),l=(0,a.convertToTensor)(n,"indices","tensorScatterupdate","int32"),u=(0,a.convertToTensor)(i,"updates","tensorScatterupdate");if(s.validateInput(u,l,o.shape),o.dtype!==u.dtype)throw Error(`tensor and updates must have the same dtype, instead they are ${o.dtype} and ${u.dtype}.`);return t.ENGINE.runKernel(r.TensorScatterUpdate,{tensor:o,indices:l,updates:u},{})}});e.s(["tensorScatterUpdate",0,i])},623288,e=>{"use strict";var t=e.i(973272);function r(e,r){return(0,t.searchSorted)(e,r,"right")}e.s(["upperBound",()=>r])},966508,147602,471942,501406,736947,359377,708841,e=>{"use strict";var t=e.i(792452);function r(e,r){let a=[];for(let e=0;e<r.length;e++)r[e]&&a.push(e);let n=(0,t.buffer)(e,"int32"),s=(0,t.buffer)([a.length,e.length],"int32");for(let t=0;t<a.length;t++){let r=n.indexToLoc(a[t]),i=t*e.length;s.values.set(r,i)}return s.toTensor()}e.s(["whereImpl",()=>r],147602);var a=e.i(240210);async function n(e){let t=(0,a.convertToTensor)(e,"condition","whereAsync","bool"),n=await t.data(),s=r(t.shape,n);return e!==t&&t.dispose(),s}e.s(["whereAsync",0,n],966508);var s=e.i(496378),i=e.i(81936),o=e.i(940570),l=e.i(836111);async function u(e,t,r){let u=(0,a.convertToTensor)(e,"tensor","boolMask"),p=(0,a.convertToTensor)(t,"mask","boolMask","bool"),d=null==r?0:r,c=p.rank,h=u.shape;s.assert(c>0,()=>"mask cannot be scalar"),s.assertShapesMatch(h.slice(d,d+c),p.shape,"mask's shape must match the first K dimensions of tensor's shape,");let m=1;for(let e=d;e<d+c;e++)m*=h[e];let f=h.slice(0,d).concat([m],h.slice(d+c)),g=(0,o.reshape)(u,f),y=(0,o.reshape)(p,[-1]),b=await n(y),T=(0,l.squeeze)(b,[1]),v=(0,i.gather)(g,T,d);return e!==u&&u.dispose(),t!==p&&p.dispose(),T.dispose(),g.dispose(),y.dispose(),b.dispose(),v}e.s(["booleanMaskAsync",0,u],471942);var p=e.i(744877),d=e.i(536331),c=e.i(680837),h=e.i(449404),m=e.i(566389),f=e.i(26194),g=e.i(919862),y=e.i(33457);let b=(0,m.op)({movingAverage_:function(e,t,r,n,i=!0){let o=(0,a.convertToTensor)(e,"v","movingAverage"),l=(0,a.convertToTensor)(t,"x","movingAverage"),u=(0,a.convertToTensor)(r,"decay","movingAverage");(0,p.assertTypesMatch)(o,l),s.assert(s.arraysEqual(o.shape,l.shape),()=>"Shape mismatch in v and x");let m=(0,g.scalar)(1),b=(0,y.sub)(m,u),T=(0,h.mul)((0,y.sub)(l,o),b);if(i){s.assert(null!=n,()=>"When using zeroDebias: true, step is required.");let e=(0,a.convertToTensor)(n,"step","movingAverage");T=(0,c.div)(T,(0,y.sub)(m,(0,f.pow)(u,e)))}return(0,d.add)(o,T)}});e.s(["movingAverage",0,b],501406);var T=e.i(27923),v=e.i(592061),N=e.i(782826);let x=(0,m.op)({scatterND_:function(e,t,r){(0,s.assertNonNegativeIntegerDimensions)(r);let n=(0,a.convertToTensor)(e,"indices","scatterND","int32"),i=(0,a.convertToTensor)(t,"updates","scatterND");return N.validateInput(i,n,r),T.ENGINE.runKernel(v.ScatterNd,{indices:n,updates:i},{shape:r})}});e.s(["scatterND",0,x],736947);let S=(0,m.op)({sparseToDense_:function(e,t,r,n=0){(0,s.assertNonNegativeIntegerDimensions)(r);let i=(0,a.convertToTensor)(e,"sparseIndices","sparseToDense","int32"),o=(0,a.convertToTensor)(t,"sparseValues","sparseToDense","string_or_numeric"),l=(0,a.convertToTensor)(n,"defaultValue","sparseToDense",o.dtype);if("int32"!==i.dtype)throw Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${i.dtype}.`);if(i.rank>2)throw Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${i.shape}.`);let u=i.rank>0?i.shape[0]:1,p=i.rank>1?i.shape[1]:1;if(r.length!==p)throw Error(`outputShape has incorrect number of elements:, ${r.length}, should be: ${p}.`);let d=o.size;if(0!==o.rank&&(1!==o.rank||d!==u))throw Error(`sparseValues has incorrect shape ${o.shape}, should be [] or [${u}]`);if(o.dtype!==l.dtype)throw Error("sparseValues.dtype must match defaultValues.dtype");return T.ENGINE.runKernel(v.SparseToDense,{sparseIndices:i,sparseValues:o,defaultValue:l},{outputShape:r})}});e.s(["sparseToDense",0,S],359377);let E=(0,m.op)({gatherND_:function(e,t){let r=(0,a.convertToTensor)(t,"indices","gatherND","int32"),n=(0,a.convertToTensor)(e,"x","gatherND","string_or_numeric");return T.ENGINE.runKernel(v.GatherNd,{params:n,indices:r})}});e.s(["gatherND",0,E],708841)},139515,787566,139397,837322,193347,e=>{"use strict";let t;e.i(600059),e.i(704411);var r=e.i(720606),a=e.i(889135),n=e.i(527081),s=e.i(449672),i=e.i(284216),o=e.i(177990),l=e.i(251315),u=e.i(520445),p=e.i(252900);e.i(947837);var d=e.i(976654),c=e.i(410616),h=e.i(873663),m=e.i(176885),f=e.i(536331),g=e.i(208468),y=e.i(941826),b=e.i(644551),T=e.i(394472),v=e.i(51106),N=e.i(764563),x=e.i(791124),S=e.i(846199),E=e.i(119947),w=e.i(300320),k=e.i(281991),I=e.i(217896),A=e.i(360061),P=e.i(657626),M=e.i(394503),_=e.i(147311),V=e.i(239197),D=e.i(762452),$=e.i(722097),O=e.i(533016),R=e.i(601312),F=e.i(566006),C=e.i(792452),B=e.i(494096),L=e.i(556422),G=e.i(582343),z=e.i(612930),U=e.i(994152),q=e.i(655015),W=e.i(542670),K=e.i(813546),H=e.i(86361),j=e.i(843008),J=e.i(894983),Z=e.i(673749),X=e.i(599829),Q=e.i(127063),Y=e.i(385846),ee=e.i(795894),et=e.i(777815),er=e.i(504785),ea=e.i(657311),en=e.i(570097),es=e.i(274619),ei=e.i(985730),eo=e.i(378804),el=e.i(805129),eu=e.i(680837),ep=e.i(928612),ed=e.i(607381),ec=e.i(725517),eh=e.i(746814),em=e.i(17074),ef=e.i(87432),eg=e.i(923153),ey=e.i(729932),eb=e.i(345175),eT=e.i(40827),ev=e.i(81705),eN=e.i(516954),ex=e.i(419886),eS=e.i(21637),eE=e.i(167131),ew=e.i(81936),ek=e.i(101123),eI=e.i(318814),eA=e.i(176598),eP=e.i(379973),eM=e.i(971805),e_=e.i(514149),eV=e.i(872606),eD=e.i(388566),e$=e.i(612700),eO=e.i(371888),eR=e.i(35109),eF=e.i(322459),eC=e.i(297198),eB=e.i(105258),eL=e.i(940181),eG=e.i(334401),ez=e.i(783171),eU=e.i(705680),eq=e.i(725759),eW=e.i(392326),eK=e.i(404138),eH=e.i(656040),ej=e.i(37051),eJ=e.i(168091),eZ=e.i(264564),eX=e.i(255401),eQ=e.i(638688),eY=e.i(155217),e0=e.i(754665),e1=e.i(551573),e2=e.i(600936),e3=e.i(564418),e6=e.i(152522),e4=e.i(876852),e5=e.i(449404),e9=e.i(820538),e7=e.i(774116),e8=e.i(408604),te=e.i(344658),tt=e.i(379778),tr=e.i(434425),ta=e.i(584525),tn=e.i(588581),ts=e.i(661193),ti=e.i(740560),to=e.i(820829),tl=e.i(593510),tu=e.i(191938),tp=e.i(871242),td=e.i(26194),tc=e.i(145018),th=e.i(879228),tm=e.i(345813),tf=e.i(712397),tg=e.i(878638),ty=e.i(881234),tb=e.i(850273),tT=e.i(200619),tv=e.i(431100),tN=e.i(51270),tx=e.i(844220),tS=e.i(359254),tE=e.i(528280),tw=e.i(404099),tk=e.i(283532),tI=e.i(539333),tA=e.i(98856),tP=e.i(940570),tM=e.i(185876),t_=e.i(243822),tV=e.i(146747),tD=e.i(593355),t$=e.i(985957),tO=e.i(751057),tR=e.i(90119),tF=e.i(919862),tC=e.i(671859),tB=e.i(25498),tL=e.i(465470),tG=e.i(846141),tz=e.i(153910),tU=e.i(85565),tq=e.i(367743),tW=e.i(606764),tK=e.i(629999),tH=e.i(261413),tj=e.i(678041),tJ=e.i(40017),tZ=e.i(197631),tX=e.i(922398),tQ=e.i(707019),tY=e.i(900846),t0=e.i(965960),t1=e.i(129476),t2=e.i(470353),t3=e.i(798670),t6=e.i(119509),t4=e.i(240774),t5=e.i(907467),t9=e.i(836111),t7=e.i(691832),t8=e.i(311709),re=e.i(241468),rt=e.i(33457),rr=e.i(101669),ra=e.i(59143),rn=e.i(199009),rs=e.i(861392),ri=e.i(260188),ro=e.i(973946),rl=e.i(104802),ru=e.i(941486),rp=e.i(349913),rd=e.i(83301),rc=e.i(552336),rh=e.i(551200),rm=e.i(210487),rf=e.i(944867),rg=e.i(41735),ry=e.i(419426),rb=e.i(295175),rT=e.i(623288),rv=e.i(200649),rN=e.i(379250),rx=e.i(966508),rS=e.i(394596),rE=e.i(990256),rw=e.i(471942),rk=e.i(604907),rI=e.i(683784),rA=e.i(501406),rP=e.i(736947),rM=e.i(973272),r_=e.i(359377),rV=e.i(708841),rD=e.i(963496),r$=e.i(512960),rO=e.i(240210),rR=e.i(496378);async function rF(e,t,r=1){let a=(0,rO.convertToTensor)(e,"predictions","inTopK"),n=(0,rO.convertToTensor)(t,"targets","inTopK");(0,rR.assert)(a.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`),(0,rR.assert)(a.rank-1===n.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${n.rank}`),(0,rR.assertShapesMatch)(a.shape.slice(0,a.shape.length-1),n.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=a.shape[a.shape.length-1];(0,rR.assert)(r>0&&r<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${r}`);let i=await a.data(),o=await n.data(),[l,u]=[i.length/s,s],p=(0,rR.getTypedArrayFromDType)("bool",l);for(let e=0;e<l;e++){let t=e*u,a=i.subarray(t,t+u),n=[];for(let e=0;e<a.length;e++)n.push({value:a[e],index:e});n.sort((e,t)=>t.value-e.value),p[e]=0;for(let t=0;t<r;t++)if(n[t].index===o[e]){p[e]=1;break}}return e!==a&&a.dispose(),t!==n&&n.dispose(),(0,rs.tensor)(p,n.shape,"bool")}e.s(["inTopKAsync",0,rF],229248),e.i(229248);var rC=e.i(566389),rB=e.i(809827);e.s(["OP_SCOPE_SUFFIX",()=>rC.OP_SCOPE_SUFFIX,"abs",()=>c.abs,"acos",()=>h.acos,"acosh",()=>m.acosh,"add",()=>f.add,"addN",()=>g.addN,"all",()=>y.all,"any",()=>b.any,"argMax",()=>T.argMax,"argMin",()=>v.argMin,"asin",()=>N.asin,"asinh",()=>x.asinh,"atan",()=>S.atan,"atan2",()=>E.atan2,"atanh",()=>w.atanh,"avgPool",()=>k.avgPool,"avgPool3d",()=>I.avgPool3d,"basicLSTMCell",()=>A.basicLSTMCell,"batchNorm",()=>M.batchNorm,"batchNorm2d",()=>_.batchNorm2d,"batchNorm3d",()=>V.batchNorm3d,"batchNorm4d",()=>D.batchNorm4d,"batchToSpaceND",()=>P.batchToSpaceND,"bincount",()=>$.bincount,"bitwiseAnd",()=>O.bitwiseAnd,"booleanMaskAsync",()=>rw.booleanMaskAsync,"broadcastArgs",()=>R.broadcastArgs,"broadcastTo",()=>F.broadcastTo,"buffer",()=>C.buffer,"cast",()=>B.cast,"ceil",()=>L.ceil,"clipByValue",()=>G.clipByValue,"clone",()=>z.clone,"complex",()=>U.complex,"concat",()=>q.concat,"concat1d",()=>W.concat1d,"concat2d",()=>K.concat2d,"concat3d",()=>H.concat3d,"concat4d",()=>j.concat4d,"conv1d",()=>J.conv1d,"conv2d",()=>Z.conv2d,"conv2dTranspose",()=>X.conv2dTranspose,"conv3d",()=>Q.conv3d,"conv3dTranspose",()=>Y.conv3dTranspose,"cos",()=>ee.cos,"cosh",()=>et.cosh,"cosineWindow",()=>r$.cosineWindow,"cumprod",()=>er.cumprod,"cumsum",()=>ea.cumsum,"denseBincount",()=>en.denseBincount,"depthToSpace",()=>es.depthToSpace,"depthwiseConv2d",()=>ei.depthwiseConv2d,"diag",()=>eo.diag,"dilation2d",()=>el.dilation2d,"div",()=>eu.div,"divNoNan",()=>ep.divNoNan,"dot",()=>ed.dot,"dropout",()=>rD.dropout,"einsum",()=>ec.einsum,"elu",()=>eh.elu,"enclosingPowerOfTwo",()=>r$.enclosingPowerOfTwo,"ensureShape",()=>em.ensureShape,"equal",()=>ef.equal,"erf",()=>eg.erf,"euclideanNorm",()=>ey.euclideanNorm,"exp",()=>eb.exp,"expandDims",()=>eT.expandDims,"expm1",()=>ev.expm1,"eye",()=>eN.eye,"fft",()=>tY.fft,"fill",()=>ex.fill,"floor",()=>eS.floor,"floorDiv",()=>eE.floorDiv,"fused",0,rB,"gather",()=>ew.gather,"gatherND",()=>rV.gatherND,"greater",()=>ek.greater,"greaterEqual",()=>eI.greaterEqual,"ifft",()=>t0.ifft,"imag",()=>eA.imag,"image",()=>d.image,"inTopKAsync",0,rF,"irfft",()=>t1.irfft,"isFinite",()=>eP.isFinite,"isInf",()=>eM.isInf,"isNaN",()=>e_.isNaN,"leakyRelu",()=>eV.leakyRelu,"less",()=>eD.less,"lessEqual",()=>e$.lessEqual,"linalg",()=>d.linalg,"linspace",()=>eO.linspace,"localResponseNormalization",()=>eR.localResponseNormalization,"log",()=>eF.log,"log1p",()=>eC.log1p,"logSigmoid",()=>eB.logSigmoid,"logSoftmax",()=>eL.logSoftmax,"logSumExp",()=>eG.logSumExp,"logicalAnd",()=>ez.logicalAnd,"logicalNot",()=>eU.logicalNot,"logicalOr",()=>eq.logicalOr,"logicalXor",()=>eW.logicalXor,"losses",()=>d.losses,"lowerBound",()=>eK.lowerBound,"matMul",()=>eH.matMul,"max",()=>ej.max,"maxPool",()=>eJ.maxPool,"maxPool3d",()=>eZ.maxPool3d,"maxPoolWithArgmax",()=>eX.maxPoolWithArgmax,"maximum",()=>eQ.maximum,"mean",()=>eY.mean,"meshgrid",()=>e0.meshgrid,"min",()=>e1.min,"minimum",()=>e2.minimum,"mirrorPad",()=>e3.mirrorPad,"mod",()=>e6.mod,"moments",()=>e4.moments,"movingAverage",()=>rA.movingAverage,"mul",()=>e5.mul,"multiRNNCell",()=>e9.multiRNNCell,"multinomial",()=>e7.multinomial,"neg",()=>e8.neg,"norm",()=>rI.norm,"notEqual",()=>te.notEqual,"oneHot",()=>tt.oneHot,"ones",()=>tr.ones,"onesLike",()=>ta.onesLike,"op",()=>rC.op,"outerProduct",()=>tn.outerProduct,"pad",()=>ts.pad,"pad1d",()=>ti.pad1d,"pad2d",()=>to.pad2d,"pad3d",()=>tl.pad3d,"pad4d",()=>tu.pad4d,"pool",()=>tp.pool,"pow",()=>td.pow,"prelu",()=>tc.prelu,"print",()=>th.print,"prod",()=>tm.prod,"raggedGather",()=>tf.raggedGather,"raggedRange",()=>tg.raggedRange,"raggedTensorToTensor",()=>ty.raggedTensorToTensor,"rand",()=>tb.rand,"randomGamma",()=>tT.randomGamma,"randomNormal",()=>tv.randomNormal,"randomStandardNormal",()=>tN.randomStandardNormal,"randomUniform",()=>tx.randomUniform,"randomUniformInt",()=>tS.randomUniformInt,"range",()=>tE.range,"real",()=>tw.real,"reciprocal",()=>tk.reciprocal,"relu",()=>tI.relu,"relu6",()=>tA.relu6,"reshape",()=>tP.reshape,"reverse",()=>tM.reverse,"reverse1d",()=>t_.reverse1d,"reverse2d",()=>tV.reverse2d,"reverse3d",()=>tD.reverse3d,"reverse4d",()=>t$.reverse4d,"rfft",()=>t2.rfft,"round",()=>tO.round,"rsqrt",()=>tR.rsqrt,"scalar",()=>tF.scalar,"scatterND",()=>rP.scatterND,"searchSorted",()=>rM.searchSorted,"selu",()=>tC.selu,"separableConv2d",()=>tB.separableConv2d,"setdiff1dAsync",()=>tL.setdiff1dAsync,"sigmoid",()=>tG.sigmoid,"sign",()=>tz.sign,"signal",()=>d.signal,"sin",()=>tU.sin,"sinh",()=>tq.sinh,"slice",()=>tW.slice,"slice1d",()=>tK.slice1d,"slice2d",()=>tH.slice2d,"slice3d",()=>tj.slice3d,"slice4d",()=>tJ.slice4d,"softmax",()=>tZ.softmax,"softplus",()=>tX.softplus,"spaceToBatchND",()=>tQ.spaceToBatchND,"sparse",()=>d.sparse,"sparseToDense",()=>r_.sparseToDense,"spectral",()=>d.spectral,"split",()=>t3.split,"sqrt",()=>t6.sqrt,"square",()=>t4.square,"squaredDifference",()=>t5.squaredDifference,"squeeze",()=>t9.squeeze,"stack",()=>t7.stack,"step",()=>t8.step,"stridedSlice",()=>re.stridedSlice,"string",()=>d.string,"sub",()=>rt.sub,"sum",()=>rr.sum,"tan",()=>ra.tan,"tanh",()=>rn.tanh,"tensor",()=>rs.tensor,"tensor1d",()=>ri.tensor1d,"tensor2d",()=>ro.tensor2d,"tensor3d",()=>rl.tensor3d,"tensor4d",()=>ru.tensor4d,"tensor5d",()=>rp.tensor5d,"tensor6d",()=>rd.tensor6d,"tensorScatterUpdate",()=>rc.tensorScatterUpdate,"tile",()=>rh.tile,"topk",()=>rm.topk,"transpose",()=>rk.transpose,"truncatedNormal",()=>rf.truncatedNormal,"unique",()=>rg.unique,"unsortedSegmentSum",()=>ry.unsortedSegmentSum,"unstack",()=>rb.unstack,"upperBound",()=>rT.upperBound,"variable",()=>rv.variable,"where",()=>rN.where,"whereAsync",()=>rx.whereAsync,"zeros",()=>rS.zeros,"zerosLike",()=>rE.zerosLike],787566),e.i(787566),e.s(["OP_SCOPE_SUFFIX",()=>rC.OP_SCOPE_SUFFIX,"abs",()=>c.abs,"acos",()=>h.acos,"acosh",()=>m.acosh,"add",()=>f.add,"addN",()=>g.addN,"all",()=>y.all,"any",()=>b.any,"argMax",()=>T.argMax,"argMin",()=>v.argMin,"asin",()=>N.asin,"asinh",()=>x.asinh,"atan",()=>S.atan,"atan2",()=>E.atan2,"atanh",()=>w.atanh,"avgPool",()=>k.avgPool,"avgPool3d",()=>I.avgPool3d,"basicLSTMCell",()=>A.basicLSTMCell,"batchNorm",()=>M.batchNorm,"batchNorm2d",()=>_.batchNorm2d,"batchNorm3d",()=>V.batchNorm3d,"batchNorm4d",()=>D.batchNorm4d,"batchToSpaceND",()=>P.batchToSpaceND,"bincount",()=>$.bincount,"bitwiseAnd",()=>O.bitwiseAnd,"booleanMaskAsync",()=>rw.booleanMaskAsync,"broadcastArgs",()=>R.broadcastArgs,"broadcastTo",()=>F.broadcastTo,"buffer",()=>C.buffer,"cast",()=>B.cast,"ceil",()=>L.ceil,"clipByValue",()=>G.clipByValue,"clone",()=>z.clone,"complex",()=>U.complex,"concat",()=>q.concat,"concat1d",()=>W.concat1d,"concat2d",()=>K.concat2d,"concat3d",()=>H.concat3d,"concat4d",()=>j.concat4d,"conv1d",()=>J.conv1d,"conv2d",()=>Z.conv2d,"conv2dTranspose",()=>X.conv2dTranspose,"conv3d",()=>Q.conv3d,"conv3dTranspose",()=>Y.conv3dTranspose,"cos",()=>ee.cos,"cosh",()=>et.cosh,"cosineWindow",()=>r$.cosineWindow,"cumprod",()=>er.cumprod,"cumsum",()=>ea.cumsum,"denseBincount",()=>en.denseBincount,"depthToSpace",()=>es.depthToSpace,"depthwiseConv2d",()=>ei.depthwiseConv2d,"diag",()=>eo.diag,"dilation2d",()=>el.dilation2d,"div",()=>eu.div,"divNoNan",()=>ep.divNoNan,"dot",()=>ed.dot,"dropout",()=>rD.dropout,"einsum",()=>ec.einsum,"elu",()=>eh.elu,"enclosingPowerOfTwo",()=>r$.enclosingPowerOfTwo,"ensureShape",()=>em.ensureShape,"equal",()=>ef.equal,"erf",()=>eg.erf,"euclideanNorm",()=>ey.euclideanNorm,"exp",()=>eb.exp,"expandDims",()=>eT.expandDims,"expm1",()=>ev.expm1,"eye",()=>eN.eye,"fft",()=>tY.fft,"fill",()=>ex.fill,"floor",()=>eS.floor,"floorDiv",()=>eE.floorDiv,"fused",()=>rB,"gather",()=>ew.gather,"gatherND",()=>rV.gatherND,"greater",()=>ek.greater,"greaterEqual",()=>eI.greaterEqual,"ifft",()=>t0.ifft,"imag",()=>eA.imag,"image",()=>d.image,"inTopKAsync",0,rF,"irfft",()=>t1.irfft,"isFinite",()=>eP.isFinite,"isInf",()=>eM.isInf,"isNaN",()=>e_.isNaN,"leakyRelu",()=>eV.leakyRelu,"less",()=>eD.less,"lessEqual",()=>e$.lessEqual,"linalg",()=>d.linalg,"linspace",()=>eO.linspace,"localResponseNormalization",()=>eR.localResponseNormalization,"log",()=>eF.log,"log1p",()=>eC.log1p,"logSigmoid",()=>eB.logSigmoid,"logSoftmax",()=>eL.logSoftmax,"logSumExp",()=>eG.logSumExp,"logicalAnd",()=>ez.logicalAnd,"logicalNot",()=>eU.logicalNot,"logicalOr",()=>eq.logicalOr,"logicalXor",()=>eW.logicalXor,"losses",()=>d.losses,"lowerBound",()=>eK.lowerBound,"matMul",()=>eH.matMul,"max",()=>ej.max,"maxPool",()=>eJ.maxPool,"maxPool3d",()=>eZ.maxPool3d,"maxPoolWithArgmax",()=>eX.maxPoolWithArgmax,"maximum",()=>eQ.maximum,"mean",()=>eY.mean,"meshgrid",()=>e0.meshgrid,"min",()=>e1.min,"minimum",()=>e2.minimum,"mirrorPad",()=>e3.mirrorPad,"mod",()=>e6.mod,"moments",()=>e4.moments,"movingAverage",()=>rA.movingAverage,"mul",()=>e5.mul,"multiRNNCell",()=>e9.multiRNNCell,"multinomial",()=>e7.multinomial,"neg",()=>e8.neg,"norm",()=>rI.norm,"notEqual",()=>te.notEqual,"oneHot",()=>tt.oneHot,"ones",()=>tr.ones,"onesLike",()=>ta.onesLike,"op",()=>rC.op,"outerProduct",()=>tn.outerProduct,"pad",()=>ts.pad,"pad1d",()=>ti.pad1d,"pad2d",()=>to.pad2d,"pad3d",()=>tl.pad3d,"pad4d",()=>tu.pad4d,"pool",()=>tp.pool,"pow",()=>td.pow,"prelu",()=>tc.prelu,"print",()=>th.print,"prod",()=>tm.prod,"raggedGather",()=>tf.raggedGather,"raggedRange",()=>tg.raggedRange,"raggedTensorToTensor",()=>ty.raggedTensorToTensor,"rand",()=>tb.rand,"randomGamma",()=>tT.randomGamma,"randomNormal",()=>tv.randomNormal,"randomStandardNormal",()=>tN.randomStandardNormal,"randomUniform",()=>tx.randomUniform,"randomUniformInt",()=>tS.randomUniformInt,"range",()=>tE.range,"real",()=>tw.real,"reciprocal",()=>tk.reciprocal,"relu",()=>tI.relu,"relu6",()=>tA.relu6,"reshape",()=>tP.reshape,"reverse",()=>tM.reverse,"reverse1d",()=>t_.reverse1d,"reverse2d",()=>tV.reverse2d,"reverse3d",()=>tD.reverse3d,"reverse4d",()=>t$.reverse4d,"rfft",()=>t2.rfft,"round",()=>tO.round,"rsqrt",()=>tR.rsqrt,"scalar",()=>tF.scalar,"scatterND",()=>rP.scatterND,"searchSorted",()=>rM.searchSorted,"selu",()=>tC.selu,"separableConv2d",()=>tB.separableConv2d,"setdiff1dAsync",()=>tL.setdiff1dAsync,"sigmoid",()=>tG.sigmoid,"sign",()=>tz.sign,"signal",()=>d.signal,"sin",()=>tU.sin,"sinh",()=>tq.sinh,"slice",()=>tW.slice,"slice1d",()=>tK.slice1d,"slice2d",()=>tH.slice2d,"slice3d",()=>tj.slice3d,"slice4d",()=>tJ.slice4d,"softmax",()=>tZ.softmax,"softplus",()=>tX.softplus,"spaceToBatchND",()=>tQ.spaceToBatchND,"sparse",()=>d.sparse,"sparseToDense",()=>r_.sparseToDense,"spectral",()=>d.spectral,"split",()=>t3.split,"sqrt",()=>t6.sqrt,"square",()=>t4.square,"squaredDifference",()=>t5.squaredDifference,"squeeze",()=>t9.squeeze,"stack",()=>t7.stack,"step",()=>t8.step,"stridedSlice",()=>re.stridedSlice,"string",()=>d.string,"sub",()=>rt.sub,"sum",()=>rr.sum,"tan",()=>ra.tan,"tanh",()=>rn.tanh,"tensor",()=>rs.tensor,"tensor1d",()=>ri.tensor1d,"tensor2d",()=>ro.tensor2d,"tensor3d",()=>rl.tensor3d,"tensor4d",()=>ru.tensor4d,"tensor5d",()=>rp.tensor5d,"tensor6d",()=>rd.tensor6d,"tensorScatterUpdate",()=>rc.tensorScatterUpdate,"tile",()=>rh.tile,"topk",()=>rm.topk,"transpose",()=>rk.transpose,"truncatedNormal",()=>rf.truncatedNormal,"unique",()=>rg.unique,"unsortedSegmentSum",()=>ry.unsortedSegmentSum,"unstack",()=>rb.unstack,"upperBound",()=>rT.upperBound,"variable",()=>rv.variable,"where",()=>rN.where,"whereAsync",()=>rx.whereAsync,"zeros",()=>rS.zeros,"zerosLike",()=>rE.zerosLike],428798);var rL=e.i(428798),rG=rL;function rz(e,t,r=""){if("number"!=typeof e&&"number"!=typeof t){s.util.assert(e.length===t.length,()=>r+` Shapes ${e} and ${t} must match`);for(let a=0;a<e.length;a++){let n=e[a],i=t[a];s.util.assert(n<0||i<0||n===i,()=>r+` Shapes ${e} and ${t} must match`)}}}function rU(e){return!("number"==typeof e||e.some(e=>e<0))}function rq(e,t,r){let a=rW(e,r),n=!rU(a);if(n&&0===t.length)throw Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(n&&t.forEach(e=>{a=rW(e.shape,a)}),!rU(a))throw Error(`Non-fully-defined elementShape: ${a}`);return a}function rW(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let r=[];for(let a=0;a<e.length;++a){let n=e[a],s=t[a];if(n>=0&&s>=0&&n!==s)throw Error(`Incompatible shape during merge: ${e} vs. ${t}`);r[a]=n>=0?n:s}return r}class rK{constructor(e,t,a,n,s,i,o){this.name=e,this.dtype=t,this.maxSize=a,this.elementShape=n,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=(0,tF.scalar)(0),(0,r.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),rz(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),a.read)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(a.written)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);a.tensor=t,(0,r.keep)(t),a.written=!0,this.tensors[e]=a}writeMany(e,t){if(e.length!==t.length)throw Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,r)=>this.write(e,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return(0,rs.tensor)([],[0].concat(this.elementShape));let r=this.readMany(e);return rz(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),(0,t7.stack)(r,0)}concat(e){if(e&&e!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return(0,rs.tensor)([],[0].concat(this.elementShape));let t=[];for(let e=0;e<this.size();e++)t.push(e);let r=this.readMany(t);return rz(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),(0,q.concat)(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,(0,rb.unstack)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let a=0,n=e.map(e=>a+=e);if(a!==t.shape[0])throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=0===a?0:t.size/a,i=[];(0,r.tidy)(()=>{t=(0,tP.reshape)(t,[1,a,s]);for(let r=0;r<e.length;++r){let a=[0,0===r?0:n[r-1],0],o=[1,e[r],s];i[r]=(0,tP.reshape)((0,tW.slice)(t,a,o),this.elementShape)}return i});let o=[];for(let t=0;t<e.length;t++)o[t]=t;this.writeMany(o,i)}}class rH{get id(){return this.idTensor.id}constructor(e,t,a,n=-1){this.tensors=e,this.elementShape=t,this.elementDtype=a,null!=e&&e.forEach(e=>{if(a!==e.dtype)throw Error(`Invalid data types; op elements ${a}, but list elements ${e.dtype}`);rz(t,e.shape,"TensorList shape mismatch: "),(0,r.keep)(e)}),this.idTensor=(0,tF.scalar)(0),this.maxNumElements=n,(0,r.keep)(this.idTensor)}copy(){return new rH([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,a=-1){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==a&&this.tensors.length!==a)throw Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);rz(e,this.elementShape,"TensorList shape mismatch: ");let n=rq(this.elementShape,this.tensors,e);return(0,r.tidy)(()=>{let e=this.tensors.map(e=>(0,tP.reshape)(e,n));return(0,t7.stack)(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw Error("Trying to pop from an empty list.");let r=rq(this.elementShape,this.tensors,e),a=this.tensors.pop();return a.kept=!1,rz(a.shape,e,"TensorList shape mismatch: "),(0,tP.reshape)(a,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(rz(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw Error("Trying to push element into a full list.");(0,r.keep)(e),this.tensors.push(e)}resize(e){if(e<0)throw Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new rH([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw Error(`element at index ${e} is null.`);rz(this.tensors[e].shape,t,"TensorList shape mismatch: ");let a=rq(this.elementShape,this.tensors,t);return(0,tP.reshape)(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);rz(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,r.keep)(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,a){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);rz(this.elementShape,a,"TensorList shape mismatch: "),e=e.slice(0,this.size());let n=rq(this.elementShape,this.tensors,a);return 0===e.length?(0,rs.tensor)([],[0].concat(n)):(0,r.tidy)(()=>{let t=e.map(e=>(0,tP.reshape)(this.tensors[e],n));return(0,t7.stack)(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);rz(this.elementShape,t,"TensorList shape mismatch: ");let a=rq(this.elementShape,this.tensors,t);return 0===this.size()?(0,rs.tensor)([],[0].concat(a)):(0,r.tidy)(()=>{let e=this.tensors.map(e=>(0,tP.reshape)(e,a));return(0,q.concat)(e,0)})}}let rj=async(e,t,a)=>{switch(e.op){case"If":case"StatelessIf":{let r=(0,l.getParamValue)("thenBranch",e,t,a),n=(0,l.getParamValue)("elseBranch",e,t,a),s=(0,l.getParamValue)("cond",e,t,a),i=(0,l.getParamValue)("args",e,t,a);if((await s.data())[0])return a.functionMap[r].executeFunctionAsync(i,a.tensorArrayMap,a.tensorListMap);return a.functionMap[n].executeFunctionAsync(i,a.tensorArrayMap,a.tensorListMap)}case"While":case"StatelessWhile":{let r=(0,l.getParamValue)("body",e,t,a),n=(0,l.getParamValue)("cond",e,t,a),s=(0,l.getParamValue)("args",e,t,a),i=await a.functionMap[n].executeFunctionAsync(s,a.tensorArrayMap,a.tensorListMap),o=s.map(e=>e.id),u=await i[0].data();i.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()});let p=s;for(;u[0];){let e=p,t=(p=await a.functionMap[r].executeFunctionAsync(p,a.tensorArrayMap,a.tensorListMap)).map(e=>e.id);e.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});let s=await a.functionMap[n].executeFunctionAsync(p,a.tensorArrayMap,a.tensorListMap);u=await s[0].data(),s.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return p}case"LoopCond":{let r=(0,l.getParamValue)("pred",e,t,a);return[(0,l.cloneTensor)(r)]}case"Switch":{let r=(0,l.getParamValue)("pred",e,t,a),n=(0,l.getParamValue)("data",e,t,a);return n.kept||(n=(0,l.cloneTensor)(n)),(await r.data())[0]?[void 0,n]:[n,void 0]}case"Merge":{let r=e.inputNames.find(e=>void 0!==(0,l.getTensor)(e,t,a));if(r){let e=(0,l.getTensor)(r,t,a);return[(0,l.cloneTensor)(e)]}return}case"Enter":{let r=(0,l.getParamValue)("frameName",e,t,a),n=(0,l.getParamValue)("tensor",e,t,a);return a.enterFrame(r),[(0,l.cloneTensor)(n)]}case"Exit":{let r=(0,l.getParamValue)("tensor",e,t,a);return a.exitFrame(),[(0,l.cloneTensor)(r)]}case"NextIteration":{let r=(0,l.getParamValue)("tensor",e,t,a);return a.nextIteration(),[(0,l.cloneTensor)(r)]}case"TensorArrayV3":{let r=(0,l.getParamValue)("size",e,t,a),n=(0,l.getParamValue)("dtype",e,t,a),s=(0,l.getParamValue)("elementShape",e,t,a),i=(0,l.getParamValue)("dynamicSize",e,t,a),o=(0,l.getParamValue)("clearAfterRead",e,t,a),u=(0,l.getParamValue)("identicalElementShapes",e,t,a),p=new rK((0,l.getParamValue)("name",e,t,a),n,r,s,u,i,o);return a.addTensorArray(p),[p.idTensor,(0,tF.scalar)(1)]}case"TensorArrayWriteV3":{let r=(0,l.getParamValue)("tensorArrayId",e,t,a),n=(0,l.getParamValue)("index",e,t,a),s=(0,l.getParamValue)("tensor",e,t,a),i=a.getTensorArray(r.id);return i.write(n,s),[i.idTensor]}case"TensorArrayReadV3":{let r=(0,l.getParamValue)("tensorArrayId",e,t,a),n=(0,l.getParamValue)("index",e,t,a);return[a.getTensorArray(r.id).read(n)]}case"TensorArrayGatherV3":{let r=(0,l.getParamValue)("tensorArrayId",e,t,a),n=(0,l.getParamValue)("indices",e,t,a),s=(0,l.getParamValue)("dtype",e,t,a);return[a.getTensorArray(r.id).gather(n,s)]}case"TensorArrayScatterV3":{let r=(0,l.getParamValue)("tensorArrayId",e,t,a),n=(0,l.getParamValue)("indices",e,t,a),s=(0,l.getParamValue)("tensor",e,t,a),i=a.getTensorArray(r.id);return i.scatter(n,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=(0,l.getParamValue)("tensorArrayId",e,t,a),n=a.getTensorArray(r.id),s=(0,l.getParamValue)("dtype",e,t,a);return[n.concat(s)]}case"TensorArraySplitV3":{let r=(0,l.getParamValue)("tensorArrayId",e,t,a),n=(0,l.getParamValue)("tensor",e,t,a),s=(0,l.getParamValue)("lengths",e,t,a),i=a.getTensorArray(r.id);return i.split(s,n),[i.idTensor]}case"TensorArraySizeV3":{let r=(0,l.getParamValue)("tensorArrayId",e,t,a),n=a.getTensorArray(r.id);return[(0,tF.scalar)(n.size(),"int32")]}case"TensorArrayCloseV3":{let r=(0,l.getParamValue)("tensorArrayId",e,t,a),n=a.getTensorArray(r.id);return n.clearAndClose(),[n.idTensor]}case"TensorListSetItem":{let r=(0,l.getParamValue)("tensorListId",e,t,a),n=(0,l.getParamValue)("index",e,t,a),s=(0,l.getParamValue)("tensor",e,t,a),i=a.getTensorList(r.id);return i.setItem(n,s),[i.idTensor]}case"TensorListGetItem":{let r=(0,l.getParamValue)("tensorListId",e,t,a),n=(0,l.getParamValue)("index",e,t,a),s=(0,l.getParamValue)("elementShape",e,t,a),i=(0,l.getParamValue)("elementDType",e,t,a);return[a.getTensorList(r.id).getItem(n,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=(0,l.getParamValue)("indices",e,t,a),n=function(e,t,r,a){if(t.length!==e.shape[0])throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let n=Math.max(...t);if(null!=a&&-1!==a&&n>=a)throw Error(`Max index must be < array size (${n}  vs. ${a})`);let s=new rH([],r,e.dtype,a),i=(0,rb.unstack)(e,0);return t.forEach((e,t)=>{s.setItem(e,i[t])}),s}((0,l.getParamValue)("tensor",e,t,a),r,(0,l.getParamValue)("elementShape",e,t,a),(0,l.getParamValue)("numElements",e,t,a));return a.addTensorList(n),[n.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r,n=(0,l.getParamValue)("elementShape",e,t,a),s=(0,l.getParamValue)("elementDType",e,t,a);r="TensorListReserve"===e.op?"numElements":"maxNumElements";let i=(0,l.getParamValue)(r,e,t,a),o=new rH([],n,s,"TensorListReserve"===e.op?-1:i);return a.addTensorList(o),[o.idTensor]}case"TensorListGather":{let r=(0,l.getParamValue)("tensorListId",e,t,a),n=(0,l.getParamValue)("indices",e,t,a),s=(0,l.getParamValue)("elementShape",e,t,a),i=(0,l.getParamValue)("elementDType",e,t,a);return[a.getTensorList(r.id).gather(n,i,s)]}case"TensorListStack":{let r=(0,l.getParamValue)("tensorListId",e,t,a),n=(0,l.getParamValue)("elementShape",e,t,a),s=(0,l.getParamValue)("elementDType",e,t,a),i=(0,l.getParamValue)("numElements",e,t,a);return[a.getTensorList(r.id).stack(n,s,i)]}case"TensorListFromTensor":{let r=function(e,t,r){let a=e.dtype;if(e.shape.length<1)throw Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==r)throw Error(`Invalid data types; op elements ${e.dtype}, but list elements ${r}`);return rz(e.shape.slice(1),t,"TensorList shape mismatch: "),new rH((0,rb.unstack)(e),t,a)}((0,l.getParamValue)("tensor",e,t,a),(0,l.getParamValue)("elementShape",e,t,a),(0,l.getParamValue)("elementDType",e,t,a));return a.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=(0,l.getParamValue)("tensorListId",e,t,a),n=a.getTensorList(r.id),s=(0,l.getParamValue)("dtype",e,t,a),i=(0,l.getParamValue)("elementShape",e,t,a);return[n.concat(s,i)]}case"TensorListPushBack":{let r=(0,l.getParamValue)("tensorListId",e,t,a),n=(0,l.getParamValue)("tensor",e,t,a),s=a.getTensorList(r.id);return s.pushBack(n),[s.idTensor]}case"TensorListPopBack":{let r=(0,l.getParamValue)("tensorListId",e,t,a),n=(0,l.getParamValue)("elementShape",e,t,a),s=(0,l.getParamValue)("elementDType",e,t,a);return[a.getTensorList(r.id).popBack(n,s)]}case"TensorListSplit":{let n=(0,l.getParamValue)("tensor",e,t,a),s=(0,l.getParamValue)("elementShape",e,t,a),i=function(e,t,a){let n=0,s=t.map(e=>n+=e);if(n!==e.shape[0])throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);let i=rW(e.shape.slice(1),a),o=0===n?0:e.size/n,l=(0,r.tidy)(()=>{let r=[];e=(0,tP.reshape)(e,[1,n,o]);for(let a=0;a<t.length;++a){let n=[0,0===a?0:s[a-1],0],l=[1,t[a],o];r[a]=(0,tP.reshape)((0,tW.slice)(e,n,l),i)}return e.dispose(),r}),u=new rH([],a,e.dtype,t.length);for(let e=0;e<l.length;e++)u.setItem(e,l[e]);return u}(n,(0,l.getParamValue)("lengths",e,t,a),s);return a.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=(0,l.getParamValue)("tensorListId",e,t,a),n=a.getTensorList(r.id);return[(0,tF.scalar)(n.size(),"int32")]}case"TensorListResize":{let r=(0,l.getParamValue)("tensorListId",e,t,a),n=(0,l.getParamValue)("size",e,t,a),s=a.getTensorList(r.id).resize(n);return a.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var rJ=rL;function rZ(e,t,r){let[a,n]=(0,l.getParamValue)("fusedOps",e,t,r),s="biasadd"===a,i="prelu"===n,o=(0,l.getParamValue)("numArgs",e,t,r);if(s){if(i&&2!==o)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&1!==o)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if("fusedbatchnorm"===a)throw Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=(0,l.getParamValue)("strides",e,t,r),p=(0,l.getPadding)(e,t,r),d=(0,l.getParamValue)("dataFormat",e,t,r).toUpperCase(),c=(0,l.getParamValue)("dilations",e,t,r),[h,m]=(0,l.getParamValue)("args",e,t,r);return s||(m=h,h=void 0),{stride:u,pad:p,dataFormat:d,dilations:c,biasArg:h,preluArg:m,activationFunc:n,leakyreluAlpha:(0,l.getParamValue)("leakyreluAlpha",e,t,r)}}var rX=rL,rQ=rL;function rY(e,t,r){let a=(0,l.getParamValue)("boxes",e,t,r),n=(0,l.getParamValue)("scores",e,t,r),s=(0,l.getParamValue)("maxOutputSize",e,t,r),i=(0,l.getParamValue)("iouThreshold",e,t,r);return{boxes:a,scores:n,maxOutputSize:s,iouThreshold:i,scoreThreshold:(0,l.getParamValue)("scoreThreshold",e,t,r),softNmsSigma:(0,l.getParamValue)("softNmsSigma",e,t,r)}}let r0=async(e,t,r,a,n=rQ)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:a,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=rY(e,t,r),p=await n.image.nonMaxSuppressionWithScoreAsync(a,s,i,o,l,u);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:a,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=rY(e,t,r),p=(0,l.getParamValue)("padToMaxOutputSize",e,t,r),d=await n.image.nonMaxSuppressionPaddedAsync(a,s,i,o,u,p);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:a,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=rY(e,t,r);return[await n.image.nonMaxSuppressionAsync(a,s,i,o,l)]}case"Where":{let a=n.cast((0,l.getParamValue)("condition",e,t,r),"bool"),s=[await n.whereAsync(a)];return a.dispose(),s}case"ListDiff":return n.setdiff1dAsync((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("y",e,t,r));default:throw TypeError(`Node type ${e.op} is not implemented`)}};var r1=rL,r2=rL;class r3{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=(0,tF.scalar)(0),this.tensorMap=new Map,(0,r.keep)(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return tF.scalar(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let a=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),(0,r.tidy)(()=>{let e=(0,rb.unstack)(t),n=a.length,i=e.length;s.util.assert(n===i,()=>`The number of elements doesn't match, keys has ${n} elements, the values has ${i} elements.`);for(let t=0;t<n;t++){let n=a[t],s=e[t];(0,r.keep)(s),this.tensorMap.set(n,s)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let a=await e.data();return(0,r.tidy)(()=>{let e=[];for(let r=0;r<a.length;r++){let n=a[r],s=this.findWithDefault(n,t);e.push(s)}return(0,t7.stack)(e)})}findWithDefault(e,t){let r=this.tensorMap.get(e);return null!=r?r:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}let r6=async(e,t,r,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{let n=a.getHashTableHandleByName(e.name);if(null!=n)return[n];{let n=new r3((0,l.getParamValue)("keyDType",e,t,r),(0,l.getParamValue)("valueDType",e,t,r));return a.addHashTable(e.name,n),[n.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let n=(0,l.getParamValue)("tableHandle",e,t,r,a),s=(0,l.getParamValue)("keys",e,t,r),i=(0,l.getParamValue)("values",e,t,r),o=a.getHashTableById(n.id);return[await o.import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let n=(0,l.getParamValue)("tableHandle",e,t,r,a),s=(0,l.getParamValue)("keys",e,t,r),i=(0,l.getParamValue)("defaultValue",e,t,r),o=a.getHashTableById(n.id);return[await o.find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let n=(0,l.getParamValue)("tableHandle",e,t,r,a);return[a.getHashTableById(n.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var r4=rL,r5=rL,r9=rL,r7=rL,r8=rL,ae=rL,at=rL,ar=rL,aa=rL,an=rL,as=rL;function ai(e,t,a,n,i=r.tidy){let o=((e,t,a)=>{switch(e.category){case"arithmetic":return i(()=>((e,t,r,a=rL)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"AddN":return[a.addN((0,l.getParamValue)("tensors",e,t,r))];case"FloorMod":case"Mod":return[a.mod((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"Mul":return[a.mul((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"RealDiv":case"Div":return[a.div((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"DivNoNan":return[a.divNoNan((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"FloorDiv":return[a.floorDiv((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"Sub":return[a.sub((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"Minimum":return[a.minimum((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"Maximum":return[a.maximum((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"Pow":return[a.pow((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"SquaredDifference":return[a.squaredDifference((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"basic_math":return i(()=>((e,t,r,a=rG)=>{switch(e.op){case"Abs":case"ComplexAbs":return[a.abs((0,l.getParamValue)("x",e,t,r))];case"Acos":return[a.acos((0,l.getParamValue)("x",e,t,r))];case"Acosh":return[a.acosh((0,l.getParamValue)("x",e,t,r))];case"Asin":return[a.asin((0,l.getParamValue)("x",e,t,r))];case"Asinh":return[a.asinh((0,l.getParamValue)("x",e,t,r))];case"Atan":return[a.atan((0,l.getParamValue)("x",e,t,r))];case"Atan2":return[a.atan2((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("y",e,t,r))];case"Atanh":return[a.atanh((0,l.getParamValue)("x",e,t,r))];case"Ceil":return[a.ceil((0,l.getParamValue)("x",e,t,r))];case"Complex":return[a.complex((0,l.getParamValue)("real",e,t,r),(0,l.getParamValue)("imag",e,t,r))];case"Cos":return[a.cos((0,l.getParamValue)("x",e,t,r))];case"Cosh":return[a.cosh((0,l.getParamValue)("x",e,t,r))];case"Elu":return[a.elu((0,l.getParamValue)("x",e,t,r))];case"Erf":return[a.erf((0,l.getParamValue)("x",e,t,r))];case"Exp":return[a.exp((0,l.getParamValue)("x",e,t,r))];case"Expm1":return[a.expm1((0,l.getParamValue)("x",e,t,r))];case"Floor":return[a.floor((0,l.getParamValue)("x",e,t,r))];case"Log":return[a.log((0,l.getParamValue)("x",e,t,r))];case"Log1p":return[a.log1p((0,l.getParamValue)("x",e,t,r))];case"Imag":return[a.imag((0,l.getParamValue)("x",e,t,r))];case"Neg":return[a.neg((0,l.getParamValue)("x",e,t,r))];case"Reciprocal":return[a.reciprocal((0,l.getParamValue)("x",e,t,r))];case"Real":return[a.real((0,l.getParamValue)("x",e,t,r))];case"Relu":return[a.relu((0,l.getParamValue)("x",e,t,r))];case"Round":return[a.round((0,l.getParamValue)("x",e,t,r))];case"Selu":return[a.selu((0,l.getParamValue)("x",e,t,r))];case"Sigmoid":return[a.sigmoid((0,l.getParamValue)("x",e,t,r))];case"Sin":return[a.sin((0,l.getParamValue)("x",e,t,r))];case"Sign":return[a.sign((0,l.getParamValue)("x",e,t,r))];case"Sinh":return[a.sinh((0,l.getParamValue)("x",e,t,r))];case"Softplus":return[a.softplus((0,l.getParamValue)("x",e,t,r))];case"Sqrt":return[a.sqrt((0,l.getParamValue)("x",e,t,r))];case"Square":return[a.square((0,l.getParamValue)("x",e,t,r))];case"Tanh":return[a.tanh((0,l.getParamValue)("x",e,t,r))];case"Tan":return[a.tan((0,l.getParamValue)("x",e,t,r))];case"ClipByValue":return[a.clipByValue((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("clipValueMin",e,t,r),(0,l.getParamValue)("clipValueMax",e,t,r))];case"Relu6":return[a.relu6((0,l.getParamValue)("x",e,t,r))];case"Rsqrt":return[a.rsqrt((0,l.getTensor)(e.inputNames[0],t,r))];case"LeakyRelu":return[a.leakyRelu((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("alpha",e,t,r))];case"Prelu":return[a.prelu((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("alpha",e,t,r))];case"IsNan":return[a.isNaN((0,l.getTensor)(e.inputNames[0],t,r))];case"IsInf":return[a.isInf((0,l.getTensor)(e.inputNames[0],t,r))];case"IsFinite":return[a.isFinite((0,l.getTensor)(e.inputNames[0],t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"control":return rj(e,t,a);case"convolution":return i(()=>((e,t,r,a=rJ)=>{switch(e.op){case"Conv1D":{let n=(0,l.getParamValue)("stride",e,t,r),s=(0,l.getParamValue)("pad",e,t,r),i=(0,l.getParamValue)("dataFormat",e,t,r).toUpperCase(),o=(0,l.getParamValue)("dilation",e,t,r);return[a.conv1d((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("filter",e,t,r),n,s,i,o)]}case"Conv2D":{let n=(0,l.getParamValue)("strides",e,t,r),s=(0,l.getPadding)(e,t,r),i=(0,l.getParamValue)("dataFormat",e,t,r).toUpperCase(),o=(0,l.getParamValue)("dilations",e,t,r);return[a.conv2d((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("filter",e,t,r),[n[1],n[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:n,pad:s,dataFormat:i,dilations:o,biasArg:u,preluArg:p,activationFunc:d,leakyreluAlpha:c}=rZ(e,t,r);return[a.fused.conv2d({x:(0,l.getParamValue)("x",e,t,r),filter:(0,l.getParamValue)("filter",e,t,r),strides:[n[1],n[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:d,preluActivationWeights:p,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:n,pad:s,dataFormat:i,dilations:o,biasArg:u,preluArg:p,activationFunc:d,leakyreluAlpha:c}=rZ(e,t,r);return[a.fused.depthwiseConv2d({x:(0,l.getParamValue)("x",e,t,r),filter:(0,l.getParamValue)("filter",e,t,r),strides:[n[1],n[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:d,preluActivationWeights:p,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let n=(0,l.getParamValue)("outputShape",e,t,r),s=(0,l.getParamValue)("strides",e,t,r),i=(0,l.getPadding)(e,t,r);return[a.conv2dTranspose((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("filter",e,t,r),n,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let n=(0,l.getParamValue)("strides",e,t,r),s=(0,l.getPadding)(e,t,r),i=(0,l.getParamValue)("dilations",e,t,r),o=(0,l.getParamValue)("dataFormat",e,t,r).toUpperCase();return[a.depthwiseConv2d((0,l.getParamValue)("input",e,t,r),(0,l.getParamValue)("filter",e,t,r),[n[1],n[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let n=(0,l.getParamValue)("strides",e,t,r),s=(0,l.getParamValue)("pad",e,t,r),i=(0,l.getParamValue)("dataFormat",e,t,r).toUpperCase(),o=(0,l.getParamValue)("dilations",e,t,r);return[a.conv3d((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("filter",e,t,r),[n[1],n[2],n[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let n=(0,l.getParamValue)("strides",e,t,r),s=(0,l.getParamValue)("pad",e,t,r),i=(0,l.getParamValue)("kernelSize",e,t,r);return[a.avgPool((0,l.getParamValue)("x",e,t,r),[i[1],i[2]],[n[1],n[2]],s)]}case"MaxPool":{let n=(0,l.getParamValue)("strides",e,t,r),s=(0,l.getParamValue)("pad",e,t,r),i=(0,l.getParamValue)("kernelSize",e,t,r);return[a.maxPool((0,l.getParamValue)("x",e,t,r),[i[1],i[2]],[n[1],n[2]],s)]}case"MaxPoolWithArgmax":{let n=(0,l.getParamValue)("strides",e,t,r),s=(0,l.getParamValue)("pad",e,t,r),i=(0,l.getParamValue)("kernelSize",e,t,r),o=(0,l.getParamValue)("includeBatchInIndex",e,t,r),{result:u,indexes:p}=a.maxPoolWithArgmax((0,l.getParamValue)("x",e,t,r),[i[1],i[2]],[n[1],n[2]],s,o);return[u,p]}case"AvgPool3D":{let n=(0,l.getParamValue)("strides",e,t,r),s=(0,l.getParamValue)("pad",e,t,r),i=(0,l.getParamValue)("kernelSize",e,t,r);return[a.avgPool3d((0,l.getParamValue)("x",e,t,r),[i[1],i[2],i[3]],[n[1],n[2],n[3]],s)]}case"MaxPool3D":{let n=(0,l.getParamValue)("strides",e,t,r),s=(0,l.getParamValue)("pad",e,t,r),i=(0,l.getParamValue)("kernelSize",e,t,r);return[a.maxPool3d((0,l.getParamValue)("x",e,t,r),[i[1],i[2],i[3]],[n[1],n[2],n[3]],s)]}case"Dilation2D":{let n=(0,l.getParamValue)("strides",e,t,r),s=(0,l.getParamValue)("pad",e,t,r),i=(0,l.getParamValue)("dilations",e,t,r),o=n[1],u=n[2],p=i[1],d=i[2];return[a.dilation2d((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("filter",e,t,r),[o,u],s,[p,d],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"creation":return i(()=>((e,t,r,a=rX)=>{switch(e.op){case"Fill":{let n=(0,l.getParamValue)("shape",e,t,r),s=(0,l.getParamValue)("dtype",e,t,r),i=(0,l.getParamValue)("value",e,t,r);return[a.fill(n,i,s)]}case"LinSpace":{let n=(0,l.getParamValue)("start",e,t,r),s=(0,l.getParamValue)("stop",e,t,r),i=(0,l.getParamValue)("num",e,t,r);return[a.linspace(n,s,i)]}case"Multinomial":{let n=(0,l.getParamValue)("logits",e,t,r),s=(0,l.getParamValue)("numSamples",e,t,r),i=(0,l.getParamValue)("seed",e,t,r);return[a.multinomial(n,s,i)]}case"OneHot":{let n=(0,l.getParamValue)("indices",e,t,r),s=(0,l.getParamValue)("depth",e,t,r),i=(0,l.getParamValue)("onValue",e,t,r),o=(0,l.getParamValue)("offValue",e,t,r),u=(0,l.getParamValue)("dtype",e,t,r);return[a.oneHot(n,s,i,o,u)]}case"Ones":return[a.ones((0,l.getParamValue)("shape",e,t,r),(0,l.getParamValue)("dtype",e,t,r))];case"OnesLike":return[a.onesLike((0,l.getParamValue)("x",e,t,r))];case"RandomStandardNormal":return[a.randomStandardNormal((0,l.getParamValue)("shape",e,t,r),(0,l.getParamValue)("dtype",e,t,r),(0,l.getParamValue)("seed",e,t,r))];case"RandomUniform":return[a.randomUniform((0,l.getParamValue)("shape",e,t,r),(0,l.getParamValue)("minval",e,t,r),(0,l.getParamValue)("maxval",e,t,r),(0,l.getParamValue)("dtype",e,t,r))];case"RandomUniformInt":return[a.randomUniformInt((0,l.getParamValue)("shape",e,t,r),(0,l.getParamValue)("minval",e,t,r),(0,l.getParamValue)("maxval",e,t,r),(0,l.getParamValue)("seed",e,t,r))];case"Range":{let n=(0,l.getParamValue)("start",e,t,r),s=(0,l.getParamValue)("stop",e,t,r),i=(0,l.getParamValue)("step",e,t,r);return[a.range(n,s,i,(0,l.getParamValue)("dtype",e,t,r))]}case"TruncatedNormal":{let n=(0,l.getParamValue)("shape",e,t,r),s=(0,l.getParamValue)("mean",e,t,r),i=(0,l.getParamValue)("stdDev",e,t,r),o=(0,l.getParamValue)("seed",e,t,r);return[a.truncatedNormal(n,s,i,(0,l.getParamValue)("dtype",e,t,r),o)]}case"Zeros":return[a.zeros((0,l.getParamValue)("shape",e,t,r),(0,l.getParamValue)("dtype",e,t,r))];case"ZerosLike":return[a.zerosLike((0,l.getParamValue)("x",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"dynamic":return r0(e,t,a);case"evaluation":return i(()=>((e,t,r,a=r1)=>{switch(e.op){case"LowerBound":{let n=(0,l.getParamValue)("sortedSequence",e,t,r),s=(0,l.getParamValue)("values",e,t,r);return[a.lowerBound(n,s)]}case"TopKV2":{let n=(0,l.getParamValue)("x",e,t,r),s=(0,l.getParamValue)("k",e,t,r),i=(0,l.getParamValue)("sorted",e,t,r),o=a.topk(n,s,i);return[o.values,o.indices]}case"UpperBound":{let n=(0,l.getParamValue)("sortedSequence",e,t,r),s=(0,l.getParamValue)("values",e,t,r);return[a.upperBound(n,s)]}case"Unique":{let n=(0,l.getParamValue)("x",e,t,r),s=a.unique(n);return[s.values,s.indices]}case"UniqueV2":{let n=(0,l.getParamValue)("x",e,t,r),s=(0,l.getParamValue)("axis",e,t,r),i=a.unique(n,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"image":return i(()=>((e,t,r,a=r4)=>{switch(e.op){case"ResizeBilinear":{let n=(0,l.getParamValue)("images",e,t,r),s=(0,l.getParamValue)("size",e,t,r),i=(0,l.getParamValue)("alignCorners",e,t,r),o=(0,l.getParamValue)("halfPixelCenters",e,t,r);return[a.image.resizeBilinear(n,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let n=(0,l.getParamValue)("images",e,t,r),s=(0,l.getParamValue)("size",e,t,r),i=(0,l.getParamValue)("alignCorners",e,t,r),o=(0,l.getParamValue)("halfPixelCenters",e,t,r);return[a.image.resizeNearestNeighbor(n,[s[0],s[1]],i,o)]}case"CropAndResize":{let n=(0,l.getParamValue)("image",e,t,r),s=(0,l.getParamValue)("boxes",e,t,r),i=(0,l.getParamValue)("boxInd",e,t,r),o=(0,l.getParamValue)("cropSize",e,t,r),u=(0,l.getParamValue)("method",e,t,r),p=(0,l.getParamValue)("extrapolationValue",e,t,r);return[a.image.cropAndResize(n,s,i,o,u,p)]}case"ImageProjectiveTransformV3":{let n=(0,l.getParamValue)("images",e,t,r),s=(0,l.getParamValue)("transforms",e,t,r),i=(0,l.getParamValue)("outputShape",e,t,r),o=(0,l.getParamValue)("fillValue",e,t,r),u=(0,l.getParamValue)("interpolation",e,t,r),p=(0,l.getParamValue)("fillMode",e,t,r);return[a.image.transform(n,s,u.toLowerCase(),p.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"graph":return i(()=>((e,t,r,a=r2)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let n=(0,l.getParamValue)("default",e,t,r);return[(0,l.getTensor)(e.name,t,r)||n];case"Placeholder":return[(0,l.getTensor)(e.name,t,r)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let a=(0,l.getParamValue)("x",e,t,r);return[(0,l.cloneTensor)(a)]}case"IdentityN":return(0,l.getParamValue)("x",e,t,r).map(e=>(0,l.cloneTensor)(e));case"Snapshot":let s=(0,l.getParamValue)("x",e,t,r);return[(0,l.cloneTensor)(s)];case"Shape":return[a.tensor1d((0,l.getParamValue)("x",e,t,r).shape,"int32")];case"ShapeN":return(0,l.getParamValue)("x",e,t,r).map(e=>a.tensor1d(e.shape));case"Size":return[a.scalar((0,l.getParamValue)("x",e,t,r).size,"int32")];case"Rank":return[a.scalar((0,l.getParamValue)("x",e,t,r).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":let i=(0,l.getParamValue)("x",e,t,r),o=(0,l.getParamValue)("data",e,t,r),u=(0,l.getParamValue)("message",e,t,r),p=(0,l.getParamValue)("summarize",e,t,r);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,p));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"logical":return i(()=>((e,t,r,a=r5)=>{switch(e.op){case"Equal":return[a.equal((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"NotEqual":return[a.notEqual((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"Greater":return[a.greater((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"GreaterEqual":return[a.greaterEqual((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"Less":return[a.less((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"LessEqual":return[a.lessEqual((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"LogicalAnd":return[a.logicalAnd((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"LogicalNot":return[a.logicalNot((0,l.getParamValue)("a",e,t,r))];case"LogicalOr":return[a.logicalOr((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"Select":case"SelectV2":return[a.where((0,l.getParamValue)("condition",e,t,r),(0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];case"BitwiseAnd":return[a.bitwiseAnd((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"matrices":return i(()=>((e,t,r,a=r9)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("b",e,t,r),(0,l.getParamValue)("transposeA",e,t,r),(0,l.getParamValue)("transposeB",e,t,r))];case"Einsum":return[a.einsum((0,l.getParamValue)("equation",e,t,r),...(0,l.getParamValue)("tensors",e,t,r))];case"Transpose":return[a.transpose((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("perm",e,t,r))];case"_FusedMatMul":let[n,s]=(0,l.getParamValue)("fusedOps",e,t,r),i="prelu"===s,o=(0,l.getParamValue)("numArgs",e,t,r),u=(0,l.getParamValue)("leakyreluAlpha",e,t,r);if("biasadd"===n){if(i&&2!==o)throw Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==o)throw Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[p,d]=(0,l.getParamValue)("args",e,t,r);return[a.fused.matMul({a:(0,l.getParamValue)("a",e,t,r),b:(0,l.getParamValue)("b",e,t,r),transposeA:(0,l.getParamValue)("transposeA",e,t,r),transposeB:(0,l.getParamValue)("transposeB",e,t,r),bias:p,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[a.linalg.bandPart((0,l.getParamValue)("a",e,t,r),(0,l.getParamValue)("numLower",e,t,r),(0,l.getParamValue)("numUpper",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"normalization":return i(()=>((e,t,r,a=r7)=>{switch(e.op){case"EuclideanNorm":return[a.euclideanNorm((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("axis",e,t,r),(0,l.getParamValue)("keepDims",e,t,r))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[a.batchNorm((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("mean",e,t,r),(0,l.getParamValue)("variance",e,t,r),(0,l.getParamValue)("offset",e,t,r),(0,l.getParamValue)("scale",e,t,r),(0,l.getParamValue)("epsilon",e,t,r))];case"LRN":return[a.localResponseNormalization((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("radius",e,t,r),(0,l.getParamValue)("bias",e,t,r),(0,l.getParamValue)("alpha",e,t,r),(0,l.getParamValue)("beta",e,t,r))];case"Softmax":return[a.softmax((0,l.getParamValue)("x",e,t,r))];case"LogSoftmax":return[a.logSoftmax((0,l.getParamValue)("x",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"ragged":return i(()=>((e,t,r,a=r8)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:n,outputDenseValues:s}=a.raggedGather((0,l.getParamValue)("paramsNestedSplits",e,t,r),(0,l.getParamValue)("paramsDenseValues",e,t,r),(0,l.getParamValue)("indices",e,t,r),(0,l.getParamValue)("outputRaggedRank",e,t,r));return n.concat(s)}case"RaggedRange":{let{rtNestedSplits:n,rtDenseValues:s}=a.raggedRange((0,l.getParamValue)("starts",e,t,r),(0,l.getParamValue)("limits",e,t,r),(0,l.getParamValue)("splits",e,t,r));return[n,s]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor((0,l.getParamValue)("shape",e,t,r),(0,l.getParamValue)("values",e,t,r),(0,l.getParamValue)("defaultValue",e,t,r),(0,l.getParamValue)("rowPartitionTensors",e,t,r),(0,l.getParamValue)("rowPartitionTypes",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"reduction":return i(()=>((e,t,r,a=ae)=>{switch(e.op){case"Max":{let n=(0,l.getParamValue)("axis",e,t,r),s=(0,l.getParamValue)("keepDims",e,t,r);return[a.max((0,l.getParamValue)("x",e,t,r),n,s)]}case"Mean":{let n=(0,l.getParamValue)("axis",e,t,r),s=(0,l.getParamValue)("keepDims",e,t,r);return[a.mean((0,l.getParamValue)("x",e,t,r),n,s)]}case"Min":{let n=(0,l.getParamValue)("axis",e,t,r),s=(0,l.getParamValue)("keepDims",e,t,r);return[a.min((0,l.getParamValue)("x",e,t,r),n,s)]}case"Sum":{let n=(0,l.getParamValue)("axis",e,t,r),s=(0,l.getParamValue)("keepDims",e,t,r);return[a.sum((0,l.getParamValue)("x",e,t,r),n,s)]}case"All":{let n=(0,l.getParamValue)("axis",e,t,r),s=(0,l.getParamValue)("keepDims",e,t,r);return[a.all((0,l.getParamValue)("x",e,t,r),n,s)]}case"Any":{let n=(0,l.getParamValue)("axis",e,t,r),s=(0,l.getParamValue)("keepDims",e,t,r);return[a.any((0,l.getParamValue)("x",e,t,r),n,s)]}case"ArgMax":{let n=(0,l.getParamValue)("axis",e,t,r);return[a.argMax((0,l.getParamValue)("x",e,t,r),n)]}case"ArgMin":{let n=(0,l.getParamValue)("axis",e,t,r);return[a.argMin((0,l.getParamValue)("x",e,t,r),n)]}case"Prod":{let n=(0,l.getParamValue)("axis",e,t,r),s=(0,l.getParamValue)("keepDims",e,t,r);return[a.prod((0,l.getParamValue)("x",e,t,r),n,s)]}case"Cumprod":{let n=(0,l.getParamValue)("axis",e,t,r),s=(0,l.getParamValue)("exclusive",e,t,r),i=(0,l.getParamValue)("reverse",e,t,r);return[a.cumprod((0,l.getParamValue)("x",e,t,r),n,s,i)]}case"Cumsum":{let n=(0,l.getParamValue)("axis",e,t,r),s=(0,l.getParamValue)("exclusive",e,t,r),i=(0,l.getParamValue)("reverse",e,t,r);return[a.cumsum((0,l.getParamValue)("x",e,t,r),n,s,i)]}case"Bincount":let n=(0,l.getParamValue)("x",e,t,r),s=(0,l.getParamValue)("weights",e,t,r),i=(0,l.getParamValue)("size",e,t,r);return[a.bincount(n,s,i)];case"DenseBincount":{let n=(0,l.getParamValue)("x",e,t,r),s=(0,l.getParamValue)("weights",e,t,r),i=(0,l.getParamValue)("size",e,t,r),o=(0,l.getParamValue)("binaryOutput",e,t,r);return[a.denseBincount(n,s,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"slice_join":return i(()=>((e,t,a,n=at)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=(0,l.getParamValue)("n",e,t,a),s=(0,l.getParamValue)("axis",e,t,a),i=(0,l.getParamValue)("tensors",e,t,a);return i=i.slice(0,r),[n.concat(i,s)]}case"Gather":{let r=(0,l.getParamValue)("x",e,t,a),s=(0,l.getParamValue)("indices",e,t,a);return[n.gather(r,n.cast(s,"int32"),0)]}case"GatherV2":{let r=(0,l.getParamValue)("axis",e,t,a),s=(0,l.getParamValue)("batchDims",e,t,a),i=(0,l.getParamValue)("x",e,t,a),o=(0,l.getParamValue)("indices",e,t,a);return[n.gather(i,n.cast(o,"int32"),r,s)]}case"Reverse":{let r=(0,l.getParamValue)("dims",e,t,a),s=[];for(let e=0;e<r.length;e++)r[e]&&s.push(e);let i=(0,l.getParamValue)("x",e,t,a);return[n.reverse(i,s)]}case"ReverseV2":{let r=(0,l.getParamValue)("axis",e,t,a),s=(0,l.getParamValue)("x",e,t,a);return[n.reverse(s,r)]}case"Slice":{let r=(0,l.getParamValue)("begin",e,t,a),s=(0,l.getParamValue)("size",e,t,a);return[n.slice((0,l.getParamValue)("x",e,t,a),r,s)]}case"StridedSlice":{let r=(0,l.getParamValue)("begin",e,t,a),s=(0,l.getParamValue)("end",e,t,a),i=(0,l.getParamValue)("strides",e,t,a),o=(0,l.getParamValue)("beginMask",e,t,a),u=(0,l.getParamValue)("endMask",e,t,a),p=(0,l.getParamValue)("ellipsisMask",e,t,a),d=(0,l.getParamValue)("newAxisMask",e,t,a),c=(0,l.getParamValue)("shrinkAxisMask",e,t,a),h=(0,l.getParamValue)("x",e,t,a);return[n.stridedSlice(h,r,s,i,o,u,p,d,c)]}case"Pack":return(0,r.tidy)(()=>{let r=(0,l.getParamValue)("axis",e,t,a),i=(0,l.getParamValue)("tensors",e,t,a),o=i[0].shape,u=n.squeeze(i[0]).shape,p=i.map(e=>{let t=s.util.arraysEqual(e.shape,o);if(!t&&!s.util.arraysEqual(n.squeeze(e).shape,u))throw Error("the input tensors shape does not match");return t?e:n.reshape(e,o)});return[n.stack(p,r)]});case"Unpack":{let r=(0,l.getParamValue)("axis",e,t,a),s=(0,l.getParamValue)("tensor",e,t,a);return n.unstack(s,r)}case"Tile":{let r=(0,l.getParamValue)("reps",e,t,a);return[n.tile((0,l.getParamValue)("x",e,t,a),r)]}case"Split":case"SplitV":{let r=(0,l.getParamValue)("axis",e,t,a),s=(0,l.getParamValue)("numOrSizeSplits",e,t,a),i=(0,l.getParamValue)("x",e,t,a);return n.split(i,s,r)}case"ScatterNd":{let r=(0,l.getParamValue)("indices",e,t,a),s=(0,l.getParamValue)("values",e,t,a),i=(0,l.getParamValue)("shape",e,t,a);return[n.scatterND(r,s,i)]}case"GatherNd":{let r=(0,l.getParamValue)("x",e,t,a),s=(0,l.getParamValue)("indices",e,t,a);return[n.gatherND(r,s)]}case"SparseToDense":{let r=(0,l.getParamValue)("sparseIndices",e,t,a),s=(0,l.getParamValue)("outputShape",e,t,a),i=(0,l.getParamValue)("sparseValues",e,t,a),o=(0,l.getParamValue)("defaultValue",e,t,a);return[n.sparseToDense(r,i,s,i.dtype===o.dtype?o:n.cast(o,i.dtype))]}case"TensorScatterUpdate":{let r=(0,l.getParamValue)("indices",e,t,a),s=(0,l.getParamValue)("values",e,t,a),i=(0,l.getParamValue)("tensor",e,t,a);return[n.tensorScatterUpdate(i,r,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"sparse":return i(()=>((e,t,r,a=ar)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:n,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows((0,l.getParamValue)("indices",e,t,r),(0,l.getParamValue)("values",e,t,r),(0,l.getParamValue)("denseShape",e,t,r),(0,l.getParamValue)("defaultValue",e,t,r));return[n,s,i,o]}case"SparseReshape":{let{outputIndices:n,outputShape:s}=a.sparse.sparseReshape((0,l.getParamValue)("inputIndices",e,t,r),(0,l.getParamValue)("inputShape",e,t,r),(0,l.getParamValue)("newShape",e,t,r));return[n,s]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean((0,l.getParamValue)("data",e,t,r),(0,l.getParamValue)("indices",e,t,r),(0,l.getParamValue)("segmentIds",e,t,r))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum((0,l.getParamValue)("data",e,t,r),(0,l.getParamValue)("indices",e,t,r),(0,l.getParamValue)("segmentIds",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"spectral":return i(()=>((e,t,r,a=aa)=>{switch(e.op){case"FFT":return[a.fft((0,l.getParamValue)("x",e,t,r))];case"IFFT":return[a.ifft((0,l.getParamValue)("x",e,t,r))];case"RFFT":return[a.rfft((0,l.getParamValue)("x",e,t,r))];case"IRFFT":return[a.irfft((0,l.getParamValue)("x",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"string":return i(()=>((e,t,r,a=an)=>{switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace((0,l.getParamValue)("input",e,t,r),(0,l.getParamValue)("pattern",e,t,r),(0,l.getParamValue)("rewrite",e,t,r),(0,l.getParamValue)("replaceGlobal",e,t,r))];case"StringNGrams":{let{nGrams:n,nGramsSplits:s}=a.string.stringNGrams((0,l.getParamValue)("data",e,t,r),(0,l.getParamValue)("dataSplits",e,t,r),(0,l.getParamValue)("separator",e,t,r),(0,l.getParamValue)("nGramWidths",e,t,r),(0,l.getParamValue)("leftPad",e,t,r),(0,l.getParamValue)("rightPad",e,t,r),(0,l.getParamValue)("padWidth",e,t,r),(0,l.getParamValue)("preserveShortSequences",e,t,r));return[n,s]}case"StringSplit":{let{indices:n,values:s,shape:i}=a.string.stringSplit((0,l.getParamValue)("input",e,t,r),(0,l.getParamValue)("delimiter",e,t,r),(0,l.getParamValue)("skipEmpty",e,t,r));return[n,s,i]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast((0,l.getParamValue)("input",e,t,r),(0,l.getParamValue)("numBuckets",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"transformation":return i(()=>((e,t,r,a=as)=>{switch(e.op){case"Cast":return[a.cast((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("dtype",e,t,r))];case"ExpandDims":{let n=(0,l.getParamValue)("axis",e,t,r);return[a.expandDims((0,l.getParamValue)("x",e,t,r),n)]}case"Squeeze":{let n=(0,l.getParamValue)("axis",e,t,r);return[a.squeeze((0,l.getParamValue)("x",e,t,r),n)]}case"Reshape":return[a.reshape((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("shape",e,t,r))];case"EnsureShape":return[a.ensureShape((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("shape",e,t,r))];case"MirrorPad":return[a.mirrorPad((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("padding",e,t,r),(0,l.getParamValue)("mode",e,t,r))];case"PadV2":case"Pad":return[a.pad((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("padding",e,t,r),(0,l.getParamValue)("constantValue",e,t,r))];case"SpaceToBatchND":{let n=(0,l.getParamValue)("blockShape",e,t,r),s=(0,l.getParamValue)("paddings",e,t,r);return[a.spaceToBatchND((0,l.getParamValue)("x",e,t,r),n,s)]}case"BatchToSpaceND":{let n=(0,l.getParamValue)("blockShape",e,t,r),s=(0,l.getParamValue)("crops",e,t,r);return[a.batchToSpaceND((0,l.getParamValue)("x",e,t,r),n,s)]}case"DepthToSpace":{let n=(0,l.getParamValue)("blockSize",e,t,r),s=(0,l.getParamValue)("dataFormat",e,t,r).toUpperCase();return[a.depthToSpace((0,l.getParamValue)("x",e,t,r),n,s)]}case"BroadcastTo":return[a.broadcastTo((0,l.getParamValue)("x",e,t,r),(0,l.getParamValue)("shape",e,t,r))];case"BroadcastArgs":return[a.broadcastArgs((0,l.getParamValue)("s0",e,t,r),(0,l.getParamValue)("s1",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a));case"hash_table":return r6(e,t,a,n);case"custom":let o=(0,p.getRegisteredOp)(e.op);if(o&&o.customExecutor)return o.customExecutor(new u.NodeValueImpl(e,t,a));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,a);return s.util.isPromise(o)?o.then(e=>[].concat(e)):[].concat(o)}class ao{constructor(e={},t={},r={},a={},n){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=a,this.parseNodeNameCache=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function al(e,t,r,a){let n=new Set,s=[],i=null,o=null,u=new Set,p=new Set(Object.keys(e).map(e=>(0,l.parseNodeName)(e)[0])),d=new Set((a=a||[]).map(e=>(0,l.parseNodeName)(e.name)[0])),c=[...t];for(;c.length>0;){var h,m;let e=c.pop();if((ah(e)||(h=e,ad.has(h.op))||(m=e,ac.has(m.op)))&&null==i&&(o=(i=e).children.map(e=>e.name).filter(e=>n.has(e))),n.add(e.name),!(null!=r[e.name]||p.has(e.name)||d.has(e.name))){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach(e=>{u.has(e.name)||(u.add(e.name),c.push(e))})}}return{inputs:e,outputs:t,usedNodes:n,missingInputs:s,dynamicNode:i,syncInputs:o}}class au extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}let ap=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),ad=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),ac=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function ah(e){return ap.has(e.op)}class am{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new am(e.functions[t],this)})}getCompilationKey(e,t){let r=e.map(e=>e.name).sort(),a=t.map(e=>e.name).sort();return r.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(e,t){let r=al(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:n,syncInputs:s}=r;if(null!=n)throw Error(`This execution contains the node '${n.name}', which has the dynamic op '${n.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(a.length>0){let r=t.map(e=>e.name),n=Object.keys(e);throw Error(`Cannot compute the outputs [${r}] from the provided inputs [${n}]. Missing the following inputs: [${a}]`)}let i=function(e,t){let{usedNodes:r,inputs:a}=t,n=Object.keys(a).map(e=>(0,l.parseNodeName)(e)[0]).map(t=>e.nodes[t]),s=e.initNodes||[],i=e=>r.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map(e=>[e.name,e])).values()]}let u=o([...n,...e.weights,...s]).filter(i),p=o([...u,...Object.values(e.nodes)]).filter(i),d=new Map(p.map(e=>[e.name,e])),c={};for(let e of p)for(let t of(c[e.name]=c[e.name]||0,e.children))i(t)||(c[t.name]=1/0),c[t.name]=(c[t.name]||0)+1;let h=Object.entries(c).filter(([,e])=>0===e).map(([e])=>e),m=[...h];for(;h.length>0;){let e=h.pop();for(let t of d.get(e).children.filter(i))0==--c[t.name]&&(m.push(t.name),h.push(t.name))}let f=function(e,t){let r=new Map(e.map(e=>[e.name,e])),a=t.map(e=>e.name),n=new Set(a);for(;a.length>0;){let e=a.pop();for(let t of r.get(e).children)!r.has(t.name)||n.has(t.name)||(n.add(t.name),a.push(t.name))}return e.filter(e=>n.has(e.name))}(m.map(e=>d.get(e)),u);return function(e,t){let r=new Map(e.map((e,t)=>[e.name,t])),a=new Set(t.map(e=>e.name)),n=e=>a.has("string"==typeof e?e:e.name),s=new Set(e.map(e=>e.name)),i=e=>s.has("string"==typeof e?e:e.name);for(let t of e){for(let e of t.children.filter(i)){if(!r.has(e.name))throw new au(`Child ${e.name} of node ${t.name} is unreachable.`);if(r.get(t.name)>r.get(e.name))throw new au(`Node ${t.name} is scheduled to run after its child ${e.name}.`)}if(!n(t))for(let e of t.inputs){if(!r.has(e.name))throw new au(`Input ${e.name} of node ${t.name} is unreachable.`);if(r.get(e.name)>r.get(t.name))throw new au(`Node ${t.name} is scheduled to run before its input ${e.name}.`)}}}(f,u),f}(this.graph,r),o=function(e){let t=new Map(e.map((e,t)=>[e.name,t])),r=Number.MAX_SAFE_INTEGER,a=e.map((e,t)=>ah(e)?r:t),n=e=>{let r=a[t.get(e.name)];return null==r?-1:r},s=e.map((e,t)=>e.children.map(n).reduce((e,t)=>Math.max(e,t),a[t])),i=new Map;for(let t=0;t<e.length;++t){let a=s[t];if(a===r)continue;let n=e[t],o=e[a];i.has(o.name)||i.set(o.name,[]),i.get(o.name).push(n)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return(0,r.keep)(t),t}cloneTensorList(e){return e?e.map(e=>this.cloneAndKeepTensor(e)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([e,t])=>[e,this.cloneTensorList(t)]))}execute(e,t){this.disposeIntermediateTensors();let a=Object.keys(e=this.mapInputs(e)).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let n=a.map(e=>this.graph.nodes[(0,l.parseNodeName)(e)[0]]),i=t.map(e=>(0,l.parseNodeName)(e)[0]),u=new Set(i),p=i.map(e=>this.graph.nodes[e]);0===p.length&&(p=this._outputs);let d=this.getCompilationKey(n,p),c=this.compiledMap.get(d);null==c&&(c=this.compile(e,p),this.compiledMap.set(d,c));try{this.keepIntermediateTensors=(0,o.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}let h={},m={};return(0,r.tidy)(()=>{let r=new ao(this.weightMap,h,m,this.functionExecutorMap,this.parseNodeNameCache),a=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(t=>{let[n,s]=(0,l.parseNodeName)(t,r),i=[];i[s]=e[t],a[n]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[n]=this.cloneTensorList(i))});let n=this.getFrozenTensorIds(a),{orderedNodes:i,nodeLiveUntilMap:o}=c;for(let e of i){if(a[e.name])continue;let t=ai(e,a,r,this._resourceManager);if(s.util.isPromise(t))throw Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);a[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,a,r,n,u,o.get(e.name))}return null==this.parent&&r.dispose(n),t.map(e=>(0,l.getTensor)(e,a,r))})}getFrozenTensorIds(e){return new Set([].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id))))}checkTensorForDisposal(e,t,r,a,n,s,i){if(!(ah(t)||s.has(e))){for(let a of r[e])null!=a&&(i[a.id]=(i[a.id]||0)+t.children.length);for(let e of t.inputs){if(ah(e))continue;let t=(0,l.getTensorsForCurrentContext)(e.name,r,a);if(null!=t)for(let e of t){if(!e||e.kept||n.has(e.id))continue;let t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,a,n,s){if(!ah(e)&&null!=s){for(let e of s)if(!(ah(e)||n.has(e.name)))for(let n of(0,l.getTensorsForCurrentContext)(e.name,t,r))!n||n.kept||a.has(n.id)||n.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,a={},n={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=(0,o.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}let s=new ao(this.weightMap,a,n,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,s,t,r),u=t.map(e=>(0,l.getTensor)(e,i,s)),p=new Set([...u.map(e=>e.id),...Object.keys(e).map(t=>e[t].id),...this.weightIds]);return Object.values(i).forEach(e=>{e.forEach(e=>{!e||e.isDisposed||p.has(e.id)||e.dispose()})}),null==this.parent&&s.dispose(p),u}async executeFunctionAsync(e,t,r){let a=e.reduce((e,t,r)=>(e[this.inputs[r].name]=t,e),{});return this._executeAsync(a,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,a){let n=Object.keys(e),s=n.map(e=>this.graph.nodes[(0,l.parseNodeName)(e)[0]]),i=r.map(e=>(0,l.parseNodeName)(e)[0]),o=new Set(i),u=i.map(e=>this.graph.nodes[e]);0===u.length&&(u=this._outputs);let{usedNodes:p,missingInputs:d,dynamicNode:c,syncInputs:h}=al(e,u,this.weightMap,this._initNodes),m=[...s,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{let[r,a]=(0,l.parseNodeName)(t),n=[];n[a]=e[t],f[r]=n});let g={},y=this.getFrozenTensorIds(f),b={};for(;m.length>0;){let e=this.processStack(s,m,t,f,b,y,o,g,p);await Promise.all(e)}null!=c||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let T=u.filter(e=>!ah(e)&&!(0,l.getTensor)(e.name,f,t)).map(e=>e.name);if(T.length>0){let e="";throw null!=c&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),Error(`Cannot compute the outputs [${T}] from the provided inputs [${n}]. Consider providing the following inputs: [${d}]. ${e}`)}return f}processStack(e,t,r,a,n,i,o,u,p){let d=[];for(;t.length>0;){let e=t.pop();r.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&(0,l.getParamValue)("isConstant",e.node,a,r)&&([c]=(0,l.getNodeNameAndIndex)(e.node.name,r)),null==a[e.node.name]){let h=ai(e.node,a,r,this._resourceManager);c||([c]=(0,l.getNodeNameAndIndex)(e.node.name,r));let m=r.currentContext;s.util.isPromise(h)?d.push(h.then(s=>(a[c]=s,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(s)),r.currentContext=m,this.checkTensorForDisposal(c,e.node,a,r,i,o,u),this.processChildNodes(e.node,t,r,a,n,p),s))):(a[c]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(h)),this.checkTensorForDisposal(c,e.node,a,r,i,o,u),this.processChildNodes(e.node,t,r,a,n,p))}else this.processChildNodes(e.node,t,r,a,n,p)}return d}processChildNodes(e,t,r,a,n,s){e.children.forEach(e=>{let[i]=(0,l.getNodeNameAndIndex)(e.name,r);!n[i]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!(0,l.getTensor)(e,a,r))&&(n[i]=!0,t.push({contexts:r.currentContext,node:e})):e.inputNames.every(e=>!!(0,l.getTensor)(e,a,r))&&(n[i]=!0,t.push({contexts:r.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let r=e[t],[a]=(0,l.parseNodeName)(t),n=this.graph.nodes[a];if(n.attrParams.shape&&n.attrParams.shape.value){let e=n.attrParams.shape.value,t=e.length===r.shape.length&&r.shape.every((t,r)=>-1===e[r]||e[r]===t);s.util.assert(t,()=>`The shape of dict['${n.name}'] provided in model.execute(dict) must be [${e}], but was [${r.shape}]`)}n.attrParams.dtype&&n.attrParams.dtype.value&&s.util.assert(r.dtype===n.attrParams.dtype.value,()=>`The dtype of dict['${n.name}'] provided in model.execute(dict) must be ${n.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;let a={};for(let n in e){let s=null==(r=null==(t=this._signature)?void 0:t.inputs)?void 0:r[n];null!=s?a[s.name]=e[n]:a[n]=e[n]}return a}checkInputs(e){let t=Object.keys(e).filter(e=>{let[t]=(0,l.parseNodeName)(e);return null==this.graph.nodes[t]});if(t.length>0)throw Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>{var t,r;let a=null==(r=null==(t=this._signature)?void 0:t.outputs)?void 0:r[e];return null!=a?a.name:e},{})}checkOutputs(e){e.forEach(e=>{let[t]=(0,l.parseNodeName)(e);if(!this.graph.nodes[t])throw Error(`The output '${e}' is not found in the graph`)})}}class af{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}var ag=e.i(254577);class ay{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=a.io){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,null==t&&(this.loadOptions={}),this.resourceManager=new af}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return s.util.isPromise(e)?e.then(e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw Error("Model artifacts missing streamWeights function");let t=await (0,ag.decodeWeightsStream)(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let r=this.artifacts.modelTopology,a=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(a=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=a,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new am(i.OperationMapper.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=i.OperationMapper.Instance.transformGraph(e.modelInitializer);this.initializer=new am(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof n.Tensor?[e]:e,r={};return t.forEach((e,t)=>r[this.structuredOutputKeys[t]]=e),r}return e}predict(e,t){let r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){let r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof n.Tensor)&&!Array.isArray(e)){let r=null==(t=this.signature)?void 0:t.inputs;if(null!=r)for(let t in r){let a=r[t];null!=a.resourceId&&(e[t]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];let r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let a=0;return this.inputNodes.reduce((t,r)=>{var n,s,i;let o=null==(i=null==(s=null==(n=this.signature)?void 0:n.inputs)?void 0:s[r])?void 0:i.resourceId;return null!=o?t[r]=this.resourceIdToCapturedInput[o]:t[r]=e[a++],t},{})}normalizeOutputs(e){return Array.isArray(e=e||this.outputNodes)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,r=Object.keys(t);for(let a=0;a<r.length;a++){let n=t[r[a]];this.resourceIdToCapturedInput[n.resourceId]=e[a]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,r.dispose)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function ab(e,t={},r=a.io){var n;if(null==e)throw Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&((n=e).endsWith("/")||(n+="/"),e=`${n}model.json?tfjs-format=file`);let s=new ay(e,t,r);return await s.load(),s}function aT(e){let t;if(null==e)throw Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");if(e instanceof Array){let[r,n]=e;if(!r)throw Error("modelJSON must be the first element of the array");if(!n||!(n instanceof ArrayBuffer))throw Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw Error("Model JSON is missing 'weightsManifest'");let s=a.io.getWeightSpecs(r.weightsManifest),i=a.io.getModelArtifactsForJSONSync(r,s,n);t=a.io.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=a.io.fromMemorySync(e);else throw Error("Unknown model format");let r=new ay(t);return r.load(),r}e.s(["GraphModel",()=>ay,"loadGraphModel",()=>ab,"loadGraphModelSync",()=>aT],139397),e.s(["version",()=>"4.22.0"],837322),e.s([],139515);var av=e.i(27923),aN=e.i(592061),ax=e.i(248534);let aS=!1;function aE(e,r=3){let a,n;if(r>4)throw Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw Error("pixels passed to tf.browser.fromPixels() can not be null");let s=!1,i=!1,o=!1,l=!1,u=!1,p=!1;if(e.data instanceof Uint8Array)s=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)i=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)o=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)l=!0;else if(null!=e.getContext)u=!0;else if("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap)p=!0;else throw Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(null!=(0,ax.getKernel)(aN.FromPixels,av.ENGINE.backendName))return av.ENGINE.runKernel(aN.FromPixels,{pixels:e},{numChannels:r});let[d,c]=o?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(u)a=e.getContext("2d").getImageData(0,0,d,c).data;else if(i||s)a=e.data;else if(l||o||p){if(null==t)if("undefined"==typeof document)if("undefined"!=typeof OffscreenCanvas&&"undefined"!=typeof OffscreenCanvasRenderingContext2D)t=new OffscreenCanvas(1,1).getContext("2d");else throw Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else t=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});t.canvas.width=d,t.canvas.height=c,t.drawImage(e,0,0,d,c),a=t.getImageData(0,0,d,c).data}if(4===r)n=new Int32Array(a);else{let e=d*c;n=new Int32Array(e*r);for(let t=0;t<e;t++)for(let e=0;e<r;++e)n[t*r+e]=a[4*t+e]}let h=[c,d,r];return(0,rl.tensor3d)(n,h,"int32")}async function aw(e,t=3){var r;let a=null;if((0,o.env)().getBool("WRAP_TO_IMAGEBITMAP")&&"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&null!=(r=e)&&0!==r.width&&0!==r.height&&!(null!=e&&e.data instanceof Uint8Array)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}a=null!=t&&t.width===e.width&&t.height===e.height?t:e}else a=e;return aE(a,t)}function ak(e){if(2!==e.rank&&3!==e.rank)throw Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function aI(e,t){let r=(0,rO.convertToTensor)(e,"img","toPixels");if(!(e instanceof n.Tensor)){let e=r;r=(0,B.cast)(e,"int32"),e.dispose()}ak(r);let[a,s]=r.shape.slice(0,2),i=2===r.rank?1:r.shape[2],o=await r.data(),l="float32"===r.dtype?255:1,u=new Uint8ClampedArray(s*a*4);for(let e=0;e<a*s;++e){let t=[0,0,0,255];for(let a=0;a<i;a++){let n=o[e*i+a];if("float32"===r.dtype){if(n<0||n>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${n}.`)}else if("int32"===r.dtype&&(n<0||n>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${n}.`);1===i?(t[0]=n*l,t[1]=n*l,t[2]=n*l):t[a]=n*l}let a=4*e;u[a+0]=Math.round(t[0]),u[a+1]=Math.round(t[1]),u[a+2]=Math.round(t[2]),u[a+3]=Math.round(t[3])}if(null!=t){aS||null!=(0,ax.getKernel)(aN.Draw,av.ENGINE.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),aS=!0),t.width=s,t.height=a;let e=t.getContext("2d"),r=new ImageData(u,s,a);e.putImageData(r,0,0)}return r!==e&&r.dispose(),u}function aA(e,t,r){let a=(0,rO.convertToTensor)(e,"img","draw");if(!(e instanceof n.Tensor)){let e=a;a=(0,B.cast)(e,"int32"),e.dispose()}ak(a);var s=null==r?void 0:r.imageOptions;let i=(null==s?void 0:s.alpha)||1;if(i>1||i<0)throw Error(`Alpha value ${i} is suppoed to be in range [0 - 1].`);let o={image:a};av.ENGINE.runKernel(aN.Draw,o,{canvas:t,options:r})}let aP=(0,rC.op)({fromPixels_:aE});e.s(["draw",()=>aA,"fromPixels",0,aP,"fromPixelsAsync",()=>aw,"toPixels",()=>aI],193347)},609068,e=>{"use strict";var t=e.i(193347);e.s(["browser",0,t])},960573,e=>{"use strict";e.s([],236575),e.i(236575);var t=e.i(665971),r=e.i(147602);e.s(["nonMaxSuppressionV3Impl",()=>t.nonMaxSuppressionV3Impl,"nonMaxSuppressionV4Impl",()=>t.nonMaxSuppressionV4Impl,"nonMaxSuppressionV5Impl",()=>t.nonMaxSuppressionV5Impl,"whereImpl",()=>r.whereImpl],960573)},302458,e=>{"use strict";e.s(["version",()=>"4.22.0"])}]);

//# debugId=32d3dae6-4078-14b4-7303-edd6dec38687
//# sourceMappingURL=1db682abca2a1a89.js.map